<!DOCTYPE HTML>
<html>
<head>
	<title>QUnit test for calcLib.js</title>

	<!--
	<link rel='stylesheet' href='http://code.jquery.com/qunit/qunit-2.17.1.css' />
	<script src='http://code.jquery.com/jquery-1.11.0.min.js'></script>
	<script src='http://code.jquery.com/qunit/qunit-2.17.1.js'></script>

	<script>window.jQuery || document.write('<script src='local-source.js'><\/script>')</script>
	-->

	<link rel='stylesheet' href='qunit/qunit-2.17.1.css' />
	<script src='jquery/jquery-2.1.1.min.js'></script>
	<script src='qunit/qunit-2.17.1.js'></script>
	<script src='underscore/underscore-min.js'></script>

	<script src="sharedLib.js"></script>
	<script src="coordLib.js"></script>
	<script src="calcLib.js"></script>
</head>
<body>
	<div id="qunit"></div>
	<div id="qunit-fixture"></div>
</body>

<script>$(document).ready(function () {
	'use strict';
	var withinRange = MLB.sharedLib.withinRange,
		uom = MLB.sharedLib.uom,
		calcSagittaSpherical = MLB.calcLib.calcSagittaSpherical,
		calcSagittaParabolic = MLB.calcLib.calcSagittaParabolic,
		calcFocalRatio = MLB.calcLib.calcFocalRatio,
		calcFocalRatioFromSphericalSagitta = MLB.calcLib.calcFocalRatioFromSphericalSagitta,
		calcSagittalVolume = MLB.calcLib.calcSagittalVolume,
		calcSagittalVolumeParabolic = MLB.calcLib.calcSagittalVolumeParabolic,
		calcSagittalVolumeRemovedDuringParabolization = MLB.calcLib.calcSagittalVolumeRemovedDuringParabolization,
		glassRemovalDuringPolishingFrom10MicronAluminumOxideCubicInches = MLB.calcLib.glassRemovalDuringPolishingFrom10MicronAluminumOxideCubicInches,
		inchesToWavesGreenLight = MLB.calcLib.inchesToWavesGreenLight,
		calcRotatingFurnaceRPM = MLB.calcLib.calcRotatingFurnaceRPM,
		calcOffAxisIllumination = MLB.calcLib.calcOffAxisIllumination,
		getMagnitudeFromIllum = MLB.calcLib.getMagnitudeFromIllum,
		getIllumFromMagnitude = MLB.calcLib.getIllumFromMagnitude,
		addMagnitudes = MLB.calcLib.addMagnitudes,
		addArrayMagnitudes = MLB.calcLib.addArrayMagnitudes,
		magnitudeDifferenceBetweenApertures = MLB.calcLib.magnitudeDifferenceBetweenApertures,
		calculateApertureFromMagnitude = MLB.calcLib.calculateApertureFromMagnitude,
		diagObstructionArea = MLB.calcLib.diagObstructionArea,
		calcDiagOffsetUsingFocalPoint = MLB.calcLib.calcDiagOffsetUsingFocalPoint,
		calcDiagOffsetUsingFullIllumField = MLB.calcLib.calcDiagOffsetUsingFullIllumField,
		calcDiagOffsetUsingEyeToDiagDistance = MLB.calcLib.calcDiagOffsetUsingEyeToDiagDistance,
		calcDiagOffsetUsingFieldEdge = MLB.calcLib.calcDiagOffsetUsingFieldEdge,
		areaIntersectingCircles = MLB.calcLib.areaIntersectingCircles,
		getDiagIllumArray = MLB.calcLib.getDiagIllumArray,
		calcBinoscopeMinimumFocalPlaneToSecondaryDistance = MLB.calcLib.calcBinoscopeMinimumFocalPlaneToSecondaryDistance,
		calcBinoscopeSecondaryBendingAngle = MLB.calcLib.calcBinoscopeSecondaryBendingAngle,
		calcBinoscopeEquivalentApertureBinoviewer = MLB.calcLib.calcBinoscopeEquivalentApertureBinoviewer,
		calcBinoscopeEquivalentApertureStar = MLB.calcLib.calcBinoscopeEquivalentApertureStar,
		calcBinoscopeEquivalentApertureNebulosity = MLB.calcLib.calcBinoscopeEquivalentApertureNebulosity,
		calcEyepieceDivergenceFromTertiaryBendingAngle = MLB.calcLib.calcEyepieceDivergenceFromTertiaryBendingAngle,
		calcTertiaryBendingAngleFromEyepieceDivergence = MLB.calcLib.calcTertiaryBendingAngleFromEyepieceDivergence,
		calcEyepieceTipdownFromSecToTertTipdownAndTertBend = MLB.calcLib.calcEyepieceTipdownFromSecToTertTipdownAndTertBend,
		calcBinoscope = MLB.calcLib.calcBinoscope,
		getFoldedNewtonianScalingFactor = MLB.calcLib.getFoldedNewtonianScalingFactor,
		calcFoldedNewtonian = MLB.calcLib.calcFoldedNewtonian,
		limitingMagnitude = MLB.calcLib.limitingMagnitude,
		apertureInchesFromMagnitude = MLB.calcLib.apertureInchesFromMagnitude,
		calcSurfaceBrightnessFromArea = MLB.calcLib.calcSurfaceBrightnessFromArea,
		calcMagnitudeFromSurfaceBrightnessAndArea = MLB.calcLib.calcMagnitudeFromSurfaceBrightnessAndArea,
		calcMagnitudePerArcMinSquaredFromSurfaceBrightnessAndEllipticalArea = MLB.calcLib.calcMagnitudePerArcMinSquaredFromSurfaceBrightnessAndEllipticalArea,
		calcEtendue = MLB.calcLib.calcEtendue,
		calcFocalRatioForMaxEtendue = MLB.calcLib.calcFocalRatioForMaxEtendue,
		VisualDetectCalcParms = MLB.calcLib.VisualDetectCalcParms,
		visualDetectCalcData = MLB.calcLib.visualDetectCalcData,
		VisualDetectCalc = MLB.calcLib.VisualDetectCalc,
		VisualDetectCalcExitPupils = MLB.calcLib.VisualDetectCalcExitPupils,
		VisualDetectCalcApertures = MLB.calcLib.VisualDetectCalcApertures,
		calcContrastOfObjectPlusSkyToSky = MLB.calcLib.calcContrastOfObjectPlusSkyToSky,
		calcContrastOfObjectPlusSkyToSky2 = MLB.calcLib.calcContrastOfObjectPlusSkyToSky2,
		calcSkyFromObjectPlusContrast = MLB.calcLib.calcSkyFromObjectPlusContrast,
		calcNewtBaffle = MLB.calcLib.calcNewtBaffle,
		createAltazConstantMotionTrackingErrors = MLB.calcLib.createAltazConstantMotionTrackingErrors,
		calcMirrorSlumpingParms = MLB.calcLib.calcMirrorSlumpingParms,
		calcSphereParabolaDifference = MLB.calcLib.calcSphereParabolaDifference,
		wavefrontError = MLB.calcLib.wavefrontError,
		wavefrontErrorFrom_MirrorDia_RoC_CorrectionFactor_WavelengthLight = MLB.calcLib.wavefrontErrorFrom_MirrorDia_RoC_CorrectionFactor_WavelengthLight,
		wavefrontErrorFromCorrectionsArray = MLB.calcLib.wavefrontErrorFromCorrectionsArray,
		findAllowableCorrection = MLB.calcLib.findAllowableCorrection,
		calcAllowableParabolicDeviationForQuarterWavefront = MLB.calcLib.calcAllowableParabolicDeviationForQuarterWavefront,
		calcDobFriction = MLB.calcLib.calcDobFriction,
		SQMtoNELMconverter = MLB.calcLib.SQMtoNELMconverter,
		NELMtoSQMconverter = MLB.calcLib.NELMtoSQMconverter,
		artificialStarDistanceMM = MLB.calcLib.artificialStarDistanceMM,
		artificialStarDistanceInches = MLB.calcLib.artificialStarDistanceInches,
		calcApertureFromFOV_EyepieceFL_EyepieceFieldStop_Pupil = MLB.calcLib.calcApertureFromFOV_EyepieceFL_EyepieceFieldStop_Pupil,
		calcFOVFromAperture_EyepieceFL_EyepieceFieldStop_Pupil = MLB.calcLib.calcFOVFromAperture_EyepieceFL_EyepieceFieldStop_Pupil,
		calcPupilFromAperture_FOV_EyepieceFL_EyepieceFieldStop = MLB.calcLib.calcPupilFromAperture_FOV_EyepieceFL_EyepieceFieldStop,
		calcEyepieceFieldStopFromAperture_FOV_EyepieceFL_Pupil = MLB.calcLib.calcEyepieceFieldStopFromAperture_FOV_EyepieceFL_Pupil,
		calcEyepieceFLFromAperture_FOV_EyepieceFieldStop_Pupil = MLB.calcLib.calcEyepieceFLFromAperture_FOV_EyepieceFieldStop_Pupil,
		calcApertureFromFOV_EyepieceFL_EyepieceFieldStop_Pupil_ComaCorrectorMag = MLB.calcLib.calcApertureFromFOV_EyepieceFL_EyepieceFieldStop_Pupil_ComaCorrectorMag,
		calcApertureFromFOV_FocalRatio_EyepieceFieldStop = MLB.calcLib.calcApertureFromFOV_FocalRatio_EyepieceFieldStop,
		calcFOVFromAperture_FocalRatio_EyepieceFieldStop = MLB.calcLib.calcFOVFromAperture_FocalRatio_EyepieceFieldStop,
		calcFocalRatioFromAperture_FOV_EyepieceFieldStop = MLB.calcLib.calcFocalRatioFromAperture_FOV_EyepieceFieldStop,
		calcEyepieceFieldStopFromAperture_FOV_FocalRatio = MLB.calcLib.calcEyepieceFieldStopFromAperture_FOV_FocalRatio,
		calcApertureFromFOV_FocalRatio_EyepieceFieldStop_ComaCorrectorFactor = MLB.calcLib.calcApertureFromFOV_FocalRatio_EyepieceFieldStop_ComaCorrectorFactor,
		calcFOVFromAperture_FocalRatio_EyepieceFieldStop_ComaCorrectorFactor = MLB.calcLib.calcFOVFromAperture_FocalRatio_EyepieceFieldStop_ComaCorrectorFactor,
		calcFocalRatioFromAperture_FOV_EyepieceFieldStop_ComaCorrectorFactor = MLB.calcLib.calcFocalRatioFromAperture_FOV_EyepieceFieldStop_ComaCorrectorFactor,
		calcEyepieceFieldStopFromAperture_FOV_FocalRatio_ComaCorrectorFactor = MLB.calcLib.calcEyepieceFieldStopFromAperture_FOV_FocalRatio_ComaCorrectorFactor,
		calcMagnificationFromApertureAndPupil = MLB.calcLib.calcMagnificationFromApertureAndPupil,
		calcDetectionFromContrastAndObjectApparentSize = MLB.calcLib.calcDetectionFromContrastAndObjectApparentSize,
		translateDetectionLevelIntoWords = MLB.calcLib.translateDetectionLevelIntoWords,
		resolutionFromAperture_Magnification = MLB.calcLib.resolutionFromAperture_Magnification,
		calcTheoreticalResolutionArcsec = MLB.calcLib.calcTheoreticalResolutionArcsec,
		calcAiryDiskInches = MLB.calcLib.calcAiryDiskInches,
		calcMilliesLacroixTolerance = MLB.calcLib.calcMilliesLacroixTolerance,
		calcParabolicCorrectionForZone = MLB.calcLib.calcParabolicCorrectionForZone,
		calcProjectedFocuserBaffleRadius = MLB.calcLib.calcProjectedFocuserBaffleRadius,
		scalingFactor = MLB.calcLib.scalingFactor,
		calcMaxMagnification = MLB.calcLib.calcMaxMagnification,
		calcMinMagnification = MLB.calcLib.calcMinMagnification,
		calcWilliamHerschelSpacePenetratingPower = MLB.calcLib.calcWilliamHerschelSpacePenetratingPower,
		calcComaFreeDiaInches = MLB.calcLib.calcComaFreeDiaInches,
		calcDiopter = MLB.calcLib.calcDiopter,
		calcFocalLengthInches = MLB.calcLib.calcFocalLengthInches,
		calcMagnifyingLensPower = MLB.calcLib.calcMagnifyingLensPower,
		calcStrehlFromRMS = MLB.calcLib.calcStrehlFromRMS,
		calcRMSFromStrehl = MLB.calcLib.calcRMSFromStrehl,
		calcPVFromRMS = MLB.calcLib.calcPVFromRMS,
		calcRMSFromPV = MLB.calcLib.calcRMSFromPV,
		calcApertureFromEyepieceApparentFOVdegs_Pupil_ObjectApparentSize = MLB.calcLib.calcApertureFromEyepieceApparentFOVdegs_Pupil_ObjectApparentSize,
		calcComa = MLB.calcLib.calcComa,
		calcGreaterComa = MLB.calcLib.calcGreaterComa,
		calcGreaterComaWithComaCorrector = MLB.calcLib.calcGreaterComaWithComaCorrector,
		calcCollimationToleranceInches = MLB.calcLib.calcCollimationToleranceInches,
		calcMinimumMirrorSupportPoints = MLB.calcLib.calcMinimumMirrorSupportPoints,
		calcMirrorCellDimensions = MLB.calcLib.calcMirrorCellDimensions,
		calcRMSCausedByCentralObstruction = MLB.calcLib.calcRMSCausedByCentralObstruction,
		findOffsetCenterBetweenTwoPoints = MLB.calcLib.findOffsetCenterBetweenTwoPoints,
		findWeightedCenterOfPoints = MLB.calcLib.findWeightedCenterOfPoints,
		calcToolVolume = MLB.calcLib.calcToolVolume,
		calcMirrorWeight = MLB.calcLib.calcMirrorWeight,
		calcLensCG = MLB.calcLib.calcLensCG,
		calcMirrorCG = MLB.calcLib.calcMirrorCG,
		WaineoSphericalNull = MLB.calcLib.WaineoSphericalNull;

	QUnit.module('sagitta');

	QUnit.test('calcSagittaSpherical', assert => {
		var result = calcSagittaSpherical(13, 3);
		assert.equal(withinRange(result, 0.271305, 0.000001), true, 'The sagitta should be 0.271305, is ' + result);
	});

	QUnit.test('calcFocalRatio', assert => {
		var result = calcFocalRatio(13, 0.2713051698409146);
		assert.equal(withinRange(result, 3, 0.000001), true, 'The focal ratio should be 3.0, is ' + result);
	});

	QUnit.test('calcSagittaParabolic', assert => {
		var mirrorDia = 30,
			focalRatio = 0.25,
			expectedSphericalSagitta = 7.5,
			result = calcSagittaParabolic(mirrorDia, focalRatio);
		assert.equal(result, expectedSphericalSagitta, 'sagitta is ' + result);
	});

	QUnit.test('calcFocalRatioFromSphericalSagitta', assert => {
		var result = calcFocalRatioFromSphericalSagitta(30, 7.5);
		assert.equal(withinRange(result, 0.25, 0.000001), true, 'The focal ratio should be 0.25, is ' + result);
	});

	// http://www.1728.org/sphere.htm and http://www.had2know.com/academics/spherical-cap-volume-surface-area-calculator.html
	QUnit.test('calcSagittalVolume', assert => {
		var expected = 6.1439,
			result = calcSagittalVolume(10, 4);
		assert.equal(withinRange(result, expected, 0.0001), true, 'The sagittal volume should be ' + expected + ', is ' + result);

		expected = 56287;
		result = calcSagittalVolume(70, 37 / 70 / 2);
		assert.equal(withinRange(result, expected, 1), true, 'The sagittal volume should be ' + expected + ', is ' + result);
	});

	QUnit.test('calcSagittalVolumeParabolic', assert => {
		var expected = 6.1379,
			result = calcSagittalVolumeParabolic(10, 4);
		assert.equal(withinRange(result, expected, 0.0001), true, 'The sagittal volume should be ' + expected + ', is ' + result);
	});

	QUnit.test('calcSagittalVolumeRemovedDuringParabolization', assert => {
		var expected = 0.006,
			result = calcSagittalVolumeRemovedDuringParabolization(10, 4);
		assert.equal(withinRange(result, expected, 0.0001), true, 'The sagittal volume should be ' + expected + ', is ' + result);
	});

	QUnit.test('glassRemovalDuringPolishingFrom10MicronAluminumOxideCubicInches', assert => {
		var expected =  0.030915,
			result = glassRemovalDuringPolishingFrom10MicronAluminumOxideCubicInches(10, 5);
		// area increase for F5 should be from 78.54 square inches to 78.59 square inches
		assert.equal(withinRange(result, expected, 0.000001), true, 'Glass removed from a 10 inch F5 during polishing from 10 micron aluminum oxide should be ' + expected + ', is ' + result);

		expected =  0.030921;
		// essentially flat mirror
		result = glassRemovalDuringPolishingFrom10MicronAluminumOxideCubicInches(10, 100);
		// area increase for F5 should be from 78.54 square inches to 78.59 square inches
		assert.equal(withinRange(result, expected, 0.000001), true, 'Glass removed from a 10 inch F100 during polishing from 10 micron aluminum oxide should be ' + expected + ', is ' + result);
	});

	QUnit.test('inchesToWavesGreenLight', assert => {
		var sphereParabolaDifferenceInches = 0.000579, // 16" f3
			expected = 26.31,
			result = inchesToWavesGreenLight(sphereParabolaDifferenceInches);
		assert.equal(withinRange(result, expected, 0.01), true, 'converting from inches to waves of green light should be ' + expected + ', is ' + result);
	});

	QUnit.test('calcRotatingFurnaceRPM', assert => {
		var focalLengthMeters = 2,
			expected = 14.95,
			result = calcRotatingFurnaceRPM(focalLengthMeters);
		assert.equal(withinRange(result, expected, 0.01), true, 'rotating furnance RPM for focal length in meters of ' + focalLengthMeters + ' should be ' + expected + ', is ' + result);
	});

	QUnit.module('diagonal sizing');

	QUnit.test('calcOffAxisIllumination', assert => {
		var result = calcOffAxisIllumination(13.2, 40.3, 3.1, 9, 0.5);
		assert.equal(withinRange(result, 0.878, 0.001), true, 'The off-axis illumination should be .878, is ' + result);

		result = calcOffAxisIllumination(13.2, 40.3, 3.1, 9, 0.1);
		assert.equal(withinRange(result, 0.999, 0.001), true, 'The off-axis illumination should be .999, is ' + result);

		result = calcOffAxisIllumination(13.2, 40.3, 3.1, 9, 0);
		assert.equal(withinRange(result, 1.0, 0.001), true, 'The off-axis illumination should be 1.0, is ' + result);

		result = calcOffAxisIllumination(13.2, 40.3, 3.5, 9, 0.5);
		assert.equal(withinRange(result, 0.973, 0.001), true, 'The off-axis illumination should be .973, is ' + result);

		result = calcOffAxisIllumination(13.2, 40.3, 3.5, 9, 0.1);
		assert.equal(withinRange(result, 1.0, 0.001), true, 'The off-axis illumination should be 1.0, is ' + result);

		result = calcOffAxisIllumination(13.2, 40.3, 3.5, 9, 0);
		assert.equal(withinRange(result, 1.0, 0.001), true, 'The off-axis illumination should be 1.0, is ' + result);
	});

	QUnit.test('getMagnitudeFromIllum', assert => {
		var result = getMagnitudeFromIllum(0.878011030887435);
		assert.equal(withinRange(result, 0.141, 0.001), true, 'The magnitude should be 0.141, is ' + result);
	});

	QUnit.test('getMagnitudeFromIllum', assert => {
		var result = getMagnitudeFromIllum(0.71);
		assert.equal(withinRange(result, 0.37, 0.01), true, 'The magnitude should be 0.37, is ' + result);
	});

	QUnit.test('getMagnitudeFromIllum', assert => {
		var result = getMagnitudeFromIllum(0.96);
		assert.equal(withinRange(result, 0.04, 0.01), true, 'The magnitude should be 0.04, is ' + result);
	});

	QUnit.test('getMagnitudeFromIllum', assert => {
		var result = getMagnitudeFromIllum(1.04);
		assert.equal(withinRange(result, -0.04, 0.01), true, 'The magnitude should be -0.04, is ' + result);
	});

	QUnit.test('getIllumFromMagnitude', assert => {
		var result = getIllumFromMagnitude(0.37);
		assert.equal(withinRange(result, 0.71, 0.01), true, 'The inverse magnitude drop should be .71, is ' + result);
	});

	QUnit.test('addMagnitudes', assert => {
		var result = addMagnitudes(5, 6);
		assert.equal(withinRange(result, 4.636, 0.001), true, 'magnitudes 5 and 6 added should be 4.636, is ' + result);
	});

	QUnit.test('addArrayMagnitudes', assert => {
		var result = addArrayMagnitudes([5, 6, 7]);
		assert.equal(withinRange(result, 4.520, 0.001), true, 'array of magnitudes should add to 4.520, is ' + result);
	});

	QUnit.test('addArrayMagnitudes', assert => {
		var result = addArrayMagnitudes();
		assert.equal(result, undefined, 'missing array should return undefined');

		result = addArrayMagnitudes([]);
		assert.equal(result, undefined, 'empty array should return undefined');
	});

	QUnit.test('magnitudeDifferenceBetweenApertures', assert => {
		var result = magnitudeDifferenceBetweenApertures(10, 20);
		assert.equal(withinRange(result, -1.5, 0.01), true, 'The difference in magnitude between apertures of 10 and 20 should be -1.5, is ' + result);
	});

	QUnit.test('calculateApertureFromMagnitude', assert => {
		var magLoss = 0,
		    expected = 1,
		    result = calculateApertureFromMagnitude(magLoss);

		assert.equal(withinRange(result, expected, 0.01), true, 'Equivalent aperture with magnitude drop of ' +  magLoss + ' is ' + result);

		magLoss = 0.4;
		expected = 0.83;
		result = calculateApertureFromMagnitude(magLoss);
		assert.equal(withinRange(result, expected, 0.01), true, 'Equivalent aperture with magnitude drop of ' +  magLoss + ' is ' + result);
	});

	QUnit.test('diagObstructionArea', assert => {
		var result = diagObstructionArea(10, 1);
		assert.equal(withinRange(result, 0.01, 0), true, 'The diagonal obstruction should be 0.01, is ' + result);
	});

	QUnit.test('calcDiagOffsetUsingFocalPoint', assert => {
		var result = calcDiagOffsetUsingFocalPoint(13.2, 40.3, 3.1, 9);
		assert.equal(withinRange(result, 0.25, 0.01), true, 'The diagonal offset should be .25, is ' + result);

		// 30" F2.7
		result = calcDiagOffsetUsingFocalPoint(30, 82, 6.5, 17);
		assert.equal(withinRange(result, 0.59, 0.01), true, 'The diagonal offset should be .59, is ' + result);
	});

	QUnit.test('calcDiagOffsetUsingFullIllumField', assert => {
		var result = calcDiagOffsetUsingFullIllumField(13.2, 40.3, 3.1, 9);
		assert.equal(withinRange(result, -0.26, 0.01), true, 'The diagonal offset2 should be -.26, is ' + result);

		// 30" F2.7
		result = calcDiagOffsetUsingFullIllumField(30, 82, 6.5, 17);
		assert.equal(withinRange(result, -0.61, 0.01), true, 'The diagonal offset2 should be -.61, is ' + result);
	});

	QUnit.test('calcDiagOffsetUsingEyeToDiagDistance', assert => {
		var result = calcDiagOffsetUsingEyeToDiagDistance(3.1, 9);
		assert.equal(withinRange(result, -0.26, 0.01), true, 'The diagonal offset3 should be -.26, is ' + result);

		// add 4 inches for the eye to focal plane distance
		var result = calcDiagOffsetUsingEyeToDiagDistance(3.1, 13);
		assert.equal(withinRange(result, -0.18, 0.01), true, 'The diagonal offset3 should be -.18 with 4 inches eye to focal plane distance, is ' + result);

		// 30" F2.7
		result = calcDiagOffsetUsingEyeToDiagDistance(6.5, 17);
		assert.equal(withinRange(result, -0.62, 0.01), true, 'The diagonal offset3 should be -.62, is ' + result);
		// add 4 inches for the eye to focal plane distance
		result = calcDiagOffsetUsingEyeToDiagDistance(6.5, 21);
		assert.equal(withinRange(result, -0.50, 0.01), true, 'The diagonal offset3 should be -.50 with 4 inches eye to focal plane distance, is ' + result);
	});

	QUnit.test('calcDiagOffsetUsingFieldEdge', assert => {
		var result = calcDiagOffsetUsingFieldEdge(3.1, 9, 1.4);
		assert.equal(withinRange(result, 0.16, 0.01), true, 'The diagonal offset from the field edge should be .16, is ' + result);

		// example from the Sketchup graphic
		result = calcDiagOffsetUsingFieldEdge(2.828, 3, 2);
		assert.equal(withinRange(result, 0.23, 0.01), true, 'The diagonal offset from the field edge should be .23, is ' + result);

		// 30" F2.7
		result = calcDiagOffsetUsingFieldEdge(6.5, 17, 1.2);
		assert.equal(withinRange(result, 0.60, 0.01), true, 'The diagonal offset from the field edge should be .60, is ' + result);
	});

	QUnit.test('areaIntersectingCircles', assert => {
		var result = areaIntersectingCircles(100, 0, 100, 200, 0, 100) / (Math.PI * 100 * 100),
			expected = 0.391;

		assert.equal(withinRange(result, expected, 0.001), true, 'The intersecting circle area should be, ' + expected + ', is ' + result);
	});

	/* eg,
	-0.7000000000000001,0.8109570241529027
	-0.6000000000000001,0.8444947700225293,
	-0.5,0.878011030887435,
	-0.4,0.9113610077701036,
	-0.30000000000000004,0.9442331974332544,
	-0.2,0.9757007976643087,
	-0.1,0.9999028396353284,
	0,1,
	0.1,0.9999028396353284,
	0.2,0.9757007976643087,
	0.30000000000000004,0.9442331974332544,
	0.4,0.9113610077701036,
	0.5,0.878011030887435,
	0.6000000000000001,0.8444947700225293,
	0.7000000000000001,0.8109570241529027
	*/
	QUnit.test('getDiagIllumArray', assert => {
		var result = getDiagIllumArray(13.2, 40.3, 3.1, 9, 0.1, 1.38);
		assert.equal(result.length, 15, 'the array length should be 15, is ' + result.length + '; the array is ' + result);
		assert.equal(withinRange(result[1][1], 0.844, 0.001), true, 'The off-axis illumination should be 0.844, is ' + result[1][1]);
		assert.equal(withinRange(result[13][1], 0.844, 0.001), true, 'The off-axis illumination should be 0.844, is ' + result[13][1]);

		result = getDiagIllumArray(13.2, 40.3, 3.5, 9, 0.1, 1.38);
		assert.equal(result.length, 15, 'the array length should be 15, is ' + result.length + '; the array is ' + result);
		assert.equal(withinRange(result[1][1], 0.945, 0.001), true, 'The off-axis illumination should be 0.945, is ' + result[1][1]);
		assert.equal(withinRange(result[13][1], 0.945, 0.001), true, 'The off-axis illumination should be 0.945, is ' + result[13][1]);
	});

	QUnit.module('calcBinoscope');

	// for matching CAD layout, see  binoLayoutForNewtDesigner1.jpg, binoLayoutForNewtDesigner2.jpg, binoLayoutForNewtDesigner3.jpg
	// call is calcBinoscopeMinimumFocalPlaneToSecondaryDistance(aperture, focalPointPerpendicularOffsetFromEdgeOfPrimary, focalPlaneToTertiaryDistance, secondaryBendingAngleDeg, tertiaryBendingAngleDeg)
	QUnit.test('calcBinoscopeMinimumFocalPlaneToSecondaryDistance', assert => {
		var allowableError = 0.001,
			// secondary bending but no tertiary bending
			aperture = 10,
			focalPointPerpendicularOffsetFromEdgeOfPrimary = 3,
			focalPlaneToTertiaryDistance = 5,
			secondaryBendingAngleDeg = 53.130,
			tertiaryBendingAngleDeg = 0,
			expected = 15,
			result = calcBinoscopeMinimumFocalPlaneToSecondaryDistance(aperture, focalPointPerpendicularOffsetFromEdgeOfPrimary, focalPlaneToTertiaryDistance, secondaryBendingAngleDeg, tertiaryBendingAngleDeg);

		assert.equal(withinRange(result.minimumFocalPlaneToSecondaryDistance, expected, allowableError), true, 'The minimum focal plane to secondary length with secondaryBendingAngleDeg should be ' + expected + ', is ' + result.minimumFocalPlaneToSecondaryDistance);

		// secondary bending and tertiary bending
		aperture = 10;
		focalPointPerpendicularOffsetFromEdgeOfPrimary = 3;
		focalPlaneToTertiaryDistance = 5;
		secondaryBendingAngleDeg = 53.130;
		tertiaryBendingAngleDeg = 30;
		expected = 11.875;
		allowableError = 0.001;
		result = calcBinoscopeMinimumFocalPlaneToSecondaryDistance(aperture, focalPointPerpendicularOffsetFromEdgeOfPrimary, focalPlaneToTertiaryDistance, secondaryBendingAngleDeg, tertiaryBendingAngleDeg);

		assert.equal(withinRange(result.minimumFocalPlaneToSecondaryDistance, expected, allowableError), true, 'The minimum focal plane to secondary length with secondaryBendingAngleDeg and tertiaryBendingAngleDeg should be ' + expected + ', is ' + result.minimumFocalPlaneToSecondaryDistance);

		// no bending
		aperture = 10;
		focalPointPerpendicularOffsetFromEdgeOfPrimary = 3;
		focalPlaneToTertiaryDistance = 5;
		secondaryBendingAngleDeg = 90;
		tertiaryBendingAngleDeg = 0;
		expected = 13;
		allowableError = 0.001;
		result = calcBinoscopeMinimumFocalPlaneToSecondaryDistance(aperture, focalPointPerpendicularOffsetFromEdgeOfPrimary, focalPlaneToTertiaryDistance, secondaryBendingAngleDeg, tertiaryBendingAngleDeg);

		assert.equal(withinRange(result.minimumFocalPlaneToSecondaryDistance, expected, allowableError), true, 'The minimum focal plane to secondary length with no bending should be ' + expected + ', is ' + result.minimumFocalPlaneToSecondaryDistance);
	});

	// function call is calcBinoscopeSecondaryBendingAngle(aperture, focalPointPerpendicularOffsetFromEdgeOfPrimary, focalPlaneToSecondaryDistance, focalPlaneToTertiaryDistance, tertiaryBendingAngleDeg)
	QUnit.test('calcBinoscopeSecondaryBendingAngle', assert => {
		var allowableError = 0.001,
			// ex a: no tertiary bending
			aperture = 10,
			focalPointPerpendicularOffsetFromEdgeOfPrimary = 3,
		    focalPlaneToSecondaryDistance = 15,
			focalPlaneToTertiaryDistance = 5,
			tertiaryBendingAngleDeg = 0,
			expected = 53.130,
			result = calcBinoscopeSecondaryBendingAngle(aperture, focalPointPerpendicularOffsetFromEdgeOfPrimary, focalPlaneToSecondaryDistance, focalPlaneToTertiaryDistance, tertiaryBendingAngleDeg);

		assert.equal(withinRange(result.elbowAngleDeg, expected, allowableError), true, 'The binoscope secondary bending angle should be ' + expected + ', is ' + result.elbowAngleDeg);

		// ex b: 30 deg tertiary bending
		aperture = 10,
		focalPointPerpendicularOffsetFromEdgeOfPrimary = 3,
		focalPlaneToSecondaryDistance = 11.875;
		focalPlaneToTertiaryDistance = 5;
		tertiaryBendingAngleDeg = 30;
		expected = 53.130;
		result = calcBinoscopeSecondaryBendingAngle(aperture, focalPointPerpendicularOffsetFromEdgeOfPrimary, focalPlaneToSecondaryDistance, focalPlaneToTertiaryDistance, tertiaryBendingAngleDeg);

		assert.equal(withinRange(result.elbowAngleDeg, expected, allowableError), true, 'The binoscope secondary bending angle should be ' + expected + ', is ' + result.elbowAngleDeg);

		// no bending of secondary or tertiary
		aperture = 10,
		focalPointPerpendicularOffsetFromEdgeOfPrimary = 3;
		focalPlaneToSecondaryDistance = 13;
		focalPlaneToTertiaryDistance = 5;
		tertiaryBendingAngleDeg = 0;
		expected = 90;
		result = calcBinoscopeSecondaryBendingAngle(aperture, focalPointPerpendicularOffsetFromEdgeOfPrimary, focalPlaneToSecondaryDistance, focalPlaneToTertiaryDistance, tertiaryBendingAngleDeg);

		assert.equal(withinRange(result.elbowAngleDeg, expected, allowableError), true, 'The binoscope secondary bending angle should be ' + expected + ', is ' + result.elbowAngleDeg);

		// no bending of secondary or tertiary: example from NewtDesigner default
		aperture = 10,
		focalPointPerpendicularOffsetFromEdgeOfPrimary = 3;
		focalPlaneToSecondaryDistance = 10;
		focalPlaneToTertiaryDistance = 2;
		tertiaryBendingAngleDeg = 0;
		expected = 90;
		result = calcBinoscopeSecondaryBendingAngle(aperture, focalPointPerpendicularOffsetFromEdgeOfPrimary, focalPlaneToSecondaryDistance, focalPlaneToTertiaryDistance, tertiaryBendingAngleDeg);

		assert.equal(withinRange(result.elbowAngleDeg, expected, allowableError), true, 'The binoscope secondary bending angle should be ' + expected + ', is ' + result.elbowAngleDeg);
	});

	QUnit.test('calcBinoscopeEquivalentApertureBinoviewer', assert => {
		var allowableError = 0.001,
		    aperture = 10,
			result = calcBinoscopeEquivalentApertureBinoviewer(aperture),
			expected = 14;

		assert.equal(withinRange(result, expected, allowableError), true, 'The binoscope aperture gain should be ' + expected + ', is ' + result);
	});

	QUnit.test('calcBinoscopeEquivalentApertureStar', assert => {
		var allowableError = 0.001,
		    aperture = 10,
			result = calcBinoscopeEquivalentApertureStar(aperture),
			expected = {low: 12, high: 14};

		assert.equal(withinRange(result.low, expected.low, allowableError), true, 'The binoscope aperture gain should be ' + expected.low + ', is ' + result.low);
		assert.equal(withinRange(result.high, expected.high, allowableError), true, 'The binoscope aperture gain should be ' + expected.high + ', is ' + result.high);
	});

	QUnit.test('calcBinoscopeEquivalentApertureNebulosity', assert => {
		var allowableError = 0.001,
		    aperture = 10,
			result = calcBinoscopeEquivalentApertureNebulosity(aperture),
			expected = {low: 14, high: 18};

		assert.equal(withinRange(result.low, expected.low, allowableError), true, 'The binoscope aperture gain should be ' + expected.low + ', is ' + result.low);
		assert.equal(withinRange(result.high, expected.high, allowableError), true, 'The binoscope aperture gain should be ' + expected.high + ', is ' + result.high);
	});

	QUnit.test('calcEyepieceDivergenceFromTertiaryBendingAngle', assert => {
		var allowableError = 0.001,
		    tertiaryBendingAngleDeg = 20,
		    secondaryAxisDownwardTiltAngleDeg = 30,
			result = calcEyepieceDivergenceFromTertiaryBendingAngle(tertiaryBendingAngleDeg, secondaryAxisDownwardTiltAngleDeg),
			expected = 17.32;

		assert.equal(withinRange(result, expected, allowableError), true, 'The binoscope eyepiece divergence in deg should be ' + expected + ', is ' + result);
	});

	QUnit.test('calcTertiaryBendingAngleFromEyepieceDivergence', assert => {
		var allowableError = 0.001,
		    eyepieceDivergenceAngleDeg = 17.32,
		    secondaryAxisDownwardTiltAngleDeg = 30,
			result = calcTertiaryBendingAngleFromEyepieceDivergence(eyepieceDivergenceAngleDeg, secondaryAxisDownwardTiltAngleDeg),
			expected = 20;

		assert.equal(withinRange(result, expected, allowableError), true, 'The binoscope tertoaru bending angle in deg should be ' + expected + ', is ' + result);
	});

	QUnit.test('calcEyepieceTipdownFromSecToTertTipdownAndTertBend', assert => {
		var allowableError = 0.001,
		    eyepieceDivergenceDeg = 10,
		    secondaryAxisDownwardTiltAngleDeg = 35,
			result = calcEyepieceTipdownFromSecToTertTipdownAndTertBend(eyepieceDivergenceDeg, secondaryAxisDownwardTiltAngleDeg),
			expected =  5.736;

		assert.equal(withinRange(result, expected, allowableError), true, 'The eyepiece tipdown angle in deg should be ' + expected + ', is ' + result);
	});

	// for matching CAD layout, see  binoLayoutForNewtDesigner1.jpg, binoLayoutForNewtDesigner2.jpg, binoLayoutForNewtDesigner3.jpg
	// function call is calcBinoscope(mirrorDia, focalRatio, focalPointOffsetFromEdgeOfPrimary, focalPlaneToTertiaryDistance, focalPlaneToSecondaryDistance, secondaryBendingAngleDeg, tertiaryBendingAngleDeg, fieldDia)
	QUnit.test('calcBinoscope', assert => {
		var allowableError = 0.001,
		    result = calcBinoscope(30, 3, 5, 5, 27, 65.380, 0, 4);

		assert.equal(withinRange(result.focalLength, 90, allowableError), true, 'The focalLength should be 90, is ' + result.focalLength);
		assert.equal(withinRange(result.primaryToSecondaryDistance, 63, allowableError), true, 'The primaryToSecondaryDistance should be 90, is ' + result.primaryToSecondaryDistance);
		assert.equal(withinRange(result.primaryToP3HorizontalDistance, 58.835, allowableError), true, 'The primaryToP3HorizontalDistance should be 58.835, is ' + result.primaryToP3HorizontalDistance);
		assert.equal(withinRange(result.secondaryToTertiaryDistance, 22, allowableError), true, 'The secondaryToTertiaryDistance should be 22, is ' + result.secondaryToTertiaryDistance);
		assert.equal(withinRange(result.secondaryToTertiaryVerticalLength, 20, allowableError), true, 'The secondaryToTertiaryVerticalLength should be 20, is ' + result.secondaryToTertiaryVerticalLength);
		assert.equal(withinRange(result.secondaryToTertiaryHorizontalLength, 9.165, allowableError), true, 'The secondaryToTertiaryHorizontalLength should be 9.165, is ' + result.secondaryToTertiaryHorizontalLength);
		assert.equal(withinRange(result.elbowAngleDeg, 65.380, allowableError), true, 'The elbowAngleDeg should be 65.380, is ' + result.elbowAngleDeg);
		assert.equal(withinRange(result.anglePrimaryMirrorEdgeToP1Deg, 9.462, allowableError), true, 'The anglePrimaryMirrorEdgeToP1Deg should be 9.462, is ' + result.anglePrimaryMirrorEdgeToP1Deg);
		assert.equal(withinRange(result.anglePrimaryMirrorEdgeToP1AndVerticalDeg, 80.538, allowableError), true, 'The anglePrimaryMirrorEdgeToP1AndVerticalDeg should be 80.538, is ' + result.anglePrimaryMirrorEdgeToP1AndVerticalDeg);
		assert.equal(withinRange(result.secondaryCenterToPrimaryMirrorEdgeRayLength, 4.5, allowableError), true, 'The secondaryCenterToPrimaryMirrorEdgeRayLength should be 4.5, is ' + result.secondaryCenterToPrimaryMirrorEdgeRayLength);
		assert.equal(withinRange(result.angleSecondaryFaceToVerticalDeg, 32.690, allowableError), true, 'The angleSecondaryFaceToVerticalDeg should be 32.690, is ' + result.angleSecondaryFaceToVerticalDeg);
		assert.equal(withinRange(result.secondaryUpperLength, 4.830, allowableError), true, 'The secondaryUpperLength should be 4.830, is ' + result.secondaryUpperLength);
		assert.equal(withinRange(result.secondaryLowerLength, 5.987, allowableError), true, 'The secondaryLowerLength should be 5.987, is ' + result.secondaryLowerLength);
		assert.equal(withinRange(result.secondaryMajorAxis, 10.818, allowableError), true, 'The secondaryMajorAxis should be 10.818, is ' + result.secondaryMajorAxis);
		assert.equal(withinRange(result.secondaryMinorAxis, 9, allowableError), true, 'The secondaryMinorAxis should be 9, is ' + result.secondaryMinorAxis);
		assert.equal(withinRange(result.secondaryOffset, 0.579, allowableError), true, 'The secondaryOffset should be 5.579, is ' + result.secondaryOffset);
		assert.equal(withinRange(result.secondaryUpperPointYLength, 4.065, allowableError), true, 'The secondaryUpperPointYLength should be 4.065, is ' + result.secondaryUpperPointYLength);
		assert.equal(withinRange(result.secondaryUpperPointXLength, 2.609, allowableError), true, 'The secondaryUpperPointXLength should be 2.609, is ' + result.secondaryUpperPointXLength);
		assert.equal(withinRange(result.secondaryLowerPointYLength, 5.039, allowableError), true, 'The secondaryLowerPointYLength should be 5.039, is ' + result.secondaryLowerPointYLength);
		assert.equal(withinRange(result.secondaryLowerPointXLength, 3.234, allowableError), true, 'The secondaryLowerPointXLength should be 3.234, is ' + result.secondaryLowerPointXLength);
		assert.equal(withinRange(result.tertiarySizedForP3UpperLength, 0.894, allowableError), true, 'The tertiarySizedForP3UpperLength should be 0.894, is ' + result.tertiarySizedForP3UpperLength);
		assert.equal(withinRange(result.angleTertiaryFaceToVerticalDeg, 32.690, allowableError), true, 'The angleTertiaryFaceToVerticalDeg should be 32.690, is ' + result.angleTertiaryFaceToVerticalDeg);
		assert.equal(withinRange(result.tertiarySizedForP3LowerLength, 1.109, allowableError), true, 'The tertiarySizedForP3LowerLength should be 1.109, is ' + result.tertiarySizedForP3LowerLength);
		assert.equal(withinRange(result.tertiarySizedForP3MajorAxis, 2.003, allowableError), true, 'The tertiarySizedForP3MajorAxis should be 2.003, is ' + result.tertiarySizedForP3MajorAxis);
		assert.equal(withinRange(result.tertiarySizedForP3MinorAxis, 1.667, allowableError), true, 'The tertiarySizedForP3MinorAxis should be 1.667, is ' + result.tertiarySizedForP3MinorAxis);
		assert.equal(withinRange(result.tertiarySizedForP3Offset, 0.107, allowableError), true, 'The tertiarySizedForP3Offset should be 0.107, is ' + result.tertiarySizedForP3Offset);
		assert.equal(withinRange(result.tertiarySizedForP3UpperPointYLength, 0.753, allowableError), true, 'The tertiarySizedForP3UpperPointYLength should be 0.753, is ' + result.tertiarySizedForP3UpperPointYLength);
		assert.equal(withinRange(result.tertiarySizedForP3UpperPointXLength, 0.483, allowableError), true, 'The tertiarySizedForP3UpperPointXLength should be 0.483, is ' + result.tertiarySizedForP3UpperPointXLength);
		assert.equal(withinRange(result.tertiarySizedForP3LowerPointYLength, 0.933, allowableError), true, 'The tertiarySizedForP3LowerPointYLength should be 0.933, is ' + result.tertiarySizedForP3LowerPointYLength);
		assert.equal(withinRange(result.tertiarySizedForP3LowerPointXLength, 0.599, allowableError), true, 'The tertiarySizedForP3LowerPointXLength should be 0.599, is ' + result.tertiarySizedForP3LowerPointXLength);
		assert.equal(withinRange(result.P2centerXLengthFromSecondaryCenter, 11.248, allowableError), true, 'The P2centerXLengthFromSecondaryCenter should be 11.248, is ' + result.P2centerXLengthFromSecondaryCenter);
		assert.equal(withinRange(result.P2centerYLengthFromSecondaryCenter, 24.545, allowableError), true, 'The P2centerYLengthFromSecondaryCenter should be 24.545, is ' + result.P2centerYLengthFromSecondaryCenter);
		assert.equal(withinRange(result.P2centerXLengthFromTertiaryCenter, 2.083, allowableError), true, 'The P2centerXLengthFromTertiaryCenter should be 2.083, is ' + result.P2centerXLengthFromTertiaryCenter);
		assert.equal(withinRange(result.P2centerYLengthFromTertiaryCenter, 4.545, allowableError), true, 'The P2centerYLengthFromTertiaryCenter should be 4.545, is ' + result.P2centerYLengthFromTertiaryCenter);
		assert.equal(withinRange(result.P2FieldEdgeXLengthFromP2Center, 1.818, allowableError), true, 'The P2FieldEdgeXLengthFromP2Center should be 1.818, is ' + result.P2FieldEdgeXLengthFromP2Center);
		assert.equal(withinRange(result.P2FieldEdgeYLengthFromP2Center, 0.833, allowableError), true, 'The P2FieldEdgeYLengthFromP2Center should be 0.833, is ' + result.P2FieldEdgeYLengthFromP2Center);
		assert.equal(withinRange(result.secondaryRightEdgeToP2FieldRightEdgeX, 12.039, allowableError), true, 'The secondaryRightEdgeToP2FieldRightEdgeX should be 12.039, is ' + result.secondaryRightEdgeToP2FieldRightEdgeX);
		assert.equal(withinRange(result.secondaryRightEdgeToP2FieldRightEdgeY, 21.313, allowableError), true, 'The secondaryRightEdgeToP2FieldRightEdgeY should be 21.313, is ' + result.secondaryRightEdgeToP2FieldRightEdgeY);
		assert.equal(withinRange(result.secondaryLeftEdgeToP2FieldLeftEdgeX, 9.833, allowableError), true, 'The secondaryLeftEdgeToP2FieldLeftEdgeX should be 9.833, is ' + result.secondaryLeftEdgeToP2FieldLeftEdgeX);
		assert.equal(withinRange(result.secondaryLeftEdgeToP2FieldLeftEdgeY, 28.751, allowableError), true, 'The secondaryLeftEdgeToP2FieldLeftEdgeY should be 28.751, is ' + result.secondaryLeftEdgeToP2FieldLeftEdgeY);
		assert.equal(withinRange(result.slopeSecondaryRightEdgeToP2FieldRightEdge, 1.770, allowableError), true, 'The slopeSecondaryRightEdgeToP2FieldRightEdge should be 1.770, is ' + result.slopeSecondaryRightEdgeToP2FieldRightEdge);
		assert.equal(withinRange(result.slopeSecondaryLeftEdgeToP2FieldLeftEdge, 2.924, allowableError), true, 'The slopeSecondaryLeftEdgeToP2FieldLeftEdge should be 2.924, is ' + result.slopeSecondaryLeftEdgeToP2FieldLeftEdge);
		assert.equal(withinRange(result.slopeTertiary, 1.558, allowableError), true, 'The slopeTertiary should be 1.558, is ' + result.slopeTertiary);
		assert.equal(withinRange(result.r1X, 2.773, allowableError), true, 'The r1X should be 2.773, is ' + result.r1X);
		assert.equal(withinRange(result.r2X, -2.632, allowableError), true, 'The r2X should be -2.632, is ' + result.r2X);
		assert.equal(withinRange(result.tertiarySizedForP3FieldUpperPointXLength, 1.475, allowableError), true, 'The tertiarySizedForP3FieldUpperPointXLength should be 1.475, is ' + result.tertiarySizedForP3FieldUpperPointXLength);
		assert.equal(withinRange(result.tertiarySizedForP3FieldUpperPointYLength, 2.298, allowableError), true, 'The tertiarySizedForP3FieldUpperPointYLength should be 2.298, is ' + result.tertiarySizedForP3FieldUpperPointYLength);
		assert.equal(withinRange(result.tertiarySizedForP3FieldUpperLength, 2.731, allowableError), true, 'The tertiarySizedForP3FieldUpperLength should be 2.731, is ' + result.tertiarySizedForP3FieldUpperLength);
		assert.equal(withinRange(result.tertiarySizedForP3FieldLowerPointXLength, 1.717, allowableError), true, 'The tertiarySizedForP3FieldLowerPointXLength should be 1.717, is ' + result.tertiarySizedForP3FieldLowerPointXLength);
		assert.equal(withinRange(result.tertiarySizedForP3FieldLowerPointYLength, 2.675, allowableError), true, 'The tertiarySizedForP3FieldLowerPointYLength should be 2.675, is ' + result.tertiarySizedForP3FieldLowerPointYLength);
		assert.equal(withinRange(result.tertiarySizedForP3FieldLowerLength, 3.179, allowableError), true, 'The tertiarySizedForP3FieldLowerLength should be 3.179, is ' + result.tertiarySizedForP3FieldLowerLength);
		assert.equal(withinRange(result.tertiarySizedForP3FieldMajorAxis, 5.910, allowableError), true, 'The tertiarySizedForP3FieldMajorAxis should be 5.910, is ' + result.tertiarySizedForP3FieldMajorAxis);
		assert.equal(withinRange(result.tertiarySizedForP3FieldMinorAxis, 4.926, allowableError), true, 'The tertiarySizedForP3FieldMinorAxis should be 4.926, is ' + result.tertiarySizedForP3FieldMinorAxis);
		assert.equal(withinRange(result.tertiarySizedForP3FieldOffset, 0.224, allowableError), true, 'The tertiarySizedForP3FieldOffset should be 0.224, is ' + result.tertiarySizedForP3FieldOffset);
		assert.equal(withinRange(result.tertiarySizedForP3FieldAndFocalRatioUpperPointXLength, 1.643, allowableError), true, 'The tertiarySizedForP3FieldAndFocalRatioUpperPointXLength should be 1.643, is ' + result.tertiarySizedForP3FieldAndFocalRatioUpperPointXLength);
		assert.equal(withinRange(result.tertiarySizedForP3FieldAndFocalRatioUpperPointYLength, 2.560, allowableError), true, 'The tertiarySizedForP3FieldAndFocalRatioUpperPointYLength should be 2.560, is ' + result.tertiarySizedForP3FieldAndFocalRatioUpperPointYLength);
		assert.equal(withinRange(result.tertiarySizedForP3FieldAndFocalRatioUpperLength, 3.041, allowableError), true, 'The tertiarySizedForP3FieldAndFocalRatioUpperLength should be 3.041, is ' + result.tertiarySizedForP3FieldAndFocalRatioUpperLength);
		assert.equal(withinRange(result.tertiarySizedForP3FieldAndFocalRatioLowerPointXLength, 2.036, allowableError), true, 'The tertiarySizedForP3FieldAndFocalRatioLowerPointXLength should be 2.036, is ' + result.tertiarySizedForP3FieldAndFocalRatioLowerPointXLength);
		assert.equal(withinRange(result.tertiarySizedForP3FieldAndFocalRatioLowerPointYLength, 3.173, allowableError), true, 'The tertiarySizedForP3FieldAndFocalRatioLowerPointYLength should be 3.173, is ' + result.tertiarySizedForP3FieldAndFocalRatioLowerPointYLength);
		assert.equal(withinRange(result.tertiarySizedForP3FieldAndFocalRatioLowerLength, 3.770, allowableError), true, 'The tertiarySizedForP3FieldAndFocalRatioLowerLength should be 3.770, is ' + result.tertiarySizedForP3FieldAndFocalRatioLowerLength);
	});

	// see binoLayoutForNewtDesigner4: ex a and b
	// function call is calcBinoscope(mirrorDia, focalRatio, focalPointOffsetFromEdgeOfPrimary, focalPlaneToTertiaryDistance, focalPlaneToSecondaryDistance, secondaryBendingAngleDeg, tertiaryBendingAngleDeg, fieldDia)
	QUnit.test('calcBinoscope with tertiary angle', assert => {
		var allowableError = 0.001,
			h,
		    // ex a
		    result = calcBinoscope(10, 4, 3, 5, 15, 53.130, 0, 1);

		assert.equal(withinRange(result.secondaryToTertiaryDistance, 10, allowableError), true, 'The secondaryToTertiaryDistance should be 10, is ' + result.secondaryToTertiaryDistance);
		assert.equal(withinRange(result.secondaryToTertiaryVerticalLength, 8, allowableError), true, 'The secondaryToTertiaryVerticalLength should be 8, is ' + result.secondaryToTertiaryVerticalLength);
		assert.equal(withinRange(result.secondaryToTertiaryHorizontalLength, 6, allowableError), true, 'The secondaryToTertiaryHorizontalLength should be 6, is ' + result.secondaryToTertiaryHorizontalLength);
		assert.equal(withinRange(result.elbowAngleDeg, 53.130, allowableError), true, 'The elbowAngleDeg should be 53.130, is ' + result.elbowAngleDeg);

		//ex b
		result = calcBinoscope(10, 4, 3, 5, 15, 53.130, 30, 1);
		assert.equal(withinRange(result.secondaryToTertiaryDistance, 10, allowableError), true, 'The secondaryToTertiaryDistance should be 10, is ' + result.secondaryToTertiaryDistance);
		assert.equal(withinRange(result.secondaryToTertiaryVerticalLength, 8, allowableError), true, 'The secondaryToTertiaryVerticalLength should be 8, is ' + result.secondaryToTertiaryVerticalLength);
		assert.equal(withinRange(result.secondaryToTertiaryHorizontalLength, 6, allowableError), true, 'The secondaryToTertiaryHorizontalLength should be 6, is ' + result.secondaryToTertiaryHorizontalLength);
		assert.equal(withinRange(result.elbowAngleDeg, 53.130, allowableError), true, 'The elbowAngleDeg should be 53.130, is ' + result.elbowAngleDeg);
		// tertiary to focal point values for 30 deg angle - see binoLayoutForNewtDesigner4 ex b
		assert.equal(withinRange(result.P3centerXLengthFromTertiaryCenter, 4.3301, allowableError), true, 'The P3centerXLengthFromTertiaryCenter should be 4.3301, is ' + result.P3centerXLengthFromTertiaryCenter);
		assert.equal(withinRange(result.P3centerYLengthFromTertiaryCenter, 2.5, allowableError), true, 'The P3centerYLengthFromTertiaryCenter should be 2.5, is ' + result.P3centerYLengthFromTertiaryCenter);
		assert.equal(withinRange(result.P3FieldEdgeXLengthFromP3Center, 0.25, allowableError), true, 'The P3FieldEdgeXLengthFromP3Center should be 0.25, is ' + result.P3FieldEdgeXLengthFromP3Center);
		assert.equal(withinRange(result.P3FieldEdgeYLengthFromP3Center, 0.433, allowableError), true, 'The P3FieldEdgeYLengthFromP3Center should be 0.433, is ' + result.P3FieldEdgeYLengthFromP3Center);
		// hypotenuse of right angle with sides 0.25 and 0.433 should be 0.5
		h = Math.sqrt(result.P3FieldEdgeXLengthFromP3Center * result.P3FieldEdgeXLengthFromP3Center + result.P3FieldEdgeYLengthFromP3Center * result.P3FieldEdgeYLengthFromP3Center);
		assert.equal(withinRange(h, 0.5, allowableError), true, 'The tertiary til plane half length should be 0.5 is ' + h);
		assert.equal(withinRange(result.tertiaryAngledAtPrimaryDeg, 11.565, allowableError), true, 'The tertiaryAngledAtPrimaryDeg should be 11.565, is ' + result.tertiaryAngledAtPrimaryDeg);
		assert.equal(withinRange(result.tertiaryAngledAtFocalPlaneDeg, 41.565, allowableError), true, 'The tertiaryAngledAtFocalPlaneDeg should be 41.565, is ' + result.tertiaryAngledAtFocalPlaneDeg);
		assert.equal(withinRange(result.tertiaryAngledAtMaxLengthMajorAxis, 3.007, allowableError), true, 'The tertiaryAngledAtMaxLengthMajorAxis should be 3.07, is ' + result.tertiaryAngledAtMaxLengthMajorAxis);
		assert.equal(withinRange(result.tertiaryAngledAtMaxLengthMinorAxis, 2.25, allowableError), true, 'The tertiaryAngledAtMaxLengthMinorAxis should be 2.25, is ' + result.tertiaryAngledAtMaxLengthMinorAxis);
		assert.equal(withinRange(result.tertiaryAngledAtXLengthMajorAxisFromTertiaryCenter, 0.301, allowableError), true, 'The tertiaryAngledAtXLengthMajorAxisFromTertiaryCenter should be 0.301, is ' + result.tertiaryAngledAtXLengthMajorAxisFromTertiaryCenter);
		assert.equal(withinRange(result.tertiaryAngledAtYLengthMajorAxisFromTertiaryCenter, 1.473, allowableError), true, 'The tertiaryAngledAtYLengthMajorAxisFromTertiaryCenter should be 1.473, is ' + result.tertiaryAngledAtYLengthMajorAxisFromTertiaryCenter);
	});

	QUnit.module('foldedNewtonian');

	// example: mirror = 30, focal ratio = 3, diag = 8, tertiary distance = 2, eyepiece to mirror = 50, diag to mirror = 66
	// therefore maxWidth = diag to mirror = 66,
	// maxHeight = (diag * focal ratio + tertiary) * 2 = (8*3 + 2)*2 = 52 (primary axis is centered),
	// model width to height = 66/52 = 1.2692308,
	// graphics width = 200, height = 100,
	// graphics width to height = 200/100 = 2,
	// fit model into graphics:
	// if model's width/height > graphics width/height, then model wider than display, else display wider than model,
	// if model w/h > graphics w/h then scale by width: model width / display width, else scale by height: model height / display height,
	// eg, if model w/h = 1.2692308 and display w/h = 2, then display wider than model, given same height,
	// given model w = 66, h = 52 and graphics w = 200, h = 100:
	// therefore scale by height: graphics height of 100 / model height of 52 = scaling factor of 1.9230769,
	// otherwise would scale by width: graphics width of 200 / model width of 66 = scaling factor of 3.030303,
	// using scaling factor of 1.9230769, width = 1.9230769 * 66 = 126.92308, height = 1.9230769 * 52 = 100:
	// so some display width wasted since the narrower model has to fit within;
	// returned scalingFactor made smaller by a margin, eg if scaling factor is 1.9230769 then returned value is 1.53846152;
	// this test ignores tertiaryOffsetFromEdgeOfPrimary;
	QUnit.test('getFoldedNewtonianScalingFactor', assert => {
		var result = getFoldedNewtonianScalingFactor(200, 100, 3, 8, 2, 0, 66);
		assert.equal(withinRange(result, 1.538461, 0.000001), true, 'scalingFactor should be 1.538461, is ' + result);
	});

	// function call is calcFoldedNewtonian(mirrorDia, focalRatio, diagSize, tertiaryOffsetFromEdgeOfPrimary, focalPointToTertiaryDistance, focalPointToDiagDistance)
	QUnit.test('calcFoldedNewtonian', assert => {
		var result = calcFoldedNewtonian(30, 2.9, 7, 0, 3);
		assert.equal(withinRange(result.diagToPrimaryMirrorDistance, 66.7, 0.01), true, 'The diagToPrimaryMirrorDistance should be 66.7, is ' + result.diagToPrimaryMirrorDistance);
		assert.equal(withinRange(result.focalPointToPrimaryMirrorDistance, 58.08, 0.01), true, 'The focalPointToPrimaryMirrorDistance should be 55.08, is ' + result.focalPointToPrimaryMirrorDistance);
		assert.equal(withinRange(result.focalPointToDiagDistance, 20.3, 0.01), true, 'The focalPointToDiagDistance should be 20.3, is ' + result.focalPointToDiagDistance);
		assert.equal(withinRange(result.elbowAngleDeg, 60.12, 0.01), true, 'The elbowAngleDeg should be 60.12, is ' + result.elbowAngleDeg);
		assert.equal(withinRange(result.diagMajorAxisSize, 8.09, 0.01), true, 'The diagMajorAxisSize should be 8.09, is ' + result.diagMajorAxisSize);
	});

	QUnit.test('calcFoldedNewtonian focalPointToPrimaryMirrorDistance and focalPointToTertiaryDistance', assert => {
		var result = calcFoldedNewtonian(30, 3, 10, 0, 0),
			expected = 34.02;
		assert.equal(withinRange(result.focalPointToPrimaryMirrorDistance, expected, 0.01), true, 'The focalPointToPrimaryMirrorDistance should be ' + expected + ', is ' + result.focalPointToPrimaryMirrorDistance);

		// tertiaryOffsetFromEdgeOfPrimary of 1 should shrink diagonal to mirror distance by about 1, give a sufficiently sharp angle (result of a very large diagonal)
		result = calcFoldedNewtonian(30, 3, 10, 0, 1);
		expected = 35.18;
		assert.equal(withinRange(result.focalPointToPrimaryMirrorDistance, expected, 0.01), true, 'The focalPointToPrimaryMirrorDistance should be ' + expected + ', is ' + result.focalPointToPrimaryMirrorDistance);
	});

	// function call is calcFoldedNewtonian(mirrorDia, focalRatio, diagSize, tertiaryOffsetFromEdgeOfPrimary, focalPointToTertiaryDistance, focalPointToDiagDistance)
	QUnit.test('calcFoldedNewtonian with new optional parm focalPointToDiagDistance', assert => {
		var result = calcFoldedNewtonian(30, 2.9, 7, 0, 0, 18);
		assert.equal(withinRange(result.diagToPrimaryMirrorDistance, 69, 0.01), true, 'The diagToPrimaryMirrorDistance should be 69, is ' + result.diagToPrimaryMirrorDistance);
		assert.equal(withinRange(result.focalPointToPrimaryMirrorDistance, 59.05, 0.01), true, 'The focalPointToPrimaryMirrorDistance should be 59.05, is ' + result.focalPointToPrimaryMirrorDistance);
		assert.equal(withinRange(result.focalPointToDiagDistance, 18, 0.01), true, 'The focalPointToDiagDistance should be 18, is ' + result.focalPointToDiagDistance);
		assert.equal(withinRange(result.elbowAngleDeg, 56.44, 0.01), true, 'The elbowAngleDeg should be 56.44, is ' + result.elbowAngleDeg);
		assert.equal(withinRange(result.diagMajorAxisSize, 7.94, 0.01), true, 'The diagMajorAxisSize should be 7.94, is ' + result.diagMajorAxisSize);
	});

	QUnit.module('visual detection calculator: parms and data');

	QUnit.test('limiting magnitude', assert => {
		var apertureIn = 13;
		var expectedLimitingMag = 16.37;
		var result = limitingMagnitude(apertureIn);
		assert.equal(withinRange(result, expectedLimitingMag, 0.01), true, 'limiting magnitude from ' + apertureIn + ' apertureIn should be ' + expectedLimitingMag + ', is ' + result);
	});

	QUnit.test('apertureInchesFromMagnitude', assert => {
		var magnitude = 16.37;
		var expectedApertureIn = 13;
		var result = apertureInchesFromMagnitude(magnitude);
		assert.equal(withinRange(result, expectedApertureIn, 0.01), true, 'aperture from ' + magnitude + ' magnitude should be ' + expectedApertureIn + ', is ' + result);
	});

	QUnit.test('calcSurfaceBrightnessFromArea', assert => {
		var objMag = 5,
		    minObjArcmin = 40,
			maxObjArcmin = 145,
			expectedSurfaceBrightness = 23.03,
			result = calcSurfaceBrightnessFromArea(objMag, minObjArcmin, maxObjArcmin);

		assert.equal(withinRange(result, expectedSurfaceBrightness, 0.01), true, 'surface brightness of ' + result + ' should be ' + expectedSurfaceBrightness + ', is ' + result);
	});

	QUnit.test('calcMagnitudeFromSurfaceBrightnessAndArea', assert => {
		var objSurfaceBrightness = 23.03,
		    minObjArcmin = 40,
			maxObjArcmin = 145,
			expectedMagnitude = 5,
			result = calcMagnitudeFromSurfaceBrightnessAndArea(objSurfaceBrightness, minObjArcmin, maxObjArcmin);

		assert.equal(withinRange(result, expectedMagnitude, 0.01), true, 'magnitude of ' + result + ' should be ' + expectedMagnitude + ', is ' + result);
	});

	QUnit.test('calcMagnitudePerArcMinSquaredFromSurfaceBrightnessAndEllipticalArea', assert => {
		var objSurfaceBrightness = 23.03,
		    minObjArcmin = 40,
			maxObjArcmin = 145,
			expectedMagnitude = 5,
			result = calcMagnitudeFromSurfaceBrightnessAndArea(objSurfaceBrightness, minObjArcmin, maxObjArcmin);

		assert.equal(withinRange(result, expectedMagnitude, 0.01), true, 'magnitude of ' + result + ' should be ' + expectedMagnitude + ', is ' + result);
	});

	QUnit.test('calcEtendue', assert => {
		var apertureCm = 25.4,
		    FOVDeg = 2,
			expectedEtendue = 1591.87,
			result = calcEtendue(apertureCm, FOVDeg);

		assert.equal(withinRange(result, expectedEtendue, 0.01), true, 'etendue of ' + result + ' should be ' + expectedEtendue + ', is ' + result);
	});

	QUnit.test('calcFocalRatioForMaxEtendue', assert => {
		var eyepieceFLmm = 21,
		    eyePupilmm = 6.7,
			comaCorrectorFactor,
			expectedFR = 3.14,
			result = calcFocalRatioForMaxEtendue(eyepieceFLmm, eyePupilmm);

		assert.equal(withinRange(result, expectedFR, 0.01), true, 'focal ratio for max etendue at pupil of = ' + eyePupilmm + 'mm is ' + result + ' should be ' + expectedFR + ', is ' + result);

		comaCorrectorFactor = 1.15;
		expectedFR = 2.73;
		result = calcFocalRatioForMaxEtendue(eyepieceFLmm, eyePupilmm, comaCorrectorFactor);
		assert.equal(withinRange(result, expectedFR, 0.01), true, 'focal ratio for max etendue at pupil of = ' + eyePupilmm + 'mm with coma corrector is ' + result + ' should be ' + expectedFR + ', is ' + result);

		eyePupilmm = 5;
		comaCorrectorFactor = undefined;
		expectedFR = 4.20;
		result = calcFocalRatioForMaxEtendue(eyepieceFLmm, eyePupilmm, comaCorrectorFactor);
		assert.equal(withinRange(result, expectedFR, 0.01), true, 'focal ratio for max etendue at pupil of = ' + eyePupilmm + 'mm is ' + result + ' should be ' + expectedFR + ', is ' + result);

		eyepieceFLmm = 31;
		eyePupilmm = 6;
		comaCorrectorFactor = undefined;
		expectedFR = 5.17;
		result = calcFocalRatioForMaxEtendue(eyepieceFLmm, eyePupilmm, comaCorrectorFactor);
		assert.equal(withinRange(result, expectedFR, 0.01), true, 'focal ratio for max etendue at pupil of = ' + eyePupilmm + 'mm is ' + result + ' should be ' + expectedFR + ', is ' + result);
	});

	QUnit.test('parms.apertureIn', assert => {
		var parms, result, parms2, result2, originalResult;
		parms = new VisualDetectCalcParms();
		parms.apertureIn = 13.2;
		result = parms.apertureIn;
		assert.equal(result, 13.2, 'apertureIn should be 13.2, is ' + result);

		parms2 = new VisualDetectCalcParms();
		parms2.apertureIn = 30;
		result2 = parms2.apertureIn;
		assert.equal(result2, 30, 'copied apertureIn should be 30, is ' + result2);

		originalResult = parms.apertureIn;
		assert.equal(originalResult, 13.2, 'original apertureIn should be 13.2, is ' + result);
	});

	QUnit.test('parms.apertureIn', assert => {
		var parms, result, copiedParms, result2, originalResult;
		parms = new VisualDetectCalcParms();
		parms.apertureIn = 13.2;
		result = parms.apertureIn;
		assert.equal(result, 13.2, 'apertureIn should be 13.2, is ' + result);

		copiedParms = parms.copyFrom();
		copiedParms.apertureIn = 30;
		result2 = copiedParms.apertureIn;
		assert.equal(result2, 30, 'copied apertureIn should be 30, is ' + result2);

		originalResult = parms.apertureIn;
		assert.equal(originalResult, 13.2, 'original apertureIn should be 13.2, is ' + result);
	});

	QUnit.test('visualDetectCalcData.logAngle[1]', assert => {
		var data, result;
		data = visualDetectCalcData;
		result = data.logAngle[1];
		assert.equal(result, 0.5563, 'logAngle[1] should be 0.5563, is ' + result);

		result = data.ltc[1][1];
		assert.equal(result, -1.7747, 'ltc[1][1] should be -1.7747, is ' + result);
	});

	QUnit.module('visual detection calculator: the calculator');

	var visualDetectCalcParms = new VisualDetectCalcParms();
	visualDetectCalcParms.apertureIn = 13;
	visualDetectCalcParms.bkgndBrightEye = 21.5;
	visualDetectCalcParms.objName = 'California Nebula';
	visualDetectCalcParms.objMag = 5;
	visualDetectCalcParms.maxObjArcmin = 145;
	visualDetectCalcParms.minObjArcmin = 40;
	visualDetectCalcParms.eyepieceExitPupilmm = 6;
	visualDetectCalcParms.apparentFoV = 100;
	// can override defaults if desired
	//visualDetectCalcParms.eyeLimitMag = ;
	//visualDetectCalcParms.exitPupilmm = ;
	//visualDetectCalcParms.scopeTrans = ;
	//visualDetectCalcParms.singleEyeFactor = ;

	var visualDetectCalc = new VisualDetectCalc();

	QUnit.test('visualDetectCalc.calc()', assert => {
		var parms, result;
		parms = visualDetectCalcParms.copyFrom();
		result = visualDetectCalc.calc(parms);
		assert.equal(withinRange(result.logContrastDiff,  0.84, 0.01), true, 'The logContrastDiff should be 0.84, is ' + result.logContrastDiff);
		assert.equal(withinRange(result.actualFoV, 1.81708055723804, 0.000001), true, 'The actualFoV should be 1.81708055723804, is ' + result.actualFoV);
		assert.equal(result.fitsFoV, true, 'The object should  fit the field of view, is ' + result.fitsFoV);
		assert.equal(result.detectable, true, 'The object should  be detectable, is ' + result.detectable);
	});

	QUnit.test('visualDetectCalc.calc()', assert => {
		var parms, result;
		parms = visualDetectCalcParms.copyFrom();
		parms.eyepieceExitPupilmm = 4;
		result = visualDetectCalc.calc(parms);
		assert.equal(withinRange(result.logContrastDiff, 0.89, 0.01), true, 'The logContrastDiff should be 0.89, is ' + result.logContrastDiff);
		assert.equal(withinRange(result.actualFoV, 1.21138703815869, 0.000001), true, 'The actualFoV should be 1.21138703815869, is ' + result.actualFoV);
		assert.equal(result.fitsFoV, true, 'The object should  fit the field of view, is ' + result.fitsFoV);
		assert.equal(result.detectable, true, 'The object should  be detectable, is ' + result.detectable);
	});

	QUnit.test('NGC 134 example from Clarke\'s book', assert => {
		var parms, result;
		parms = new VisualDetectCalcParms();
		parms.apertureIn = 8;
		parms.bkgndBrightEye = 24.25;
		parms.objName = 'NGC 134';
		parms.objMag = 11.4;
		parms.maxObjArcmin = 5;
		parms.minObjArcmin = 1;
		// for 187x per book
		parms.eyepieceExitPupilmm = 1.09;
		parms.apparentFoV = 60;
		// overriding defaults
		parms.exitPupilmm = 9;
		parms.scopeTrans = .7;
		parms.singleEyeFactor = 1;
		result = visualDetectCalc.calc(parms);
		console.log(visualDetectCalc.includeResultAsString(visualDetectCalc.calc(parms)).text);
		assert.equal(withinRange(result.logContrastDiff, 1.0, 0.1), true, 'The logContrastDiff should be 1.0, is ' + result.logContrastDiff);
	});

	QUnit.test('Sculptor System example from Clarke\'s book', assert => {
		var parms, result;
		parms = new VisualDetectCalcParms();
		parms.apertureIn = 8;
		parms.bkgndBrightEye = 24.25;
		parms.objName = 'Sculptor System';
		parms.objMag = 8.8;
		parms.maxObjArcmin = 60;
		parms.minObjArcmin = 60;
		// for 27x per book
		parms.eyepieceExitPupilmm = 7.5;
		parms.apparentFoV = 60;
		// overriding defaults
		parms.exitPupilmm = 9;
		parms.scopeTrans = .8;
		parms.singleEyeFactor = 1;
		result = visualDetectCalc.calc(parms);
		console.log('Sculptor System example from Clarke\'s book\n'
			+ 'Clarke  says log difference = 0.4 based on 27x and states that object with no telescope=26.3 and object in telescope at ODM=24.5, and background at magnification=24.6\n'
			+ 'I get log difference = 0.3\n'
			+ visualDetectCalc.includeResultAsString(visualDetectCalc.calc(parms)).text);
		assert.equal(withinRange(result.logContrastDiff, 0.3, 0.1), true, 'The logContrastDiff should be 0.3 (book says 0.4), is ' + result.logContrastDiff);
	});

	QUnit.test('visualDetectCalc.calc()', assert => {
		// compare to my previous C version based on Clark's Visual Astronomy calculates logContrastDiff = 0.51
		// because exitPupilmm=6.5, exitPupilmm=9, scope transmission=.85 and missing single eye factor
		var parms, result;
		parms = new VisualDetectCalcParms();
		parms.apertureIn = 20;
		parms.bkgndBrightEye = 21;
		parms.objName = 'copy from earlier ODM unit test';
		parms.objMag = 12;
		parms.maxObjArcmin = 2;
		parms.minObjArcmin = 2;
		parms.eyepieceExitPupilmm = 7;
		parms.apparentFoV = 100;
		// overriding defaults
		parms.exitPupilmm = 9;
		parms.scopeTrans = .85;
		parms.singleEyeFactor = 1;
		result = visualDetectCalc.calc(parms);
		console.log(visualDetectCalc.includeResultAsString(visualDetectCalc.calc(parms)).text);
		assert.equal(withinRange(result.logContrastDiff, 0.55, 0.01), true, 'The logContrastDiff should be 0.55, is ' + result.logContrastDiff);
	});

	QUnit.test('visualDetectCalc.fitsFoV', assert => {
		var parms, result;
		parms = visualDetectCalcParms.copyFrom();
		parms.eyepieceExitPupilmm = 1;
		result = visualDetectCalc.calc(parms);
		assert.equal(result.fitsFoV, false, 'The object should not fit the field of view, is ' + result.fitsFoV);
	});

	QUnit.test('visualDetectCalc.detectable', assert => {
		var parms, result;
		parms = visualDetectCalcParms.copyFrom();
		parms.objMag = 10;
		result = visualDetectCalc.calc(parms);
		assert.equal(result.detectable, false, 'The object should not be detectable, is ' + result.detectable);
	});

	QUnit.test('visualDetectCalc.includeResultAsString', assert => {
		var parms, result;
		parms = visualDetectCalcParms.copyFrom();
		result = visualDetectCalc.includeResultAsString(visualDetectCalc.calc(parms)).text;
		assert.equal(result.length > 0, true, 'result is ' + result);
	});

	var visualDetectCalcParms2 = new VisualDetectCalcParms();
	visualDetectCalcParms2.apertureIn = 13;
	visualDetectCalcParms2.bkgndBrightEye = 21.5;
	visualDetectCalcParms2.objName = 'Sombrero Galaxy';
	visualDetectCalcParms2.objMag = 8;
	visualDetectCalcParms2.maxObjArcmin = 9;
	visualDetectCalcParms2.minObjArcmin = 4;
	visualDetectCalcParms2.eyepieceExitPupilmm = 6;
	visualDetectCalcParms2.apparentFoV = 110;
	// can override defaults if desired
	//visualDetectCalcParms2.eyeLimitMag = ;
	//visualDetectCalcParms2.exitPupilmm = ;
	//visualDetectCalcParms2.scopeTrans = ;
	//visualDetectCalcParms2.singleEyeFactor = ;

	QUnit.test('visualDetectCalc.includeResultAsString, Sombrero Galaxy through 13 inch f3', assert => {
		var parms, result;
		parms = visualDetectCalcParms2.copyFrom();
		result = visualDetectCalc.includeResultAsString(visualDetectCalc.calc(parms)).text;
		assert.equal(result.length > 0, true, 'result is ' + result);
	});

	QUnit.module('visual detection calculator: eyepiece exit pupil sequence');

	QUnit.test('ExitPupilSequence', assert => {
		var parms, result;
		parms = visualDetectCalcParms.copyFrom();
		// determines array size of exit pupils that VisualDetectCalcExitPupils() builds
		parms.eyepieceExitPupilmm = 7;
		result = new VisualDetectCalcExitPupils(parms);
		// 7mm exit pupil, per above test
		assert.equal(result[6].parms.exitPupilmm, 7, 'The exitPupilmm should be 7, is ' + result[6].parms.exitPupilmm);
		assert.equal(result[6].parms.eyepieceExitPupilmm, 7, 'The eyepieceExitPupilmm should be 7, is ' + result[6].parms.eyepieceExitPupilmm);
		assert.equal(withinRange(result[6].logContrastDiff, 0.83, 0.01), true, 'The logContrastDiff should be 0.83, is ' + result[6].logContrastDiff);
		assert.equal(withinRange(result[6].actualFoV, 2.11992731677771, 0.000001), true, 'The actualFoV should be 2.11992731677771, is ' + result[6].actualFoV);
		// 4mm exit pupil
		assert.equal(result[3].parms.exitPupilmm, 7, 'The exitPupilmm should be 7, is ' + result[3].parms.exitPupilmm);
		assert.equal(result[3].parms.eyepieceExitPupilmm, 4, 'The eyepieceExitPupilmm should be 4, is ' + result[3].parms.eyepieceExitPupilmm);
		assert.equal(withinRange(result[3].logContrastDiff, 0.89, 0.01), true, 'The logContrastDiff should be 0.89, is ' + result[3].logContrastDiff);
		assert.equal(withinRange(result[3].actualFoV, 1.21138703815869, 0.000001), true, 'The actualFoV should be 1.21138703815869, is ' + result[3].actualFoV);
		// 1mm exit pupil
		assert.equal(result[0].parms.exitPupilmm, 7, 'The exitPupilmm should be 7, is ' + result[0].parms.exitPupilmm);
		assert.equal(result[0].parms.eyepieceExitPupilmm, 1, 'The eyepieceExitPupilmm should be 1, is ' + result[0].parms.eyepieceExitPupilmm);
		assert.equal(withinRange(result[0].logContrastDiff, 1.18, 0.01), true, 'The logContrastDiff should be 1.18, is ' + result[0].logContrastDiff);
		assert.equal(withinRange(result[0].actualFoV, 0.302846759539673, 0.000001), true, 'The actualFoV should be 0.302846759539673, is ' + result[0].actualFoV);
	});

	QUnit.module('visual detection calculator: aperture sequence');

	QUnit.test('VisualDetectCalcApertures', assert => {
		var parms, result, halfAperture, dblAperture, halfApertureParms, halfApertureResults, dblApertureParms, dblApertureResults;
		parms = visualDetectCalcParms.copyFrom();
		// determines array size of exit pupils that VisualDetectCalcExitPupils() builds
		parms.eyepieceExitPupilmm = 7;
		result = new VisualDetectCalcApertures(parms);
		// 7mm exit pupil, per above test
		assert.equal(result[1][6].parms.exitPupilmm, 7, 'The exitPupilmm should be 7, is ' + result[1][6].parms.exitPupilmm);
		assert.equal(result[1][6].parms.eyepieceExitPupilmm, 7, 'The eyepieceExitPupilmm should be 7, is ' + result[1][6].parms.eyepieceExitPupilmm);
		assert.equal(withinRange(result[1][6].logContrastDiff, 0.83, 0.01), true, 'The logContrastDiff should be 0.83, is ' + result[1][6].logContrastDiff);
		assert.equal(withinRange(result[1][6].actualFoV, 2.11992731677771, 0.000001), true, 'The actualFoV should be 2.11992731677771, is ' + result[1][6].actualFoV);
		// 4mm exit pupil
		assert.equal(result[1][3].parms.exitPupilmm, 7, 'The exitPupilmm should be 7, is ' + result[1][3].parms.exitPupilmm);
		assert.equal(result[1][3].parms.eyepieceExitPupilmm, 4, 'The eyepieceExitPupilmm should be 4, is ' + result[1][3].parms.eyepieceExitPupilmm);
		assert.equal(withinRange(result[1][3].logContrastDiff, 0.89, 0.01), true, 'The logContrastDiff should be 0.89, is ' + result[1][3].logContrastDiff);
		assert.equal(withinRange(result[1][3].actualFoV, 1.21138703815869, 0.000001), true, 'The actualFoV should be 1.21138703815869, is ' + result[1][3].actualFoV);
		// 1mm exit pupil
		assert.equal(result[1][0].parms.exitPupilmm, 7, 'The exitPupilmm should be 7, is ' + result[1][0].parms.exitPupilmm);
		assert.equal(result[1][0].parms.eyepieceExitPupilmm, 1, 'The eyepieceExitPupilmm should be 1, is ' + result[1][0].parms.eyepieceExitPupilmm);
		assert.equal(withinRange(result[1][0].logContrastDiff, 1.18, 0.01), true, 'The logContrastDiff should be 1.18, is ' + result[1][0].logContrastDiff);
		assert.equal(withinRange(result[1][0].actualFoV, 0.302846759539673, 0.000001), true, 'The actualFoV should be 0.302846759539673, is ' + result[1][0].actualFoV);

		// test apertures
		halfAperture = result[2][0].parms.apertureIn;
		assert.equal(result[1][0].parms.apertureIn/2, halfAperture, 'The aperture should be half of ' + result[1][0].parms.apertureIn + ', is ' + halfAperture);
		dblAperture = result[0][0].parms.apertureIn;
		assert.equal(result[1][0].parms.apertureIn*2, dblAperture, 'The aperture should be double of ' + result[1][0].parms.apertureIn + ', is ' + dblAperture);

		// test logContrasts, at exitPupilmm=6
		halfApertureParms = visualDetectCalcParms.copyFrom();
		halfApertureParms.apertureIn /= 2;
		halfApertureResults = visualDetectCalc.calc(halfApertureParms);
		assert.equal(halfApertureResults.logContrastDiff, result[2][5].logContrastDiff, 'The log contrast should be ' + result[2][5].logContrastDiff + ', is ' + halfApertureResults.logContrastDiff);
		dblApertureParms = visualDetectCalcParms.copyFrom();
		dblApertureParms.apertureIn *= 2;
		dblApertureResults = visualDetectCalc.calc(dblApertureParms);
		assert.equal(dblApertureResults.logContrastDiff, result[0][5].logContrastDiff, 'The log contrast should be ' + result[0][5].logContrastDiff + ', is ' + dblApertureResults.logContrastDiff);
	});

	QUnit.test('calcContrastOfObjectPlusSkyToSky', assert => {
		// M51
		var objMag = 8.4,
		    objectSize1Arcmin = 6.6,
			objectSize2Arcmin = 10.8,
			bkgndBrightEye = 21.6,
			expected = {
				contrastPercent: 94.55,
				objectSurfaceBrightness: 21.66,
				objectPlusSkyBackgroundSurfaceBrightness: 20.88
			},
		    results = calcContrastOfObjectPlusSkyToSky(objMag, objectSize1Arcmin, objectSize2Arcmin, bkgndBrightEye);

		assert.equal(withinRange(results.contrastPercent, expected.contrastPercent, 0.01), true, 'Contrast of M51 to sky background of 21.6 should be ' + expected.contrastPercent + ', is ' + results.contrastPercent);
		assert.equal(withinRange(results.objectSurfaceBrightness, expected.objectSurfaceBrightness, 0.01), true, 'Object surface brightness of M51 should be ' + expected.objectSurfaceBrightness + ', is ' + results.objectSurfaceBrightness);
		assert.equal(withinRange(results.objectPlusSkyBackgroundSurfaceBrightness, expected.objectPlusSkyBackgroundSurfaceBrightness, 0.01), true, 'Object surface brightness of M51 + sky background should be ' + expected.objectPlusSkyBackgroundSurfaceBrightness + ', is ' + results.objectPlusSkyBackgroundSurfaceBrightness);
	});

	QUnit.test('calcContrastOfObjectPlusSkyToSky2', assert => {
		// M51
		var objectSurfaceBrightness = 21.6609,
			bkgndBrightEye = 21.6,
			expected = {
				contrastPercent: 94.55,
				objectPlusSkyBackgroundSurfaceBrightness: 20.88
			},
		    results = calcContrastOfObjectPlusSkyToSky2(objectSurfaceBrightness, bkgndBrightEye);

		assert.equal(withinRange(results.contrastPercent, expected.contrastPercent, 0.01), true, 'Contrast of M51 to sky background of 21.6 should be ' + expected.contrastPercent + ', is ' + results.contrastPercent);
		assert.equal(withinRange(results.objectPlusSkyBackgroundSurfaceBrightness, expected.objectPlusSkyBackgroundSurfaceBrightness, 0.01), true, 'Object surface brightness of M51 + sky background should be ' + expected.objectPlusSkyBackgroundSurfaceBrightness + ', is ' + results.objectPlusSkyBackgroundSurfaceBrightness);
	});

	QUnit.test('calcSkyFromObjectPlusContrast', assert => {
		// M51
		var objectSurfaceBrightness = 21.6609,
			contrastPercent = 94.55,
			expected = {
				bkgndBrightEye: 21.6,
				objectPlusSkyBackgroundSurfaceBrightness: 20.88
			},
		    results = calcSkyFromObjectPlusContrast(objectSurfaceBrightness, contrastPercent);

		assert.equal(withinRange(results.bkgndBrightEye, expected.bkgndBrightEye, 0.01), true, 'bkgndBrightEye should be ' + expected.bkgndBrightEye + ', is ' + results.bkgndBrightEye);
		assert.equal(withinRange(results.objectPlusSkyBackgroundSurfaceBrightness, expected.objectPlusSkyBackgroundSurfaceBrightness, 0.01), true, 'Object surface brightness + sky background should be ' + expected.objectPlusSkyBackgroundSurfaceBrightness + ', is ' + results.objectPlusSkyBackgroundSurfaceBrightness);
	});

	QUnit.module('calcNewtBaffle');

	// test values verified by graph in baffle.html
	QUnit.test('calcNewtBaffle', assert => {
		var focalPlaneDia, focuserBarrelBottomToFocalPlaneDistance, focuserBarrelID, diagSizeMinorAxis, diagToFocalPlaneDistance, diagtoFocuserBaffleDistance, diagToOppositeSideBaffleDistance, primaryMirrorDia, primaryMirrorFocalLength, primaryToBaffleDistance, tubeID, results;
		focalPlaneDia = 1.4;
		focuserBarrelBottomToFocalPlaneDistance = 2.5;
		focuserBarrelID = 1.8;
		diagSizeMinorAxis = 3.1;
		diagToFocalPlaneDistance = 9;
		diagtoFocuserBaffleDistance = 6;
		diagToOppositeSideBaffleDistance = 7;
		primaryMirrorDia = 13.2;
		primaryMirrorFocalLength = 40.2;
		primaryToBaffleDistance = 4;
		tubeID = primaryMirrorDia + 2;
		results = calcNewtBaffle(focalPlaneDia, focuserBarrelBottomToFocalPlaneDistance, focuserBarrelID, diagSizeMinorAxis, diagToFocalPlaneDistance, diagtoFocuserBaffleDistance, diagToOppositeSideBaffleDistance, primaryMirrorFocalLength, primaryToBaffleDistance, tubeID);
		assert.equal(withinRange(results.focuserBaffleID, 1.97, 0.01), true, 'The focuser baffle ID should be 1.97, is ' + results.focuserBaffleID);
		assert.equal(withinRange(results.focuserBaffleOD, 2.44, 0.01), true, 'The focuser baffle ID should be 2.44, is ' + results.focuserBaffleOD);
		assert.equal(withinRange(results.diagonalBaffleOD, 16.55, 0.01), true, 'The diagonal baffle OD should be 16.55, is ' + results.diagonalBaffleOD);
		assert.equal(withinRange(results.primaryBaffleOD, 16.70, 0.01), true, 'The primary mirror baffle OD should be 16.70, is ' + results.primaryBaffleOD);
		assert.equal(withinRange(results.tubeExtension, 7, 0.01), true, 'The tube extension beyond the primary mirror to act as primary baffle should be 7, is ' + results.tubeExtension);
	});

	QUnit.module('createAltazConstantMotionTrackingErrors');

	QUnit.test('data return', assert => {
		var latitudeRad = 40 * uom.degToRad,
			constantTrackRateTimeRad = 300 * uom.secToRad,
			spacingDeg = 2,
			expected = 18.969,
			data = createAltazConstantMotionTrackingErrors(latitudeRad, constantTrackRateTimeRad, spacingDeg),
			results = data[5][2] / uom.arcsecToRad;

		assert.equal(withinRange(results, expected, 0.001), true, 'The constant track rate error over 5 minutes should be ' + expected + ', is ' + results);
	});

	QUnit.module('slumping');

	QUnit.test('sharply slumped: dia=30, FR=1', assert => {
		var mirrorDia = 30,
			focalRatio = 1,
			expectedEffectiveEntranceAperture = 29.688475110542754,
			result = calcMirrorSlumpingParms(mirrorDia, focalRatio);
		assert.equal(withinRange(result.effectiveDia, expectedEffectiveEntranceAperture, 0.000001), true, 'result = ' + result.effectiveDia);
	});

	QUnit.test('barely slumped: dia=30, FR=5', assert => {
		var mirrorDia = 30,
			focalRatio = 5,
			expectedEffectiveEntranceAperture = 29.987501562406997,
			result = calcMirrorSlumpingParms(mirrorDia, focalRatio);
		assert.equal(withinRange(result.effectiveDia, expectedEffectiveEntranceAperture, 0.000001), true, 'result = ' + result.effectiveDia);
	});

	QUnit.test('13" F3', assert => {
		var mirrorDia = 13.2,
			focalRatio = 3,
			expectedEffectiveEntranceAperture = 13.18472752612914,
			expectedSphericalSagitta = 0.275,
			expectedEdgeAngleDeg = 4.775,
			result = calcMirrorSlumpingParms(mirrorDia, focalRatio);
		assert.equal(withinRange(result.effectiveDia, expectedEffectiveEntranceAperture, 0.000001), true, 'result = ' + result.effectiveDia);
		assert.equal(withinRange(result.sphericalSagitta, expectedSphericalSagitta, 0.001), true, 'result = ' + result.sphericalSagitta);
		assert.equal(withinRange(result.edgeAngleDeg, expectedEdgeAngleDeg, 0.001), true, 'result = ' + result.edgeAngleDeg);
	});

	QUnit.test('42" F2.9', assert => {
		var mirrorDia = 42,
			focalRatio = 2.9,
			expectedEffectiveEntranceAperture = 41.94799792367687,
			expectedSphericalSagitta = 0.905,
			expectedEdgeAngleDeg = 4.939,
			result = calcMirrorSlumpingParms(mirrorDia, focalRatio);
		assert.equal(withinRange(result.effectiveDia, expectedEffectiveEntranceAperture, 0.000001), true, 'result = ' + result.effectiveDia);
		assert.equal(withinRange(result.sphericalSagitta, expectedSphericalSagitta, 0.001), true, 'result = ' + result.sphericalSagitta);
		assert.equal(withinRange(result.edgeAngleDeg, expectedEdgeAngleDeg, 0.001), true, 'result = ' + result.edgeAngleDeg);
	});

	QUnit.module('sphere to parabola difference');

	QUnit.test('6 inch F8', assert => {
		var mirrorDia = 6,
			focalRatio = 8,
			expectedEffectiveEntranceAperture = 0.0000114,
			result = calcSphereParabolaDifference(mirrorDia, focalRatio);
		assert.equal(withinRange(result, expectedEffectiveEntranceAperture, 0.0000001), true, 'result = ' + result);
	});

	QUnit.module('ronchi');

	QUnit.test('wavefrontError', assert => {
		var mirrorDia = 20,
			radiusOfCurvature = 200,
			correctionFactor = 0.86,
			result = wavefrontError(mirrorDia, radiusOfCurvature, correctionFactor),
			expected = 0.5108704878136372;
		assert.equal(result, expected, 'result = ' + result + ', should be ' + expected);
	});

	QUnit.test('wavefrontErrorFrom_MirrorDia_RoC_CorrectionFactor_WavelengthLight', assert => {
		var mirrorDia = 20,
			radiusOfCurvature = 200,
			correctionFactor = 0.86,
			wavelengthLight = 0.000022,
			result = wavefrontErrorFrom_MirrorDia_RoC_CorrectionFactor_WavelengthLight(mirrorDia, radiusOfCurvature, correctionFactor, wavelengthLight),
			expected = -0.5108704878136372;
		assert.equal(result, expected, 'result = ' + result + ', should be ' + expected);

		correctionFactor = 1.14,
		result = wavefrontErrorFrom_MirrorDia_RoC_CorrectionFactor_WavelengthLight(mirrorDia, radiusOfCurvature, correctionFactor, wavelengthLight),
		expected = 0.5108704878136364;
		assert.equal(result, expected, 'result = ' + result + ', should be ' + expected);
	});

	QUnit.test('wavefrontErrorFromCorrectionsArray', assert => {
		var mirrorDia = 20,
			radiusOfCurvature = 200,
			wavelengthLight = 0.000022,
			correctionsArray = [0.86, 0.86, 0.86], // correction factors for 0.3, 0.7 and 0.93 percent zones
			wavefrontErrorsArraySize = 11,
			results = wavefrontErrorFromCorrectionsArray(mirrorDia, radiusOfCurvature, wavelengthLight, correctionsArray, wavefrontErrorsArraySize),
			wavefrontErrorForZone7 = results.wavefrontErrors[7].wavefrontError,
			wavefrontPV = results.wavefrontPV,
			wavefrontRMS = results.wavefrontRMS,
			expectedWavefrontError = -0.5108704878136372,
			expectedRMS = 0.35362221682881234;

		assert.equal(wavefrontErrorForZone7, expectedWavefrontError, 'wavefrontErrorForZone7 = ' + wavefrontErrorForZone7 + ', should be ' + expectedWavefrontError);
		assert.equal(wavefrontPV, -expectedWavefrontError, 'wavefrontPV = ' + wavefrontPV + ', should be ' + -expectedWavefrontError);
		assert.equal(wavefrontRMS, expectedRMS, 'wavefrontErrorRMS = ' + wavefrontRMS + ', should be ' + expectedRMS);
	});

	// parabolic correction tolerances: focalRatio 1: 98.3%; focalRatio 2: 96.7%; focalRatio 3: 95%; focalRatio 4: 93.3%; focalRatio 5: 91.7%; focalRatio 6: 90%; focalRatio 7: 88.4%; focalRatio 8: 86.7%; focalRatio 9: 85%; focalRatio 10: 83.4%;
	QUnit.test('findAllowableCorrection, for a range of focal ratios from f/1 to f/10, mirror dia = 10', assert => {
		var mirrorDia = 10,
			focalRatio,
			results = [],
			ix,
			displayResults = 'parabolic correction tolerances: ',
			expected = 0.83359375;

		for (ix = 0; ix < 10; ix++) {
			focalRatio = (ix + 1);
			results[ix] = findAllowableCorrection(mirrorDia, mirrorDia * focalRatio * 2);
			displayResults += 'focalRatio ' + focalRatio + ': ' + Math.round(results[ix] * 1000) / 10 + '%; ';
		}

		assert.equal(results[9], expected, 'results[9] = ' + results[9] + ', should be ' + expected);
	});

	// as above, but double the aperture to demonstrate that aperture has no bearing on allowable correction
	QUnit.test('findAllowableCorrection, for a range of focal ratios from f/1 to f/10, mirror dia = 20', assert => {
		var mirrorDia = 20,
			focalRatio,
			results = [],
			ix,
			displayResults = 'parabolic correction tolerances: ',
			expected = 0.83359375;

		for (ix = 0; ix < 10; ix++) {
			focalRatio = (ix + 1);
			results[ix] = findAllowableCorrection(mirrorDia, mirrorDia * focalRatio * 2);
			displayResults += 'focalRatio ' + focalRatio + ': ' + Math.round(results[ix] * 1000) / 10 + '%; ';
		}

		assert.equal(results[9], expected, 'results[9] = ' + results[9] + ', should be ' + expected);
	});

	QUnit.test('calcAllowableParabolicDeviationForQuarterWavefront for f/10', assert => {
		var focalRatio = 10,
			expected = 0.16699999999999998,
			result = calcAllowableParabolicDeviationForQuarterWavefront(focalRatio);
		assert.equal(result, expected, 'result = ' + result + ', should be ' + expected);
	});

	QUnit.module('Dob friction of movement');

	/*
	Dob friction, from Telescope Making #8, pg 36-, Richard Berry

	Alt: f*w*sec(ba)*r/l
	Az: f*w*r/(l*cos(ba))
	F=friction (Teflon on formica) =0.1
	W=weight (that the bearing is carrying)
	R=bearing radius
	Ba=bearing angle
	L=length of the moment arm

	Example 16 inch f5:
		AZ radius 9, weight 120 lbs, 45deg bearing angle, moment arm 40inches, f=0.083
		0.088*120*9/(cos(45)*40)=3.2
		ALT radius 4, weight 80 lbs, 60deg bearing angle, moment arm 40inches, f=0.088
		1.3*80*(1/cos(60))*4/40=2.1
	*/
	QUnit.test('az and alt friction', assert => {
		var allowableError = 0.000000000000001,
			azimuthFrictionCoefficient = 0.083,
			altitudeFrictionCoefficient = 0.13,
			momentArm = 40,
			azWeight = 120,
			altWeight = 80,
			azBearingRadius = 9,
			altBearingRadius = 4,
			altBearingAngleDegFromVertical = 60,
			altitudeAngleDegFromHorizontal = 45,
			result = MLB.calcLib.calcDobFriction(azimuthFrictionCoefficient, altitudeFrictionCoefficient, momentArm, azWeight, altWeight, azBearingRadius, altBearingRadius, altBearingAngleDegFromVertical, altitudeAngleDegFromHorizontal),
			expected = [3.169252593278106, 2.08];

		assert.equal(withinRange(result.az, expected[0], allowableError), true, 'az result = ' + result.az + ', should be ' + expected[0]);
		assert.equal(withinRange(result.alt, expected[1], allowableError), true, 'alt result = ' + result.alt + ', should be ' + expected[1]);
	});

	QUnit.module('SQM to NELM converter');

	// from http://www.unihedron.com/projects/darksky/NELM2BCalc.html

	QUnit.test('SQMtoNELMconverter', assert => {
		var expected,
			result,
			allowableError = 0.0001;

		expected = 6;
		result = SQMtoNELMconverter(20.8);
		assert.equal(withinRange(result, expected, allowableError), true, 'result = ' + result + ', should be ' + expected);
	});

	QUnit.test('NELMtoSQMconverter', assert => {
		var expected,
			result,
			allowableError = 0.0001;

		expected = 20.8;
		result = NELMtoSQMconverter(6);
		assert.equal(withinRange(result, expected, allowableError), true, 'result = ' + result + ', should be ' + expected);
	});

	QUnit.module('artificialStarDistance');

	QUnit.test('artificialStarDistanceMM', assert => {
		var expected,
			result;

		expected = '8984';
		result = artificialStarDistanceMM(152, 912);
		assert.equal(result, expected, result + ' should be ' + expected);
	});

	QUnit.test('artificialStarDistanceInches', assert => {
		var expected,
			result;

		expected = '355';
		result = artificialStarDistanceInches(6, 36);
		assert.equal(result, expected, result + ' should be ' + expected);
	});

	QUnit.test('artificialStarDistanceInches', assert => {
		var expected,
			result;

		expected = '4495';
		result = artificialStarDistanceInches(16, 16 * 4.5);
		assert.equal(result, expected, result + ' should be ' + expected);
	});

	QUnit.module('telescope optimizer');

	var MLBScopeTest5Parms = function () {
		this.apertureInches = 13.1,
		this.FOVdeg = 1.762,
		this.eyepieceFocalLengthmm = 21,
		this.eyepieceFieldStopmm = 36.2,
		this.pupilmm = 5.936,    // ignores coma corrector, assumes focal ratio of 3.54; with coma corrector mag of 1.15, focal ratio would be 3.08
		this.expected = undefined,
		this.allowableError = 0.01
	};

	QUnit.test('calcApertureFromFOV_EyepieceFL_EyepieceFieldStop_Pupil', assert => {
		var parms = new MLBScopeTest5Parms(),
			expected = parms.apertureInches,
			result;

		result = calcApertureFromFOV_EyepieceFL_EyepieceFieldStop_Pupil(parms.FOVdeg, parms.eyepieceFocalLengthmm, parms.eyepieceFieldStopmm, parms.pupilmm);
		assert.equal(withinRange(result, expected, parms.allowableError), true, 'result = ' + result + ', should be ' + expected);
	});

	QUnit.test('calcFOVFromAperture_EyepieceFL_EyepieceFieldStop_Pupil', assert => {
		var parms = new MLBScopeTest5Parms(),
			expected = parms.FOVdeg,
			result;

		result = calcFOVFromAperture_EyepieceFL_EyepieceFieldStop_Pupil(parms.apertureInches, parms.eyepieceFocalLengthmm, parms.eyepieceFieldStopmm, parms.pupilmm);
		assert.equal(withinRange(result, expected, parms.allowableError), true, 'result = ' + result + ', should be ' + expected);
	});

	QUnit.test('calcPupilFromAperture_FOV_EyepieceFL_EyepieceFieldStop', assert => {
		var parms = new MLBScopeTest5Parms(),
			expected = parms.pupilmm,
			result;

		result = calcPupilFromAperture_FOV_EyepieceFL_EyepieceFieldStop(parms.apertureInches, parms.FOVdeg, parms.eyepieceFocalLengthmm, parms.eyepieceFieldStopmm);
		assert.equal(withinRange(result, expected, parms.allowableError), true, 'result = ' + result + ', should be ' + expected);
	});

	QUnit.test('calcEyepieceFieldStopFromAperture_FOV_EyepieceFL_Pupil', assert => {
		var parms = new MLBScopeTest5Parms(),
			expected = parms.eyepieceFieldStopmm,
			result;

		result = calcEyepieceFieldStopFromAperture_FOV_EyepieceFL_Pupil(parms.apertureInches, parms.FOVdeg, parms.eyepieceFocalLengthmm, parms.pupilmm);
		assert.equal(withinRange(result, expected, parms.allowableError), true, 'result = ' + result + ', should be ' + expected);
	});

	QUnit.test('calcEyepieceFLFromAperture_FOV_EyepieceFieldStop_Pupil', assert => {
		var parms = new MLBScopeTest5Parms(),
			expected = parms.eyepieceFocalLengthmm,
			result;

		result = calcEyepieceFLFromAperture_FOV_EyepieceFieldStop_Pupil(parms.apertureInches, parms.FOVdeg, parms.eyepieceFieldStopmm, parms.pupilmm);
		assert.equal(withinRange(result, expected, parms.allowableError), true, 'result = ' + result + ', should be ' + expected);
	});

	var MLBScopeTest4Parms = function () {
		this.apertureInches = 13.1,
		this.FOVdeg = 1.762,
		this.focalRatio = 3.54,    // ignores coma corrector; with coma corrector mag of 1.15, FR would be 3.08
		this.eyepieceFieldStopmm = 36.2,
		this.expected = undefined,
		this.allowableError = 0.02
	};

	QUnit.test('calcApertureFromFOV_FocalRatio_EyepieceFieldStop', assert => {
		var parms = new MLBScopeTest4Parms(),
			expected = parms.apertureInches,
			result;

		result = calcApertureFromFOV_FocalRatio_EyepieceFieldStop(parms.FOVdeg, parms.focalRatio, parms.eyepieceFieldStopmm);
		assert.equal(withinRange(result, expected, parms.allowableError), true, 'result = ' + result + ', should be ' + expected);
	});

	QUnit.test('calcFOVFromAperture_FocalRatio_EyepieceFieldStop', assert => {
		var parms = new MLBScopeTest4Parms(),
			expected = parms.FOVdeg,
			result;

		result = calcFOVFromAperture_FocalRatio_EyepieceFieldStop(parms.apertureInches, parms.focalRatio, parms.eyepieceFieldStopmm);
		assert.equal(withinRange(result, expected, parms.allowableError), true, 'result = ' + result + ', should be ' + expected);
	});

	QUnit.test('calcFocalRatioFromAperture_FOV_EyepieceFieldStop', assert => {
		var parms = new MLBScopeTest4Parms(),
			expected = parms.focalRatio,
			result;

		result = calcFocalRatioFromAperture_FOV_EyepieceFieldStop(parms.apertureInches, parms.FOVdeg, parms.eyepieceFieldStopmm);
		assert.equal(withinRange(result, expected, parms.allowableError), true, 'result = ' + result + ', should be ' + expected);
	});

	QUnit.test('calcEyepieceFieldStopFromAperture_FOV_FocalRatio', assert => {
		var parms = new MLBScopeTest4Parms(),
			expected = parms.eyepieceFieldStopmm,
			result;

		result = calcEyepieceFieldStopFromAperture_FOV_FocalRatio(parms.apertureInches, parms.FOVdeg, parms.focalRatio);
		assert.equal(withinRange(result, expected, parms.allowableError), true, 'result = ' + result + ', should be ' + expected);
	});

	var MLBScopeTest4ParmsComaCorrectorFactor = function () {
		this.apertureInches = 13.1,
		this.FOVdeg = 1.762,
		this.focalRatio = 3.08,
		this.eyepieceFieldStopmm = 36.24,
		this.comaCorrectorFactor = 1.15,
		this.expected = undefined,
		this.allowableError = 0.02
	};

	QUnit.test('calcApertureFromFOV_FocalRatio_EyepieceFieldStop_ComaCorrectorFactor', assert => {
		var parms = new MLBScopeTest4ParmsComaCorrectorFactor(),
			expected = parms.apertureInches,
			result;

		result = calcApertureFromFOV_FocalRatio_EyepieceFieldStop_ComaCorrectorFactor(parms.FOVdeg, parms.focalRatio, parms.eyepieceFieldStopmm, parms.comaCorrectorFactor);
		assert.equal(withinRange(result, expected, parms.allowableError), true, 'result including coma corrector = ' + result + ', should be ' + expected);
	});

	QUnit.test('calcFOVFromAperture_FocalRatio_EyepieceFieldStop_ComaCorrectorFactor', assert => {
		var parms = new MLBScopeTest4ParmsComaCorrectorFactor(),
			expected = parms.FOVdeg,
			result;

		result = calcFOVFromAperture_FocalRatio_EyepieceFieldStop_ComaCorrectorFactor(parms.apertureInches, parms.focalRatio, parms.eyepieceFieldStopmm, parms.comaCorrectorFactor);
		assert.equal(withinRange(result, expected, parms.allowableError), true, 'result including coma corrector = ' + result + ', should be ' + expected);
	});

	QUnit.test('calcFocalRatioFromAperture_FOV_EyepieceFieldStop_ComaCorrectorFactor', assert => {
		var parms = new MLBScopeTest4ParmsComaCorrectorFactor(),
			expected = parms.focalRatio,
			result;

		result = calcFocalRatioFromAperture_FOV_EyepieceFieldStop_ComaCorrectorFactor(parms.apertureInches, parms.FOVdeg, parms.eyepieceFieldStopmm, parms.comaCorrectorFactor);
		assert.equal(withinRange(result, expected, parms.allowableError), true, 'result including coma corrector = ' + result + ', should be ' + expected);
	});

	QUnit.test('calcEyepieceFieldStopFromAperture_FOV_FocalRatio_ComaCorrectorFactor', assert => {
		var parms = new MLBScopeTest4ParmsComaCorrectorFactor(),
			expected = parms.eyepieceFieldStopmm,
			result;

		result = calcEyepieceFieldStopFromAperture_FOV_FocalRatio_ComaCorrectorFactor(parms.apertureInches, parms.FOVdeg, parms.focalRatio, parms.comaCorrectorFactor);
		assert.equal(withinRange(result, expected, parms.allowableError), true, 'result including coma corrector = ' + result + ', should be ' + expected);
	});

	QUnit.test('calcMagnificationFromApertureAndPupil', assert => {
		var aperture = 200,
			pupil = 6.5,
			expected = 200 / 6.5, //~31x
			allowableError = 0.001,
			result = calcMagnificationFromApertureAndPupil(aperture, pupil);

		assert.equal(withinRange(result, expected, allowableError), true, 'magnification = ' + result + ', should be ' + expected);
	});

	QUnit.test('calcDetectionFromContrastAndObjectApparentSize', assert => {
		var totalTests = 0,
			totalScore = 0,
			totalAbsDev = 0,
			maxDev = 0,
			absDev,
			rms,
			avgScore,
			expected,
			data,
			calc;

		calc = function (contrast, objectApparentSizeDeg, expected) {
			var result = calcDetectionFromContrastAndObjectApparentSize(contrast, objectApparentSizeDeg);
			totalTests += 1;
			totalScore += result;
			absDev = Math.abs(result - expected)
			totalAbsDev += absDev;
			if (absDev > maxDev) {
				maxDev = absDev;
			}
		};
/*
object	contrast%	objectApparentSizeDeg	visible?
M88			90		3		very easy
M104		270		3		very easy
NAN			100		30		very easy
ex1			40		6		easy
California	24		100		easy
Horsehead	12		5		moderate
Pleiades	6		100		moderate
Witchhead	6		30		moderate
M104		270		1		moderate
M15 IFN		6		50		difficult
Sh2-216		6		75		difficult
M104		270		0.5		difficult
Cone		3		10		very difficult
WD-1		3		10		very difficult
M104		270		0.1		impossible
ex2			2		30		impossible

note that visible? is coded from impossible=1 to very easy=6
*/
		data = [
			[90, 3, 6],
			[270, 3, 6],
			[100, 30, 6],
			[40, 6, 5],
			[24, 100, 4],
			[12, 5, 4],
			[6, 100, 4],
			[6, 30, 4],
			[270, 1, 4],
			[6, 50, 3],
			[6, 75, 3],
			[270, 0.5, 3],
			[3, 10, 2],
			[270, 0.1, 1],
			[2, 30, 1]
		];
		data.forEach((o) => calc(o[0], o[1], o[2]));
		rms = totalAbsDev / totalTests;
		avgScore = totalScore / totalTests;

		expected = 15;
		assert.equal(totalTests, expected, 'totalTests is ' + totalTests + ', should be ' + expected);

		expected = 4;
		assert.equal(totalAbsDev, expected, 'totalAbsDev is ' + totalAbsDev + ', should be ' + expected);

		expected = 2;
		assert.equal(maxDev, expected, 'maxDev is ' + maxDev + ', should be ' + expected);

		expected = 3.7;
		assert.equal(withinRange(avgScore, expected, 0.1), true, 'avgScore = ' + avgScore + ', should be ' + expected);

		expected = 0.27;
		assert.equal(withinRange(rms, expected, 0.1), true, 'rms = ' + rms + ', should be ' + expected);

		// triple the aperture / apparent size raises the avgScore by nearly a level
		totalTests = 0;
		totalScore = 0;
		totalAbsDev = 0;
		maxDev = 0;
		data.forEach((o) => calc(o[0], o[1] * 3, o[2]));
		rms = totalAbsDev / totalTests;
		avgScore = totalScore / totalTests;

		expected = 4.5;
		assert.equal(withinRange(avgScore, expected, 0.1), true, 'avgScore = ' + avgScore + ', should be ' + expected);

		expected = 0.8;
		assert.equal(withinRange(rms, expected, 0.1), true, 'rms = ' + rms + ', should be ' + expected);
	});

	QUnit.test('translateDetectionLevelIntoWords', assert => {
		var detection = 5,
			expected = 'easy',
			result = translateDetectionLevelIntoWords(detection);

		assert.equal(result, expected, 'result = ' + result + ', should be ' + expected);
	});

	QUnit.test('resolutionFromAperture_Magnification', assert => {
		var apertureInches = 5,
			magnification,
			result,
			expected;

		// can't reach DawesLimit: resolution limited by magnification
		magnification = 30;
		expected = 4.6;
		result = resolutionFromAperture_Magnification(apertureInches, magnification);
		assert.equal(withinRange(result, expected, 0.001), true, 'result = ' + result + ', should be ' + expected);

		// reaches DawesLimit: magnification limited by Dawes Limit
		magnification = 300;
		expected = 0.92;
		result = resolutionFromAperture_Magnification(apertureInches, magnification);
		assert.equal(withinRange(result, expected, 0.001), true, 'result = ' + result + ', should be ' + expected);
	});

	QUnit.test('calcTheoreticalResolutionArcsec', assert => {
		var apertureInches = 10,
			result,
			expected = 0.46;

		result = calcTheoreticalResolutionArcsec(apertureInches);
		assert.equal(withinRange(result, expected, 0.001), true, 'result = ' + result + ', should be ' + expected);
	});

	QUnit.test('calcAiryDiskInches', assert => {
		var focalRatio = 5,
			result,
			expected = 0.000268;

		result = calcAiryDiskInches(focalRatio);
		assert.equal(withinRange(result, expected, 0.00001), true, 'result = ' + result + ', should be ' + expected);
	});

	QUnit.test('calcMilliesLacroixTolerance', assert => {
		var wavelengthLight = 0.000022,
			mirrorDia = 20,
			radiusOfCurvature = 200,
			zonalRadius = 0.93,
			result,
			expected = 0.005772043;

		result = calcMilliesLacroixTolerance(wavelengthLight, mirrorDia, radiusOfCurvature, zonalRadius);
		assert.equal(withinRange(result, expected, 0.00001), true, 'result = ' + result + ', should be ' + expected);
	});

	QUnit.test('calcParabolicCorrectionForZone', assert => {
		var mirrorDia = 20,
			radiusOfCurvature = 200,
			zonalRadius = 0.93,
			result,
			expected = 0.216225;

		result = calcParabolicCorrectionForZone(mirrorDia, radiusOfCurvature, zonalRadius);
		assert.equal(withinRange(result, expected, 0.00001), true, 'result = ' + result + ', should be ' + expected);
	});

	QUnit.test('calcProjectedFocuserBaffleRadius', assert => {
		var eyepieceFieldStop = 2,
			barrelTubeID = 3,
			focalPlaneToFocuserBarrelBottomDistance = 3,
			focalPlaneToDiagDistance = 10,
			telescopeTubeOD = 17,
			telescopeTubeThickness = 0.5,
			expected = 14,
			result = calcProjectedFocuserBaffleRadius(eyepieceFieldStop, barrelTubeID, focalPlaneToFocuserBarrelBottomDistance, focalPlaneToDiagDistance, telescopeTubeOD, telescopeTubeThickness);

		assert.equal(withinRange(result, expected, 0.001), true, 'The projected focuser baffle radius should be ' + expected + ', is ' + result);
	});

	QUnit.test('scalingFactor', assert => {
		var maxWidth = 1020,
			maxHeight = 420,
			modelWidth = 40,
			modelHeight = 5,
			border = 10,
			expectedScalingFactor = 25,
			expectedWidth = 1020,
			expectedHeight = 145,
			result = scalingFactor(maxWidth, maxHeight, modelWidth, modelHeight, border);

		assert.equal(withinRange(result.scalingFactor, expectedScalingFactor, 0.001), true, 'The scaling factor should be ' + expectedScalingFactor + ', is ' + result.scalingFactor);
		assert.equal(withinRange(result.width, expectedWidth, 0.001), true, 'The width should be ' + expectedWidth + ', is ' + result.width);
		assert.equal(withinRange(result.height, expectedHeight, 0.001), true, 'The height should be ' + expectedHeight + ', is ' + result.height);
	});

	QUnit.test('calcMaxMagnification', assert => {
		var apertureInches = 2.5,
			expected = 67.5,
			result = calcMaxMagnification(apertureInches);

		assert.equal(withinRange(result, expected, 0.001), true, 'Max magnification should be ' + expected + ', is ' + result);
	});

	QUnit.test('calcMinMagnification', assert => {
		var apertureInches = 2.5,
			expected = 9,
			result = calcMinMagnification(apertureInches);

		assert.equal(withinRange(result, expected, 0.001), true, 'Min magnification should be ' + expected + ', is ' + result);
	});

	QUnit.test('calcWilliamHerschelSpacePenetratingPower', assert => {
		var apertureInches = 10,
			diagSizeInches = 0,
			combinedMirrorsReflectivity = 1,
			expected = 50,
			result = calcWilliamHerschelSpacePenetratingPower(apertureInches, diagSizeInches, combinedMirrorsReflectivity);

		assert.equal(withinRange(result, expected, 0.001), true, "William Herschel's space penetrating power should be " + expected + ', is ' + result);

		diagSizeInches = 2,
		combinedMirrorsReflectivity = 0.8,
		expected = 39.192,
		result = calcWilliamHerschelSpacePenetratingPower(apertureInches, diagSizeInches, combinedMirrorsReflectivity);
		assert.equal(withinRange(result, expected, 0.001), true, "William Herschel's space penetrating power should be " + expected + ', is ' + result);
	});

	QUnit.test('calcComaFreeDiaInches', assert => {
		var focalRatio = 5,
			expected = 0.0875,
			result = calcComaFreeDiaInches(focalRatio);

		assert.equal(withinRange(result, expected, 0.001), true, 'coma free diameter in inches should be ' + expected + ', is ' + result);
	});

	QUnit.test('calcDiopter', assert => {
		var focalLengthInches = 17,
			expected =  2.3159,
			result = calcDiopter(focalLengthInches);

		assert.equal(withinRange(result, expected, 0.01), true, 'diopter should be ' + expected + ', is ' + result);
	});

	QUnit.test('calcFocalLengthInches', assert => {
		var diopter = 2.3159,
			expected = 17,
			result = calcFocalLengthInches(diopter);

		assert.equal(withinRange(result, expected, 0.01), true, 'telescope focal length should be ' + expected + ', is ' + result);
	});

	QUnit.test('calcMagnifyingLensPower', assert => {
		var diopter = 4,
			expected = 2,
			result = calcMagnifyingLensPower(diopter).lensHeldCloseToEye;

		assert.equal(withinRange(result, expected, 0.01), true, 'lens magnifying power should be ' + expected + ', is ' + result);
	});

	// http://www.rfroyce.com/standards.htm

	QUnit.test('calcStrehlFromRMS', assert => {
		var rms = 0.028,
			expected = 0.969,
			result = calcStrehlFromRMS(rms);

		assert.equal(withinRange(result, expected, 0.001), true, 'Strehl should be ' + expected + ', is ' + result);
	});

	QUnit.test('calcRMSFromStrehl', assert => {
		var Strehl = 0.969,
			expected = 0.028,
			result = calcRMSFromStrehl(Strehl);

		assert.equal(withinRange(result, expected, 0.001), true, 'RMS should be ' + expected + ', is ' + result);
	});

	QUnit.test('calcPVFromRMS', assert => {
		var rms = 0.071,
			expected = 1 / 4,
			result = calcPVFromRMS(rms);

		assert.equal(withinRange(result, expected, 0.001), true, 'PV should be ' + expected + ', is ' + result);
	});

	QUnit.test('calcRMSFromPV', assert => {
		var PV = 1 / 4,
			expected = 0.071,
			result = calcRMSFromPV(PV);

		assert.equal(withinRange(result, expected, 0.001), true, 'RMS should be ' + expected + ', is ' + result);
	});

	QUnit.test('calcApertureFromEyepieceApparentFOVdegs_Pupil_ObjectApparentSize', assert => {
		var eyepieceApparentFOVdegs = [100, 80, 60, 40],
			pupilInches = 7 / 25.4, // keep it all in inches - could just as well use mm
			objectSizeArcmin1 = 60,
			objectSizeArcmin2 = 30,
			expectedApertures = [27.56, 22.05, 16.54, 11.02],
			expectedAperture,
			expectedLuminances = [759.50, 486.08, 273.42, 121.52],
			expectedLuminance,
			result = calcApertureFromEyepieceApparentFOVdegs_Pupil_ObjectApparentSize(eyepieceApparentFOVdegs, pupilInches, objectSizeArcmin1, objectSizeArcmin2),
			resultFOV,
			resultAperture,
			resultLuminance;

		expectedApertures.forEach(function (e, ix) {
			resultFOV = result[ix]['apparentFOVdegs'];
			resultAperture = result[ix]['aperture'];
			resultLuminance = result[ix]['luminance'];
			expectedAperture = expectedApertures[ix];
			expectedLuminance = expectedLuminances[ix];
			assert.equal(withinRange(resultAperture, expectedAperture, 0.01), true, 'for ' + resultFOV + ' field of view in degrees, aperture should be ' + expectedAperture + ', is ' + resultAperture);
			assert.equal(withinRange(resultLuminance, expectedLuminance, 0.01), true, '... and luminance should be ' + expectedLuminance + ' in^2deg^2, is ' + resultLuminance);
		});
	});

	QUnit.test('calcComa', assert => {
		var eyepieceFieldStopmm = 6.85,
			focalRatio = 6.85,
			expected = {
				lowOrderComaRMS: 0.07, // per Nils Olaf's example
				linearComaRMS: 0.22
			},
			allowableError = 0.01,
			result = calcComa(eyepieceFieldStopmm, focalRatio);

		assert.equal(withinRange(result.lowOrderComaRMS, expected.lowOrderComaRMS, allowableError), true, 'lowOrderComaRMS should be ' + expected.lowOrderComaRMS + ', is ' + result.lowOrderComaRMS);
		assert.equal(withinRange(result.linearComaRMS, expected.linearComaRMS, allowableError), true, 'linearComaRMS should be ' + expected.linearComaRMS + ', is ' + result.linearComaRMS);
	});

	QUnit.test('calcGreaterComa', assert => {
		var eyepieceFieldStopmm = 3,
			focalRatio = 6,
			expected = 0.13,
			allowableError = 0.01,
			result = calcGreaterComa(eyepieceFieldStopmm, focalRatio);

		// selects for linearComaRMS
		assert.equal(withinRange(result, expected, allowableError), true, 'greatest coma should be ' + expected + ', is ' + result);

		// selects for lowOrderComaRMS
		eyepieceFieldStopmm = 20,
		focalRatio = 2,
		expected = 8.38,
		result = calcGreaterComa(eyepieceFieldStopmm, focalRatio);
		assert.equal(withinRange(result, expected, allowableError), true, 'greatest coma should be ' + expected + ', is ' + result);
	});

	QUnit.test('calcGreaterComaWithComaCorrector', assert => {
		var eyepieceFieldStopmm = 20,
			focalRatio = 3,
			useComaCorrector = false,
			expected = 3.33,
			allowableError = 0.01,
			result = calcGreaterComaWithComaCorrector(eyepieceFieldStopmm, focalRatio, useComaCorrector);

		assert.equal(withinRange(result, expected, allowableError), true, 'coma without coma corrector should be ' + expected + ', is ' + result);

		useComaCorrector = true;
		expected = 0.21,
		result = calcGreaterComaWithComaCorrector(eyepieceFieldStopmm, focalRatio, useComaCorrector);
		assert.equal(withinRange(result, expected, allowableError), true, 'coma with coma corrector should be ' + expected + ', is ' + result);
	});

	QUnit.test('calcCollimationToleranceInches', assert => {
		// https://www.cloudynights.com/topic/902119-the-refractor-crowd-is-making-fun-of-us/?p=13157624
		// where focuserAlignment should be 5.4mm for a 16 inch F3
		var apertureInches = 16,
			focalRatio = 3,
			expected = {focuserAlignment: 0.216, primaryMirrorAlignment: 0.0189},
			allowableError = 0.001,
			result = calcCollimationToleranceInches(apertureInches, focalRatio);

		assert.equal(withinRange(result.focuserAlignment, expected.focuserAlignment, allowableError), true, 'collimation tolerance (focuser) should be ' + expected.focuserAlignment + ', is ' + result.focuserAlignment);
		assert.equal(withinRange(result.primaryMirrorAlignment, expected.primaryMirrorAlignment, allowableError), true, 'collimation tolerance (primary mirror) should be ' + expected.primaryMirrorAlignment + ', is ' + result.primaryMirrorAlignment);
	});

	QUnit.test('calcMinimumMirrorSupportPoints', assert => {
		var aperture = 16,
			expected = 6,
			result = calcMinimumMirrorSupportPoints(aperture);

		assert.equal(result, expected, result + ' should be ' + expected);

		aperture = 30;
		expected = 27;
		result = calcMinimumMirrorSupportPoints(aperture);
		assert.equal(result, expected, result + ' should be ' + expected);

		aperture = 8;
		expected = 3;
		result = calcMinimumMirrorSupportPoints(aperture);
		assert.equal(result, expected, result + ' should be ' + expected);

		aperture = 60;
		expected = undefined;
		result = calcMinimumMirrorSupportPoints(aperture);
		assert.equal(result, expected, result + ' should be ' + expected);
	});

	QUnit.test('calcMirrorCellDimensions', assert => {
		// 3 pt
		var aperture = 6,
			expected = {
				radius: 1.2
			},
			allowableError = 0.01,
			result = calcMirrorCellDimensions(3, aperture / 2);

		assert.equal(withinRange(result.radius, expected.radius, allowableError), true, '3 pt mirror cell radius should be ' + expected.radius + ', is ' + result.radius);

		// 6 pt
		aperture = 12;
		expected = {
			radius: 3.42,
			balanceRadius: 2.962
		};
		result = calcMirrorCellDimensions(6, aperture / 2);
		assert.equal(withinRange(result.radius, expected.radius, allowableError), true, '6 pt mirror cell radius should be ' + expected.radius + ', is ' + result.radius);
		assert.equal(withinRange(result.balanceRadius, expected.balanceRadius, allowableError), true, '6 pt mirror cell balance radius should be ' + expected.balanceRadius + ', is ' + result.balanceRadius);

		// 9 pt
		aperture = 18;
		expected = {
			innerRadius: 2.97,
			outerRadius: 6.48,
			balanceRadius: 4.731
		};
		result = calcMirrorCellDimensions(9, aperture / 2);
		assert.equal(withinRange(result.innerRadius, expected.innerRadius, allowableError), true, '9 pt mirror cell inner radius should be ' + expected.innerRadius + ', is ' + result.innerRadius);
		assert.equal(withinRange(result.outerRadius, expected.outerRadius, allowableError), true, '9 pt mirror cell outer radius should be ' + expected.outerRadius + ', is ' + result.outerRadius);
		assert.equal(withinRange(result.balanceRadius, expected.balanceRadius, allowableError), true, '9 pt mirror cell balance radius should be ' + expected.balanceRadius + ', is ' + result.balanceRadius);

		// 12 pt
		aperture = 20;
		expected = {
			innerRadius: 1.9,
			outerRadius: 7.2,
			collimationRadius: 5.3,
			innerBarLength: 5.5,
			midBarLength: 6.4,
			outerBarLength: 4.9,
			innerBarBalance: 3.52,
			midBarBalance: 3.584,
			outerBarBalance: 2.45
		};
		result = calcMirrorCellDimensions(12, aperture / 2);
		assert.equal(withinRange(result.innerRadius, expected.innerRadius, allowableError), true, '12 pt mirror cell inner radius should be ' + expected.innerRadius + ', is ' + result.innerRadius);
		assert.equal(withinRange(result.outerRadius, expected.outerRadius, allowableError), true, '12 pt mirror cell outer radius should be ' + expected.outerRadius + ', is ' + result.outerRadius);
		assert.equal(withinRange(result.collimationRadius, expected.collimationRadius, allowableError), true, '12 pt mirror cell collimation radius should be ' + expected.collimationRadius + ', is ' + result.collimationRadius);
		assert.equal(withinRange(result.innerBarLength, expected.innerBarLength, allowableError), true, '12 pt mirror cell innerBarLength should be ' + expected.innerBarLength + ', is ' + result.innerBarLength);
		assert.equal(withinRange(result.midBarLength, expected.midBarLength, allowableError), true, '12 pt mirror cell midBarLength should be ' + expected.midBarLength + ', is ' + result.midBarLength);
		assert.equal(withinRange(result.outerBarLength, expected.outerBarLength, allowableError), true, '12 pt mirror cell outerBarLength should be ' + expected.outerBarLength + ', is ' + result.outerBarLength);
		assert.equal(withinRange(result.innerBarBalance, expected.innerBarBalance, allowableError), true, '12 pt mirror cell innerBarBalance should be ' + expected.innerBarBalance + ', is ' + result.innerBarBalance);
		assert.equal(withinRange(result.midBarBalance, expected.midBarBalance, allowableError), true, '12 pt mirror cell midBarBalance should be ' + expected.midBarBalance + ', is ' + result.midBarBalance);
		assert.equal(withinRange(result.outerBarBalance, expected.outerBarBalance, allowableError), true, '12 pt mirror cell outerBarBalance should be ' + expected.outerBarBalance + ', is ' + result.outerBarBalance);

		// 18 pt
		aperture = 24;
		expected = {
			innerRadius: 4.56,
			outerRadius: 9.12,
			triangleBalanceRadius: 7.393,
			pivotBarBalanceRadius: 6.403
		};
		result = calcMirrorCellDimensions(18, aperture / 2);
		assert.equal(withinRange(result.innerRadius, expected.innerRadius, allowableError), true, '18 pt mirror cell inner radius should be ' + expected.innerRadius + ', is ' + result.innerRadius);
		assert.equal(withinRange(result.outerRadius, expected.outerRadius, allowableError), true, '18 pt mirror cell outer radius should be ' + expected.outerRadius + ', is ' + result.outerRadius);
		assert.equal(withinRange(result.triangleBalanceRadius, expected.triangleBalanceRadius, allowableError), true, '18 pt mirror cell triangle balance radius should be ' + expected.triangleBalanceRadius + ', is ' + result.triangleBalanceRadius);
		assert.equal(withinRange(result.pivotBarBalanceRadius, expected.pivotBarBalanceRadius, allowableError), true, '18 pt mirror cell pivot bar balance radius should be ' + expected.pivotBarBalanceRadius + ', is ' + result.pivotBarBalanceRadius);

		// 27 pt
		aperture = 30;
		expected = {
			inner6Radius: 4.96,
			mid9Radius: 9.65,
			outer12Radius: 12.74,
			baseTriangleBalanceRadius: 8.43,
			innerTriangleBalanceRadius: 6.06,
			outerTriangleBalanceRadius: 11.41,
			outerTriangleBalancePtAngles2: 87 * uom.degToRad
		};
		result = calcMirrorCellDimensions(27, aperture / 2);
		assert.equal(withinRange(result.inner6Radius, expected.inner6Radius, allowableError), true, '27 pt mirror cell inner 6 radius should be ' + expected.inner6Radius + ', is ' + result.inner6Radius);
		assert.equal(withinRange(result.mid9Radius, expected.mid9Radius, allowableError), true, '27 pt mirror cell mid 9 radius should be ' + expected.mid9Radius + ', is ' + result.mid9Radius);
		assert.equal(withinRange(result.outer12Radius, expected.outer12Radius, allowableError), true, '27 pt mirror cell outer radius should be ' + expected.outer12Radius + ', is ' + result.outer12Radius);
		assert.equal(withinRange(result.baseTriangleBalanceRadius, expected.baseTriangleBalanceRadius, allowableError), true, '27 pt mirror cell base triangle balance radius should be ' + expected.baseTriangleBalanceRadius + ', is ' + result.baseTriangleBalanceRadius);
		assert.equal(withinRange(result.innerTriangleBalanceRadius, expected.innerTriangleBalanceRadius, allowableError), true, '27 pt mirror cell inner triangle balance radius should be ' + expected.innerTriangleBalanceRadius + ', is ' + result.innerTriangleBalanceRadius);
		assert.equal(withinRange(result.outerTriangleBalanceRadius, expected.outerTriangleBalanceRadius, allowableError), true, '27 pt mirror cell outer triangle balance radius should be ' + expected.outerTriangleBalanceRadius + ', is ' + result.outerTriangleBalanceRadius);
		assert.equal(withinRange(result.outerTriangleBalancePtAngles[1], expected.outerTriangleBalancePtAngles2, allowableError), true, '27 pt mirror cell outer triangle balance #2 point angle should be ' + expected.outerTriangleBalancePtAngles2 + ', is ' + result.outerTriangleBalancePtAngles[1]);

		// other
		aperture = 1000;
		expected = undefined;
		result = calcMirrorCellDimensions(54, aperture / 2);
		assert.equal(result, expected, result + ' should result in an undefined cell: ' + expected);
	});

	QUnit.test('calcRMSCausedByCentralObstruction', assert => {
		var centralObstructionByDiameter = 1 / 3,
			expected = 0.07,
			allowableError = 0.1,
			result = calcRMSCausedByCentralObstruction(centralObstructionByDiameter);

		assert.equal(withinRange(result, expected, allowableError), true, 'RMS deformation should be ' + expected + ', is ' + result);
	});

	QUnit.test('findWeightedCenterOfPoints', assert => {
		var points = [{x: 1, y: 0}, {x: 2, y: 4}, {x: 3, y: 5}],
			expected = {
				x: 2,
				y: 3
			},
			allowableError = 0.00001,
			result = findWeightedCenterOfPoints(points);

		assert.equal(withinRange(result.x, expected.x, allowableError), true, 'weighted x should be ' + expected.x + ', is ' + result.x);
		assert.equal(withinRange(result.y, expected.y, allowableError), true, 'weighted y should be ' + expected.y + ', is ' + result.y);
	});

	QUnit.test('findOffsetCenterBetweenTwoPoints', assert => {
		var point = MLB.sharedLib.point,
			pointA = point(4, 10),
			pointB = point(12, 20),
			offset = 0.5,
			expected = {
				x: 8,
				y: 15
			},
			allowableError = 0.00001,
			result = findOffsetCenterBetweenTwoPoints(pointA, pointB, offset);

		assert.equal(withinRange(result.x, expected.x, allowableError), true, 'offset x should be ' + expected.x + ', is ' + result.x);
		assert.equal(withinRange(result.y, expected.y, allowableError), true, 'offset y should be ' + expected.y + ', is ' + result.y);

		// reverse the points
		pointA = point(12, 20),
		pointB = point(4, 10),
		offset = 0.5,
		expected = {
			x: 8,
			y: 15
		},
		allowableError = 0.00001,
		result = findOffsetCenterBetweenTwoPoints(pointA, pointB, offset);

		assert.equal(withinRange(result.x, expected.x, allowableError), true, 'offset x should be ' + expected.x + ', is ' + result.x);
		assert.equal(withinRange(result.y, expected.y, allowableError), true, 'offset y should be ' + expected.y + ', is ' + result.y);

		// offset 80% of the way towards pointB
		pointA = point(4, 10),
		pointB = point(12, 20),
		offset = 0.8,
		expected = {
			x: 10.4,
			y: 18
		},
		allowableError = 0.00001,
		result = findOffsetCenterBetweenTwoPoints(pointA, pointB, offset);

		assert.equal(withinRange(result.x, expected.x, allowableError), true, 'offset x should be ' + expected.x + ', is ' + result.x);
		assert.equal(withinRange(result.y, expected.y, allowableError), true, 'offset y should be ' + expected.y + ', is ' + result.y);
	});

	QUnit.module('mirrorMaking');

	QUnit.test('calcToolVolume', assert => {
		var mirrorDia = 16,
			mirrorFocalRatio = 3,
			plasterEdgeThickness = 1.5,
			expected = 335.18,
			allowableError = 0.01,
			result = calcToolVolume(mirrorDia, mirrorFocalRatio, plasterEdgeThickness);

		assert.equal(withinRange(result, expected, allowableError), true, 'tool volume should be ' + expected + ', is ' + result);
	});

	QUnit.test('calcMirrorWeight', assert => {
		var mirrorDia = 16.25,
			mirrorFocalRatio = 2.9,
			mirrorEdgeThickness = 0.4,
			isMeniscus = true,
			expected = 7.47,
			expectedNoMeniscus = 4.19,
			allowableError = 0.01,
			result = calcMirrorWeight(mirrorDia, mirrorFocalRatio, mirrorEdgeThickness, isMeniscus);

		assert.equal(withinRange(result, expected, allowableError), true, 'mirror weight (lbs) should be ' + expected + ', is ' + result);

		isMeniscus = false;
		result = calcMirrorWeight(mirrorDia, mirrorFocalRatio, mirrorEdgeThickness, isMeniscus);
		assert.equal(withinRange(result, expectedNoMeniscus, allowableError), true, 'mirror (not a meniscus) weight (lbs) should be ' + expectedNoMeniscus + ', is ' + result);
	});

	QUnit.test('calcLensCG', assert => {
		// 20 inch F2 where sag = 0.625; CG measured from the flat side of the convex lens should be a little less than the 5/8 thickness
		var thickness = 0.625,
			radius = 80,
			expected = 0.208,
			allowableError = 0.01,
			result = calcLensCG(thickness, radius);

		assert.equal(withinRange(result, expected, allowableError), true, 'lens CG should be ' + expected + ', is ' + result);
	});

	QUnit.test('calcMirrorCG', assert => {
		// 20 inch x 2 inch thick F2; expected CG should be further from the mirror's top edge than half the sagitta
		var mirrorDia = 20,
			mirrorFocalRatio = 2,
			mirrorEdgeThickness = 0.625,
			isMeniscus = false,
			expected = 0.418,
			allowableError = 0.01,
			result = calcMirrorCG(mirrorDia, mirrorFocalRatio, mirrorEdgeThickness, isMeniscus);

		assert.equal(withinRange(result, expected, allowableError), true, 'mirror CG should be ' + expected + ', is ' + result);

		// add a bit more thickness; CG should increase to more than half the mirror's edge thickness
		mirrorEdgeThickness = 1;
		expected = 0.576;
		result = calcMirrorCG(mirrorDia, mirrorFocalRatio, mirrorEdgeThickness, isMeniscus);
		assert.equal(withinRange(result, expected, allowableError), true, 'mirror CG should be ' + expected + ', is ' + result);

		// make mirror nearly flat; CG should be just over half the mirror's edge thickness
		mirrorFocalRatio = 100;
		expected = 0.501;
		result = calcMirrorCG(mirrorDia, mirrorFocalRatio, mirrorEdgeThickness, isMeniscus);
		assert.equal(withinRange(result, expected, allowableError), true, 'mirror CG should be ' + expected + ', is ' + result);

		//a more normal mirror
		mirrorFocalRatio = 5;
		mirrorEdgeThickness = 2;
		expected = 1.022;
		result = calcMirrorCG(mirrorDia, mirrorFocalRatio, mirrorEdgeThickness, isMeniscus);
		assert.equal(withinRange(result, expected, allowableError), true, 'mirror CG should be ' + expected + ', is ' + result);

		// meniscus mirrors...

		// edge thickness = sagitta
		isMeniscus = true;
		mirrorFocalRatio = 2;
		mirrorEdgeThickness = 0.625;
		expected = 0.625;
		result = calcMirrorCG(mirrorDia, mirrorFocalRatio, mirrorEdgeThickness, isMeniscus);
		assert.equal(withinRange(result, expected, allowableError), true, 'mirror (meniscus) CG should be ' + expected + ', is ' + result);

		// real life mirror
		mirrorDia = 20.25;
		mirrorFocalRatio = 2.9;
		mirrorEdgeThickness = 0.75;
		expected = 0.594;
		result = calcMirrorCG(mirrorDia, mirrorFocalRatio, mirrorEdgeThickness, isMeniscus);
		assert.equal(withinRange(result, expected, allowableError), true, 'mirror (meniscus) CG should be ' + expected + ', is ' + result);
	});

	QUnit.module('WaineoSphericalNull');

	QUnit.skip('WaineoSphericalNull', assert => {
		var inParms = {
			// in mm
			paraboloidalDia: 500,
			KEpositionBehindSphere: 150,
			nullingSphereRoC: 2000,
			paraboloidRoC: 5000
		},
		expected = {
			lightSourceDistanceInFrontOfSphere: 69.36592,
			minimumSphereDia: 18.18299,
			minimumHoleInSphereDia: 1.806831,
			paraboloidDistanceFromSphere: 400.7165,
			paraboloidToFocusKEDistance: 415.7165,
			marginalSphericalAberration: -0.000000000000004440892, //difference between central and marginal focus of null system; should be less than 1.0E-15
			opticalPathSifference: 0.08211839,                     // OPD between central and marginal rays expressed in wave lengths of 0.00055mm
			sphericalAberrationZone707: -0.03745461,
			zoneOPD707: 0.04089487,
			minOPD: 0.01030829,              // minimized maximum OPD using 24 zones
			incrementalBestFocus: 0.02805132 // KE adjustment for MinOPD
		},
		allowableError = 0.00001,
		result = WaineoSphericalNull(inParms);

		assert.equal(withinRange(result.lightSourceDistanceInFrontOfSphere, expected.lightSourceDistanceInFrontOfSphere, allowableError), true, 'lightSourceDistanceInFrontOfSphere should be ' + expected.lightSourceDistanceInFrontOfSphere + ', is ' + result.lightSourceDistanceInFrontOfSphere);

	});

});

</script>
</html>