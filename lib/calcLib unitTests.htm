<!DOCTYPE HTML>
<html>
<head>
    <title>QUnit test for calcLib.js</title>

    <!--
    <link rel='stylesheet' href='http://code.jquery.com/qunit/qunit-1.16.0.css' />
    <script src='http://code.jquery.com/jquery-1.11.0.min.js'></script>
    <script src='http://code.jquery.com/qunit/qunit-1.16.0.js'></script>

    <script>window.jQuery || document.write('<script src='local-source.js'><\/script>')</script>
    -->

    <link rel='stylesheet' href='qunit/qunit-1.16.0.css' />
    <script src='jquery/jquery-2.1.1.min.js'></script>
    <script src='qunit/qunit-1.16.0.js'></script>
    <script src='underscore/underscore-min.js'></script>

    <script src="sharedLib.js"></script>
    <script src="coordLib.js"></script>
    <script src="calcLib.js"></script>
</head>
<body>
    <div id="qunit"></div>
    <div id="qunit-fixture"></div>
</body>

<script>$(document).ready(function () {
    'use strict';
    var withinRange = MLB.sharedLib.withinRange,
        uom = MLB.sharedLib.uom,
        calcSagittaSpherical = MLB.calcLib.calcSagittaSpherical,
        calcSagittaParabolic = MLB.calcLib.calcSagittaParabolic,
        calcFocalRatio = MLB.calcLib.calcFocalRatio,
        calcFocalRatioFromSphericalSagitta = MLB.calcLib.calcFocalRatioFromSphericalSagitta,
        calcSagittalVolume = MLB.calcLib.calcSagittalVolume,		
		calcSagittalVolumeParabolic = MLB.calcLib.calcSagittalVolumeParabolic,
		calcSagittalVolumeRemovedDuringParabolization = MLB.calcLib.calcSagittalVolumeRemovedDuringParabolization,
		glassRemovalDuringPolishingFrom10MicronAluminumOxideCubicInches = MLB.calcLib.glassRemovalDuringPolishingFrom10MicronAluminumOxideCubicInches,
        inchesToWavesGreenLight = MLB.calcLib.inchesToWavesGreenLight,
        calcRotatingFurnaceRPM = MLB.calcLib.calcRotatingFurnaceRPM,
        calcOffAxisIllumination = MLB.calcLib.calcOffAxisIllumination,
        magnitudeDrop = MLB.calcLib.magnitudeDrop,
        magnitudeDifferenceBetweenApertures = MLB.calcLib.magnitudeDifferenceBetweenApertures,
        inverseMagnitudeDrop = MLB.calcLib.inverseMagnitudeDrop,
        diagObstructionArea = MLB.calcLib.diagObstructionArea,
        calcDiagOffset = MLB.calcLib.calcDiagOffset,
        calcDiagOffset2 = MLB.calcLib.calcDiagOffset2,
        calcDiagOffset3 = MLB.calcLib.calcDiagOffset3,
        areaIntersectingCircles = MLB.calcLib.areaIntersectingCircles,
        getDiagIllumArray = MLB.calcLib.getDiagIllumArray,
        getFoldedNewtonianScalingFactor = MLB.calcLib.getFoldedNewtonianScalingFactor,
        calcFoldedNewtonian = MLB.calcLib.calcFoldedNewtonian,
        limitingMagnitude = MLB.calcLib.limitingMagnitude,
        apertureInchesFromMagnitude = MLB.calcLib.apertureInchesFromMagnitude,
        VisualDetectCalcParms = MLB.calcLib.VisualDetectCalcParms,
        visualDetectCalcData = MLB.calcLib.visualDetectCalcData,
        VisualDetectCalc = MLB.calcLib.VisualDetectCalc,
        VisualDetectCalcExitPupils = MLB.calcLib.VisualDetectCalcExitPupils,
        VisualDetectCalcApertures = MLB.calcLib.VisualDetectCalcApertures,
        calcNewtBaffle = MLB.calcLib.calcNewtBaffle,
        createAltazConstantMotionTrackingErrors = MLB.calcLib.createAltazConstantMotionTrackingErrors,
        calcMirrorSlumpingParms = MLB.calcLib.calcMirrorSlumpingParms,
        calcSphereParabolaDifference = MLB.calcLib.calcSphereParabolaDifference,
        wavefrontError = MLB.calcLib.wavefrontError,
        findAllowableCorrection = MLB.calcLib.findAllowableCorrection,
        calcAllowableParabolicDeviationForQuarterWavefront = MLB.calcLib.calcAllowableParabolicDeviationForQuarterWavefront,
        calcDobFriction = MLB.calcLib.calcDobFriction,
        SQMtoNELMconverter = MLB.calcLib.SQMtoNELMconverter,
        NELMtoSQMconverter = MLB.calcLib.NELMtoSQMconverter,
        artificialStarDistanceMM = MLB.calcLib.artificialStarDistanceMM,
        artificialStarDistanceInches = MLB.calcLib.artificialStarDistanceInches,
        calcApertureFromFOV_EyepieceFL_EyepieceFieldStop_EyePupil = MLB.calcLib.calcApertureFromFOV_EyepieceFL_EyepieceFieldStop_EyePupil,
        calcFOVFromAperture_EyepieceFL_EyepieceFieldStop_EyePupil = MLB.calcLib.calcFOVFromAperture_EyepieceFL_EyepieceFieldStop_EyePupil,
        calcEyePupilFromAperture_FOV_EyepieceFL_EyepieceFieldStop = MLB.calcLib.calcEyePupilFromAperture_FOV_EyepieceFL_EyepieceFieldStop,
        calcEyepieceFieldStopFromAperture_FOV_EyepieceFL_EyePupil = MLB.calcLib.calcEyepieceFieldStopFromAperture_FOV_EyepieceFL_EyePupil,
        calcEyepieceFLFromAperture_FOV_EyepieceFieldStop_EyePupil = MLB.calcLib.calcEyepieceFLFromAperture_FOV_EyepieceFieldStop_EyePupil,
        calcApertureFromFOV_EyepieceFL_EyepieceFieldStop_EyePupil_ComaCorrectorMag = MLB.calcLib.calcApertureFromFOV_EyepieceFL_EyepieceFieldStop_EyePupil_ComaCorrectorMag,
        calcApertureFromFOV_FocalRatio_EyepieceFieldStop = MLB.calcLib.calcApertureFromFOV_FocalRatio_EyepieceFieldStop,
        calcFOVFromAperture_FocalRatio_EyepieceFieldStop = MLB.calcLib.calcFOVFromAperture_FocalRatio_EyepieceFieldStop,
        calcFocalRatioFromAperture_FOV_EyepieceFieldStop = MLB.calcLib.calcFocalRatioFromAperture_FOV_EyepieceFieldStop,
        calcEyepieceFieldStopFromAperture_FOV_FocalRatio = MLB.calcLib.calcEyepieceFieldStopFromAperture_FOV_FocalRatio,
        calcApertureFromFOV_FocalRatio_EyepieceFieldStop_ComaCorrectorFactor = MLB.calcLib.calcApertureFromFOV_FocalRatio_EyepieceFieldStop_ComaCorrectorFactor,
        calcFOVFromAperture_FocalRatio_EyepieceFieldStop_ComaCorrectorFactor = MLB.calcLib.calcFOVFromAperture_FocalRatio_EyepieceFieldStop_ComaCorrectorFactor,
        calcFocalRatioFromAperture_FOV_EyepieceFieldStop_ComaCorrectorFactor = MLB.calcLib.calcFocalRatioFromAperture_FOV_EyepieceFieldStop_ComaCorrectorFactor,
        calcEyepieceFieldStopFromAperture_FOV_FocalRatio_ComaCorrectorFactor = MLB.calcLib.calcEyepieceFieldStopFromAperture_FOV_FocalRatio_ComaCorrectorFactor,
        resolutionFromAperture_Magnification = MLB.calcLib.resolutionFromAperture_Magnification,
        calcTheoreticalResolutionArcsec = MLB.calcLib.calcTheoreticalResolutionArcsec,
        calcAiryDiskInches = MLB.calcLib.calcAiryDiskInches,
        calcProjectedFocuserBaffleRadius = MLB.calcLib.calcProjectedFocuserBaffleRadius,
        scalingFactor = MLB.calcLib.scalingFactor,
        calcMaxMagnification = MLB.calcLib.calcMaxMagnification,
        calcMinMagnification = MLB.calcLib.calcMinMagnification,
        calcComaFreeDiaInches = MLB.calcLib.calcComaFreeDiaInches,
        calcDiopter = MLB.calcLib.calcDiopter,
        calcFocalLengthInches = MLB.calcLib.calcFocalLengthInches,
        calcMagnifyingLensPower = MLB.calcLib.calcMagnifyingLensPower,
        calcStrehlFromRMS = MLB.calcLib.calcStrehlFromRMS,
        calcRMSFromStrehl = MLB.calcLib.calcRMSFromStrehl,
        calcPVFromRMS = MLB.calcLib.calcPVFromRMS,
        calcRMSFromPV = MLB.calcLib.calcRMSFromPV,
        calcApertureFromEyepieceApparentFOVdegs_Pupil_ObjectApparentSize = MLB.calcLib.calcApertureFromEyepieceApparentFOVdegs_Pupil_ObjectApparentSize,
        calcComa = MLB.calcLib.calcComa,
        calcGreaterComa = MLB.calcLib.calcGreaterComa,
        calcGreaterComaWithComaCorrector = MLB.calcLib.calcGreaterComaWithComaCorrector,
        calcCollimationToleranceInches = MLB.calcLib.calcCollimationToleranceInches,
        calcMinimumMirrorSupportPoints = MLB.calcLib.calcMinimumMirrorSupportPoints,
        calcMirrorCellDimensions = MLB.calcLib.calcMirrorCellDimensions,
        calcRMSCausedByCentralObstruction = MLB.calcLib.calcRMSCausedByCentralObstruction,
        findOffsetCenterBetweenTwoPoints = MLB.calcLib.findOffsetCenterBetweenTwoPoints,
        findWeightedCenterOfPoints = MLB.calcLib.findWeightedCenterOfPoints;

    QUnit.module('sagitta');

    QUnit.test('calcSagittaSpherical', function () {
        var result = calcSagittaSpherical(13, 3);
        equal(withinRange(result, 0.271305, 0.000001), true, 'The sagitta should be 0.271305, is ' + result);
    });

    QUnit.test('calcFocalRatio', function () {
        var result = calcFocalRatio(13, 0.2713051698409146);
        equal(withinRange(result, 3, 0.000001), true, 'The focal ratio should be 3.0, is ' + result);
    });

    QUnit.test('calcSagittaParabolic', function () {
        var mirrorDia = 30,
            focalRatio = 0.25,
            expectedSphericalSagitta = 7.5,
            result = calcSagittaParabolic(mirrorDia, focalRatio);
        equal(result, expectedSphericalSagitta, 'sagitta is ' + result);
    });

    QUnit.test('calcFocalRatioFromSphericalSagitta', function () {
        var result = calcFocalRatioFromSphericalSagitta(30, 7.5);
        equal(withinRange(result, 0.25, 0.000001), true, 'The focal ratio should be 0.25, is ' + result);
    });

    // http://www.1728.org/sphere.htm and http://www.had2know.com/academics/spherical-cap-volume-surface-area-calculator.html
    QUnit.test('calcSagittalVolume', function () {
        var expected = 6.1439,
            result = calcSagittalVolume(10, 4);
        equal(withinRange(result, expected, 0.0001), true, 'The sagittal volume should be ' + expected + ', is ' + result);

        expected = 56287;
        result = calcSagittalVolume(70, 37 / 70 / 2);
        equal(withinRange(result, expected, 1), true, 'The sagittal volume should be ' + expected + ', is ' + result);
    });

    QUnit.test('calcSagittalVolumeParabolic', function () {
        var expected = 6.1379,
            result = calcSagittalVolumeParabolic(10, 4);
        equal(withinRange(result, expected, 0.0001), true, 'The sagittal volume should be ' + expected + ', is ' + result);
    });

    QUnit.test('calcSagittalVolumeRemovedDuringParabolization', function () {
        var expected = 0.006,
            result = calcSagittalVolumeRemovedDuringParabolization(10, 4);
        equal(withinRange(result, expected, 0.0001), true, 'The sagittal volume should be ' + expected + ', is ' + result);
    });

    QUnit.test('glassRemovalDuringPolishingFrom10MicronAluminumOxideCubicInches', function () {
        var expected =  0.030915,
            result = glassRemovalDuringPolishingFrom10MicronAluminumOxideCubicInches(10, 5);
		// area increase for F5 should be from 78.54 square inches to 78.59 square inches
        equal(withinRange(result, expected, 0.000001), true, 'Glass removed from a 10 inch F5 during polishing from 10 micron aluminum oxide should be ' + expected + ', is ' + result);
		
		expected =  0.030921;
		// essentially flat mirror
        result = glassRemovalDuringPolishingFrom10MicronAluminumOxideCubicInches(10, 100);
		// area increase for F5 should be from 78.54 square inches to 78.59 square inches
        equal(withinRange(result, expected, 0.000001), true, 'Glass removed from a 10 inch F100 during polishing from 10 micron aluminum oxide should be ' + expected + ', is ' + result);
	});

    QUnit.test('inchesToWavesGreenLight', function () {
        var sphereParabolaDifferenceInches = 0.000579, // 16" f3
            expected = 26.31,
            result = inchesToWavesGreenLight(sphereParabolaDifferenceInches);
        equal(withinRange(result, expected, 0.01), true, 'converting from inches to waves of green light should be ' + expected + ', is ' + result);
    });

    QUnit.test('calcRotatingFurnaceRPM', function () {
        var focalLengthMeters = 2,
            expected = 14.95,
            result = calcRotatingFurnaceRPM(focalLengthMeters);
        equal(withinRange(result, expected, 0.01), true, 'rotating furnance RPM for focal length in meters of ' + focalLengthMeters + ' should be ' + expected + ', is ' + result);
    });

    QUnit.module('diagonal sizing');

    QUnit.test('calcOffAxisIllumination', function () {
        var result = calcOffAxisIllumination(13.2, 40.3, 3.1, 9, 0.5);
        equal(withinRange(result, 0.878, 0.001), true, 'The off-axis illumination should be .878, is ' + result);

        result = calcOffAxisIllumination(13.2, 40.3, 3.1, 9, 0.1);
        equal(withinRange(result, 0.999, 0.001), true, 'The off-axis illumination should be .999, is ' + result);

        result = calcOffAxisIllumination(13.2, 40.3, 3.1, 9, 0);
        equal(withinRange(result, 1.0, 0.001), true, 'The off-axis illumination should be 1.0, is ' + result);

        result = calcOffAxisIllumination(13.2, 40.3, 3.5, 9, 0.5);
        equal(withinRange(result, 0.973, 0.001), true, 'The off-axis illumination should be .973, is ' + result);

        result = calcOffAxisIllumination(13.2, 40.3, 3.5, 9, 0.1);
        equal(withinRange(result, 1.0, 0.001), true, 'The off-axis illumination should be 1.0, is ' + result);

        result = calcOffAxisIllumination(13.2, 40.3, 3.5, 9, 0);
        equal(withinRange(result, 1.0, 0.001), true, 'The off-axis illumination should be 1.0, is ' + result);
    });

    QUnit.test('magnitudeDrop', function () {
        var result = magnitudeDrop(0.878011030887435);
        equal(withinRange(result, 0.141, 0.001), true, 'The magnitude drop should be 0.141, is ' + result);
    });

    QUnit.test('magnitudeDrop', function () {
        var result = magnitudeDrop(0.71);
        equal(withinRange(result, 0.37, 0.01), true, 'The magnitude drop should be 0.37, is ' + result);
    });

    QUnit.test('magnitudeDrop as a percentage', function () {
        var result = magnitudeDrop(0.96);
        equal(withinRange(result, 0.04, 0.01), true, 'The magnitude drop should be 0.04, is ' + result);
    });

    QUnit.test('magnitudeDrop as a percentage', function () {
        var result = magnitudeDrop(1.04);
        equal(withinRange(result, -0.04, 0.01), true, 'The magnitude drop should be -0.04, is ' + result);
    });

    QUnit.test('magnitudeDifferenceBetweenApertures', function () {
        var result = magnitudeDifferenceBetweenApertures(10, 20);
        equal(withinRange(result, -1.5, 0.01), true, 'The difference in magnitude between apertures of 10 and 20 should be -1.5, is ' + result);
    });

    QUnit.test('inverseMagnitudeDrop', function () {
        var result = inverseMagnitudeDrop(0.37);
        equal(withinRange(result, 0.71, 0.01), true, 'The inverse magnitude drop should be .71, is ' + result);
    });

    QUnit.test('diagObstructionArea', function () {
        var result = diagObstructionArea(10, 1);
        equal(withinRange(result, 0.01, 0), true, 'The diagonal obstruction should be 0.01, is ' + result);
    });

    QUnit.test('calcDiagOffset', function () {
        var result = calcDiagOffset(13.2, 40.3, 3.1, 9);
        equal(withinRange(result, 0.25, 0.01), true, 'The diagonal offset should be .25, is ' + result);
    });

    QUnit.test('calcDiagOffset2', function () {
        var result = calcDiagOffset2(13.2, 40.3, 3.1, 9);
        equal(withinRange(result, -0.26, 0.01), true, 'The diagonal offset should be -.26, is ' + result);
    });

    QUnit.test('calcDiagOffset3', function () {
        var result = calcDiagOffset3(3.1, 9);
        equal(withinRange(result, -0.26, 0.01), true, 'The diagonal offset should be -.26, is ' + result);
    });

    QUnit.test('areaIntersectingCircles', function () {
        var result = areaIntersectingCircles(100, 0, 100, 200, 0, 100) / (Math.PI * 100 * 100),
            expected = 0.391;

        equal(withinRange(result, expected, 0.001), true, 'The intersecting circle area should be, ' + expected + ', is ' + result);
    });

    /* eg,
    -0.7000000000000001,0.8109570241529027
    -0.6000000000000001,0.8444947700225293,
    -0.5,0.878011030887435,
    -0.4,0.9113610077701036,
    -0.30000000000000004,0.9442331974332544,
    -0.2,0.9757007976643087,
    -0.1,0.9999028396353284,
    0,1,
    0.1,0.9999028396353284,
    0.2,0.9757007976643087,
    0.30000000000000004,0.9442331974332544,
    0.4,0.9113610077701036,
    0.5,0.878011030887435,
    0.6000000000000001,0.8444947700225293,
    0.7000000000000001,0.8109570241529027
    */
    QUnit.test('getDiagIllumArray', function () {
        var result = getDiagIllumArray(13.2, 40.3, 3.1, 9, 0.1, 1.38);
        equal(result.length, 15, 'the array length should be 15, is ' + result.length + '; the array is ' + result);
        equal(withinRange(result[1][1], 0.844, 0.001), true, 'The off-axis illumination should be 0.844, is ' + result[1][1]);
        equal(withinRange(result[13][1], 0.844, 0.001), true, 'The off-axis illumination should be 0.844, is ' + result[13][1]);

        result = getDiagIllumArray(13.2, 40.3, 3.5, 9, 0.1, 1.38);
        equal(result.length, 15, 'the array length should be 15, is ' + result.length + '; the array is ' + result);
        equal(withinRange(result[1][1], 0.945, 0.001), true, 'The off-axis illumination should be 0.945, is ' + result[1][1]);
        equal(withinRange(result[13][1], 0.945, 0.001), true, 'The off-axis illumination should be 0.945, is ' + result[13][1]);
    });

    QUnit.module('foldedNewtonian.js');

    // example: mirror = 30, focal ratio = 3, diag = 8, tertiary distance = 2, eyepiece to mirror = 50, diag to mirror = 66
    // therefore maxWidth = diag to mirror = 66,
    // maxHeight = (diag * focal ratio + tertiary) * 2 = (8*3 + 2)*2 = 52 (primary axis is centered),
    // model width to height = 66/52 = 1.2692308,
    // graphics width = 200, height = 100,
    // graphics width to height = 200/100 = 2,
    // fit model into graphics:
    // if model's width/height > graphics width/height, then model wider than display, else display wider than model,
    // if model w/h > graphics w/h then scale by width: model width / display width, else scale by height: model height / display height,
    // eg, if model w/h = 1.2692308 and display w/h = 2, then display wider than model, given same height,
    // given model w = 66, h = 52 and graphics w = 200, h = 100:
    // therefore scale by height: graphics height of 100 / model height of 52 = scaling factor of 1.9230769,
    // otherwise would scale by width: graphics width of 200 / model width of 66 = scaling factor of 3.030303,
    // using scaling factor of 1.9230769, width = 1.9230769 * 66 = 126.92308, height = 1.9230769 * 52 = 100:
    // so some display width wasted since the narrower model has to fit within;
    // returned scalingFactor made smaller by a margin, eg if scaling factor is 1.9230769 then returned value is 1.53846152;
    // this test ignores tertiaryOffsetFromEdgeOfPrimary;
    QUnit.test('getFoldedNewtonianScalingFactor', function () {
        var result = getFoldedNewtonianScalingFactor(200, 100, 3, 8, 2, 0, 66);
        equal(withinRange(result, 1.538461, 0.000001), true, 'scalingFactor should be 1.538461, is ' + result);
    });

    QUnit.module('folded Newtonian');

    // original function call is calcFoldedNewtonian(mirrorDia, focalRatio, diagSize, focalPlaneToTertiaryDistance, tertiaryOffsetFromEdgeOfPrimary)
    QUnit.test('calcFoldedNewtonian', function () {
        var result = calcFoldedNewtonian(30, 2.9, 7, 3, 0);
        equal(withinRange(result.diagToPrimaryMirrorDistance, 66.7, 0.01), true, 'The diagToPrimaryMirrorDistance should be 66.7, is ' + result.diagToPrimaryMirrorDistance);
        equal(withinRange(result.focalPointToPrimaryMirrorDistance, 58.08, 0.01), true, 'The focalPointToPrimaryMirrorDistance should be 55.08, is ' + result.focalPointToPrimaryMirrorDistance);
        equal(withinRange(result.focalPointToDiagDistance, 20.3, 0.01), true, 'The focalPointToDiagDistance should be 20.3, is ' + result.focalPointToDiagDistance);
        equal(withinRange(result.elbowAngleDeg, 60.12, 0.01), true, 'The elbowAngleDeg should be 60.12, is ' + result.elbowAngleDeg);
        equal(withinRange(result.diagMajorAxisSize, 8.09, 0.01), true, 'The diagMajorAxisSize should be 8.09, is ' + result.diagMajorAxisSize);
    });

    QUnit.test('calcFoldedNewtonian focalPointToPrimaryMirrorDistance and focalPlaneToTertiaryDistance', function () {
        var result = calcFoldedNewtonian(30, 3, 10, 0, 0),
            expected = 34.02;
        equal(withinRange(result.focalPointToPrimaryMirrorDistance, expected, 0.01), true, 'The focalPointToPrimaryMirrorDistance should be ' + expected + ', is ' + result.focalPointToPrimaryMirrorDistance);

        // tertiaryOffsetFromEdgeOfPrimary of 1 should shrink diagonal to mirror distance by about 1, give a sufficiently sharp angle (result of a very large diagonal)
        result = calcFoldedNewtonian(30, 3, 10, 1, 0);
        expected = 35.18;
        equal(withinRange(result.focalPointToPrimaryMirrorDistance, expected, 0.01), true, 'The focalPointToPrimaryMirrorDistance should be ' + expected + ', is ' + result.focalPointToPrimaryMirrorDistance);
    });

    // new function call is calcFoldedNewtonian(mirrorDia, focalRatio, diagSize, focalPlaneToTertiaryDistance, tertiaryOffsetFromEdgeOfPrimary, focalPointToDiagDistance)
    QUnit.test('calcFoldedNewtonian with new optional parm focalPointToDiagDistance', function () {
        var result = calcFoldedNewtonian(30, 2.9, 7, 0, 0, 18);
        equal(withinRange(result.diagToPrimaryMirrorDistance, 69, 0.01), true, 'The diagToPrimaryMirrorDistance should be 69, is ' + result.diagToPrimaryMirrorDistance);
        equal(withinRange(result.focalPointToPrimaryMirrorDistance, 59.05, 0.01), true, 'The focalPointToPrimaryMirrorDistance should be 59.05, is ' + result.focalPointToPrimaryMirrorDistance);
        equal(withinRange(result.focalPointToDiagDistance, 18, 0.01), true, 'The focalPointToDiagDistance should be 18, is ' + result.focalPointToDiagDistance);
        equal(withinRange(result.elbowAngleDeg, 56.44, 0.01), true, 'The elbowAngleDeg should be 56.44, is ' + result.elbowAngleDeg);
        equal(withinRange(result.diagMajorAxisSize, 7.94, 0.01), true, 'The diagMajorAxisSize should be 7.94, is ' + result.diagMajorAxisSize);
    });

    QUnit.module('visual detection calculator: parms and data');

    QUnit.test('limiting magnitude', function () {
        var apertureIn = 13;
        var expectedLimitingMag = 16.37;
        var result = limitingMagnitude(apertureIn);
        equal(withinRange(result, expectedLimitingMag, 0.01), true, 'limiting magnitude from ' + apertureIn +' apertureIn should be ' + expectedLimitingMag + ', is ' + result);
    });

    QUnit.test('apertureInchesFromMagnitude', function () {
        var magnitude = 16.37;
        var expectedApertureIn = 13;
        var result = apertureInchesFromMagnitude(magnitude);
        equal(withinRange(result, expectedApertureIn, 0.01), true, 'aperture from ' + magnitude +' magnitude should be ' + expectedApertureIn + ', is ' + result);
    });

    QUnit.test('parms.apertureIn', function () {
        var parms, result, parms2, result2, originalResult;
        parms = new VisualDetectCalcParms();
        parms.apertureIn = 13.2;
        result = parms.apertureIn;
        equal(result, 13.2, 'apertureIn should be 13.2, is ' + result);

        parms2 = new VisualDetectCalcParms();
        parms2.apertureIn = 30;
        result2 = parms2.apertureIn;
        equal(result2, 30, 'copied apertureIn should be 30, is ' + result2);

        originalResult = parms.apertureIn;
        equal(originalResult, 13.2, 'original apertureIn should be 13.2, is ' + result);
    });

    QUnit.test('parms.apertureIn', function () {
        var parms, result, copiedParms, result2, originalResult;
        parms = new VisualDetectCalcParms();
        parms.apertureIn = 13.2;
        result = parms.apertureIn;
        equal(result, 13.2, 'apertureIn should be 13.2, is ' + result);

        copiedParms = parms.copyFrom();
        copiedParms.apertureIn = 30;
        result2 = copiedParms.apertureIn;
        equal(result2, 30, 'copied apertureIn should be 30, is ' + result2);

        originalResult = parms.apertureIn;
        equal(originalResult, 13.2, 'original apertureIn should be 13.2, is ' + result);
    });

    QUnit.test('visualDetectCalcData.logAngle[1]', function () {
        var data, result;
        data = visualDetectCalcData;
        result = data.logAngle[1];
        equal(result, 0.5563, 'logAngle[1] should be 0.5563, is ' + result);

        result = data.ltc[1][1];
        equal(result, -1.7747, 'ltc[1][1] should be -1.7747, is ' + result);
    });

    QUnit.module('visual detection calculator: the calculator');

    var visualDetectCalcParms = new VisualDetectCalcParms();
    visualDetectCalcParms.apertureIn = 13;
    visualDetectCalcParms.bkgndBrightEye = 21.5;
    visualDetectCalcParms.objName = 'California Nebula';
    visualDetectCalcParms.objMag = 5;
    visualDetectCalcParms.maxObjArcmin = 145;
    visualDetectCalcParms.minObjArcmin = 40;
    visualDetectCalcParms.eyepieceExitPupilmm = 6;
    visualDetectCalcParms.apparentFoV = 100;
    // can override defaults if desired
    //visualDetectCalcParms.eyeLimitMag = ;
    //visualDetectCalcParms.exitPupilmm = ;
    //visualDetectCalcParms.scopeTrans = ;
    //visualDetectCalcParms.singleEyeFactor = ;

    var visualDetectCalc = new VisualDetectCalc();

    QUnit.test('visualDetectCalc.calc()', function () {
        var parms, result;
        parms = visualDetectCalcParms.copyFrom();
        result = visualDetectCalc.calc(parms);
        equal(withinRange(result.logContrastDiff, 0.81793677405235943, 0.000001), true, 'The logContrastDiff should be 0.81793677405235943, is ' + result.logContrastDiff);
        equal(withinRange(result.actualFoV, 1.81708055723804, 0.000001), true, 'The actualFoV should be 1.81708055723804, is ' + result.actualFoV);
        equal(result.fitsFoV, true, 'The object should  fit the field of view, is ' + result.fitsFoV);
        equal(result.detectable, true, 'The object should  be detectable, is ' + result.detectable);
    });

    QUnit.test('visualDetectCalc.calc()', function () {
        var parms, result;
        parms = visualDetectCalcParms.copyFrom();
        parms.eyepieceExitPupilmm = 4;
        result = visualDetectCalc.calc(parms);
        equal(withinRange(result.logContrastDiff, 0.848671579113636, 0.000001), true, 'The logContrastDiff should be 0.848671579113636, is ' + result.logContrastDiff);
        equal(withinRange(result.actualFoV, 1.21138703815869, 0.000001), true, 'The actualFoV should be 1.21138703815869, is ' + result.actualFoV);
        equal(result.fitsFoV, true, 'The object should  fit the field of view, is ' + result.fitsFoV);
        equal(result.detectable, true, 'The object should  be detectable, is ' + result.detectable);
    });

    QUnit.test('NGC 134 example from Clarke\'s book', function () {
        var parms, result;
        parms = new VisualDetectCalcParms();
        parms.apertureIn = 8;
        parms.bkgndBrightEye = 24.25;
        parms.objName = 'NGC 134';
        parms.objMag = 11.4;
        parms.maxObjArcmin = 5;
        parms.minObjArcmin = 1;
        // for 187x per book
        parms.eyepieceExitPupilmm = 1.09;
        parms.apparentFoV = 60;
        // overriding defaults
        parms.exitPupilmm = 9;
        parms.scopeTrans = .7;
        parms.singleEyeFactor = 1;
        result = visualDetectCalc.calc(parms);
        equal(withinRange(result.logContrastDiff, 0.4, 0.1), true, 'The logContrastDiff should be 0.4, is ' + result.logContrastDiff);
    });

    QUnit.test('Sculptor System example from Clarke\'s book', function () {
        var parms, result;
        parms = new VisualDetectCalcParms();
        parms.apertureIn = 8;
        parms.bkgndBrightEye = 24.25;
        parms.objName = 'Sculptor System';
        parms.objMag = 8.8;
        parms.maxObjArcmin = 60;
        parms.minObjArcmin = 60;
        // for 27x per book
        parms.eyepieceExitPupilmm = 7.5;
        parms.apparentFoV = 60;
        // overriding defaults
        parms.exitPupilmm = 9;
        parms.scopeTrans = .7;
        parms.singleEyeFactor = 1;
        result = visualDetectCalc.calc(parms);
        /* book says 0.4 but this appears incorrect;
           book states that object with no telescope=26.3 and object in telescope at ODM is 24.5 (includes background!?), and background at magnification is 24.6:
           this last value appears incorrect, either ignoring reduction due to magnification or reduction due to scope transmission factor (both are approx 0.4),
           so correct value should be 24.25 - 0.4 - 0.4 = 25.05
         ie
            input values:
              aperture (in)                8
              eye limiting magnitude       6
              eye max exit pupil mm        9
              sky background brightness    24.25
              object name                  Sculptor System
              object integrated magnitude  8.8
              object dimensions arcmin     60 x 60
              eyepiece apparent field deg  60
            calculated values:
              magnification                27
              minimum useful X             23
              maximum useful X varies from 60 to 60
              actual field deg             2.2145669291338583
              object fits FoV?             true
              faintest star                15.268405970862784
              single eye mag reduction     0
              scope xmit mag reduction     0.38725489996435797
              brightness (mag/arcsec^2):
                object without telescope    26.319070773142013
                brightness reduction at X   0.395906230238124
                object in scope at X        27.102231903344496
                background in scope at X    25.033161130202483
                object+bkgnd in scope at X  24.495370025041154
              log object contrast          -0.8276283092568051
              log contrast required        -1.103609326833303
              log contrast difference      0.27598101757649784
              detectable?                  true
        */
        equal(withinRange(result.logContrastDiff, 0.3, 0.1), true, 'The logContrastDiff should be 0.4, is ' + result.logContrastDiff);
    });

    QUnit.test('visualDetectCalc.calc()', function () {
        // compare to my previous C version based on Clark's Visual Astronomy calculates logContrastDiff = 0.51
        // because exitPupilmm=6.5, exitPupilmm=9, scope transmission=.85 and missing single eye factor
        var parms, result;
        parms = new VisualDetectCalcParms();
        parms.apertureIn = 20;
        parms.bkgndBrightEye = 21;
        parms.objName = 'copy from earlier ODM unit test';
        parms.objMag = 12;
        parms.maxObjArcmin = 2;
        parms.minObjArcmin = 2;
        parms.eyepieceExitPupilmm = 7;
        parms.apparentFoV = 100;
        // overriding defaults
        parms.exitPupilmm = 9;
        parms.scopeTrans = .85;
        parms.singleEyeFactor = 1;
        result = visualDetectCalc.calc(parms);
        equal(withinRange(result.logContrastDiff, 0.51, 0.01), true, 'The logContrastDiff should be 0.51, is ' + result.logContrastDiff);
    });

    QUnit.test('visualDetectCalc.fitsFoV', function () {
        var parms, result;
        parms = visualDetectCalcParms.copyFrom();
        parms.eyepieceExitPupilmm = 1;
        result = visualDetectCalc.calc(parms);
        equal(result.fitsFoV, false, 'The object should not fit the field of view, is ' + result.fitsFoV);
    });

    QUnit.test('visualDetectCalc.detectable', function () {
        var parms, result;
        parms = visualDetectCalcParms.copyFrom();
        parms.objMag = 10;
        result = visualDetectCalc.calc(parms);
        equal(result.detectable, false, 'The object should not be detectable, is ' + result.detectable);
    });

    /*
    input values:
      aperture (in)                13
      eye limiting magnitude       6
      eye max exit pupil mm        7
      sky background brightness    21.5
      object name                  California Nebula
      object integrated magnitude  5
      object dimensions arcmin     145 x 40
      eyepiece apparent field deg  100
    calculated values:
      magnification                55
      minimum useful X             47
      maximum useful X varies from 41 to 150
      actual field deg             1.8170805572380375
      object fits FoV?             true
      faintest star                16.115820155402638
      single eye mag reduction     0.7525749891599529
      scope xmit mag reduction     0.24227503252014093
      brightness (mag/arcsec^2):
        object without telescope   23.036884505131138
        brightness reduction at X  0.3347339481530661
        object in scope at X       24.366468474964293
        background in scope at X   22.82958396983316
        object+bkgnd in scope at X 21.598732050134025
      log object contrast          -0.614753802052455
      log contrast required        -1.4326905761048156
      log contrast difference      0.8179367740523606
      detectable?                  true
    */
    QUnit.test('visualDetectCalc.includeResultAsString', function () {
        var parms, result;
        parms = visualDetectCalcParms.copyFrom();
        result = visualDetectCalc.includeResultAsString(visualDetectCalc.calc(parms)).text;
        equal(result.length > 0, true, 'result is ' + result);
    });

    var visualDetectCalcParms2 = new VisualDetectCalcParms();
    visualDetectCalcParms2.apertureIn = 13;
    visualDetectCalcParms2.bkgndBrightEye = 21.5;
    visualDetectCalcParms2.objName = 'Sombrero Galaxy';
    visualDetectCalcParms2.objMag = 8;
    visualDetectCalcParms2.maxObjArcmin = 9;
    visualDetectCalcParms2.minObjArcmin = 4;
    visualDetectCalcParms2.eyepieceExitPupilmm = 6;
    visualDetectCalcParms2.apparentFoV = 110;
    // can override defaults if desired
    //visualDetectCalcParms2.eyeLimitMag = ;
    //visualDetectCalcParms2.exitPupilmm = ;
    //visualDetectCalcParms2.scopeTrans = ;
    //visualDetectCalcParms2.singleEyeFactor = ;

    /*
    result is
    input values:
        aperture (in) 13
        eye limiting magnitude 6
        eye max exit pupil mm 7
        sky background brightness 21.5
        object name Sombrero Galaxy object
        integrated magnitude 8
        object dimensions arcmin 9 x 4
        eyepiece apparent field deg 110
    calculated values:
        magnification 55
        minimum useful X 47
        maximum useful X varies from 330 to 330
        actual field deg 1.9987886129618413
        object fits FoV? true
        faintest star 16.115820155402638
        single eye mag reduction 0.7525749891599529
        scope xmit mag reduction 0.24227503252014093
        brightness (mag/arcsec^2):
            object without telescope 20.519070773142015
            brightness reduction at X 0.3347339481530661
            object in scope at X 21.84865474297517
            background in scope at X 22.82958396983316
            object+bkgnd in scope at X 20.48448901600736
        log object contrast 0.39237169074319383
        log contrast required -0.966861934161181
        log contrast difference 1.3592336249043748
        detectable? true
    */
    QUnit.test('visualDetectCalc.includeResultAsString, Sombrero Galaxy through 13 inch f3', function () {
        var parms, result;
        parms = visualDetectCalcParms2.copyFrom();
        result = visualDetectCalc.includeResultAsString(visualDetectCalc.calc(parms)).text;
        equal(result.length > 0, true, 'result is ' + result);
    });

    QUnit.module('visual detection calculator: eyepiece exit pupil sequence');

    QUnit.test('ExitPupilSequence', function () {
        var parms, result;
        parms = visualDetectCalcParms.copyFrom();
        result = new VisualDetectCalcExitPupils(parms);
        // 7mm exit pupil, per above test
        equal(result[6].parms.exitPupilmm, 7, 'The exitPupilmm should be 7, is ' + result[6].parms.exitPupilmm);
        equal(result[6].parms.eyepieceExitPupilmm, 7, 'The eyepieceExitPupilmm should be 7, is ' + result[6].parms.eyepieceExitPupilmm);
        equal(withinRange(result[6].logContrastDiff, 0.827429778789198, 0.000001), true, 'The logContrastDiff should be 0.827429778789198, is ' + result[6].logContrastDiff);
        equal(withinRange(result[6].actualFoV, 2.11992731677771, 0.000001), true, 'The actualFoV should be 2.11992731677771, is ' + result[6].actualFoV);
        // 4mm exit pupil
        equal(result[3].parms.exitPupilmm, 7, 'The exitPupilmm should be 7, is ' + result[3].parms.exitPupilmm);
        equal(result[3].parms.eyepieceExitPupilmm, 4, 'The eyepieceExitPupilmm should be 4, is ' + result[3].parms.eyepieceExitPupilmm);
        equal(withinRange(result[3].logContrastDiff, 0.848671579113636, 0.000001), true, 'The logContrastDiff should be 0.848671579113636, is ' + result[3].logContrastDiff);
        equal(withinRange(result[3].actualFoV, 1.21138703815869, 0.000001), true, 'The actualFoV should be 1.21138703815869, is ' + result[3].actualFoV);
        // 1mm exit pupil
        equal(result[0].parms.exitPupilmm, 7, 'The exitPupilmm should be 7, is ' + result[0].parms.exitPupilmm);
        equal(result[0].parms.eyepieceExitPupilmm, 1, 'The eyepieceExitPupilmm should be 1, is ' + result[0].parms.eyepieceExitPupilmm);
        equal(withinRange(result[0].logContrastDiff, 0.779495670342709, 0.000001), true, 'The logContrastDiff should be 0.779495670342709, is ' + result[0].logContrastDiff);
        equal(withinRange(result[0].actualFoV, 0.302846759539673, 0.000001), true, 'The actualFoV should be 0.302846759539673, is ' + result[0].actualFoV);
    });

    QUnit.module('visual detection calculator: aperture sequence');

    QUnit.test('VisualDetectCalcApertures', function () {
        var parms, result, halfAperture, dblAperture, halfApertureParms, halfApertureResults, dblApertureParms, dblApertureResults;
        parms = visualDetectCalcParms.copyFrom();
        result = new VisualDetectCalcApertures(parms);
        // 7mm exit pupil, per above test
        equal(result[1][6].parms.exitPupilmm, 7, 'The exitPupilmm should be 7, is ' + result[1][6].parms.exitPupilmm);
        equal(result[1][6].parms.eyepieceExitPupilmm, 7, 'The eyepieceExitPupilmm should be 7, is ' + result[1][6].parms.eyepieceExitPupilmm);
        equal(withinRange(result[1][6].logContrastDiff, 0.827429778789198, 0.000001), true, 'The logContrastDiff should be 0.827429778789198, is ' + result[1][6].logContrastDiff);
        equal(withinRange(result[1][6].actualFoV, 2.11992731677771, 0.000001), true, 'The actualFoV should be 2.11992731677771, is ' + result[1][6].actualFoV);
        // 4mm exit pupil
        equal(result[1][3].parms.exitPupilmm, 7, 'The exitPupilmm should be 7, is ' + result[1][3].parms.exitPupilmm);
        equal(result[1][3].parms.eyepieceExitPupilmm, 4, 'The eyepieceExitPupilmm should be 4, is ' + result[1][3].parms.eyepieceExitPupilmm);
        equal(withinRange(result[1][3].logContrastDiff, 0.848671579113636, 0.000001), true, 'The logContrastDiff should be 0.848671579113636, is ' + result[1][3].logContrastDiff);
        equal(withinRange(result[1][3].actualFoV, 1.21138703815869, 0.000001), true, 'The actualFoV should be 1.21138703815869, is ' + result[1][3].actualFoV);
        // 1mm exit pupil
        equal(result[1][0].parms.exitPupilmm, 7, 'The exitPupilmm should be 7, is ' + result[1][0].parms.exitPupilmm);
        equal(result[1][0].parms.eyepieceExitPupilmm, 1, 'The eyepieceExitPupilmm should be 1, is ' + result[1][0].parms.eyepieceExitPupilmm);
        equal(withinRange(result[1][0].logContrastDiff, 0.779495670342709, 0.000001), true, 'The logContrastDiff should be 0.779495670342709, is ' + result[1][0].logContrastDiff);
        equal(withinRange(result[1][0].actualFoV, 0.302846759539673, 0.000001), true, 'The actualFoV should be 0.302846759539673, is ' + result[1][0].actualFoV);

        // test apertures
        halfAperture = result[2][0].parms.apertureIn;
        equal(result[1][0].parms.apertureIn/2, halfAperture, 'The aperture should be half of ' + result[1][0].parms.apertureIn + ', is ' + halfAperture);
        dblAperture = result[0][0].parms.apertureIn;
        equal(result[1][0].parms.apertureIn*2, dblAperture, 'The aperture should be double of ' + result[1][0].parms.apertureIn + ', is ' + dblAperture);

        // test logContrasts, at exitPupilmm=6
        halfApertureParms = visualDetectCalcParms.copyFrom();
        halfApertureParms.apertureIn /= 2;
        halfApertureResults = visualDetectCalc.calc(halfApertureParms);
        equal(halfApertureResults.logContrastDiff, result[2][5].logContrastDiff, 'The log contrast should be ' + result[2][5].logContrastDiff + ', is ' + halfApertureResults.logContrastDiff);
        dblApertureParms = visualDetectCalcParms.copyFrom();
        dblApertureParms.apertureIn *= 2;
        dblApertureResults = visualDetectCalc.calc(dblApertureParms);
        equal(dblApertureResults.logContrastDiff, result[0][5].logContrastDiff, 'The log contrast should be ' + result[0][5].logContrastDiff + ', is ' + dblApertureResults.logContrastDiff);
    });

    QUnit.module('calcNewtBaffle');

    // test values verified by graph in baffle.html
    QUnit.test('calcNewtBaffle', function () {
        var focalPlaneDia, focuserBarrelBottomToFocalPlaneDistance, focuserBarrelID, diagSizeMinorAxis, diagToFocalPlaneDistance, diagtoFocuserBaffleDistance, diagToOppositeSideBaffleDistance, primaryMirrorDia, primaryMirrorFocalLength, primaryToBaffleDistance, tubeID, results;
        focalPlaneDia = 1.4;
        focuserBarrelBottomToFocalPlaneDistance = 2.5;
        focuserBarrelID = 1.8;
        diagSizeMinorAxis = 3.1;
        diagToFocalPlaneDistance = 9;
        diagtoFocuserBaffleDistance = 6;
        diagToOppositeSideBaffleDistance = 7;
        primaryMirrorDia = 13.2;
        primaryMirrorFocalLength = 40.2;
        primaryToBaffleDistance = 4;
        tubeID = primaryMirrorDia + 2;
        results = calcNewtBaffle(focalPlaneDia, focuserBarrelBottomToFocalPlaneDistance, focuserBarrelID, diagSizeMinorAxis, diagToFocalPlaneDistance, diagtoFocuserBaffleDistance, diagToOppositeSideBaffleDistance, primaryMirrorFocalLength, primaryToBaffleDistance, tubeID);
        equal(withinRange(results.focuserBaffleID, 1.97, 0.01), true, 'The focuser baffle ID should be 1.97, is ' + results.focuserBaffleID);
        equal(withinRange(results.focuserBaffleOD, 2.44, 0.01), true, 'The focuser baffle ID should be 2.44, is ' + results.focuserBaffleOD);
        equal(withinRange(results.diagonalBaffleOD, 16.55, 0.01), true, 'The diagonal baffle OD should be 16.55, is ' + results.diagonalBaffleOD);
        equal(withinRange(results.primaryBaffleOD, 16.70, 0.01), true, 'The primary mirror baffle OD should be 16.70, is ' + results.primaryBaffleOD);
        equal(withinRange(results.tubeExtension, 7, 0.01), true, 'The tube extension beyond the primary mirror to act as primary baffle should be 7, is ' + results.tubeExtension);
    });

    QUnit.module('createAltazConstantMotionTrackingErrors');

    QUnit.test('data return', function () {
        var latitudeRad = 40 * uom.degToRad,
            constantTrackRateTimeRad = 300 * uom.secToRad,
            spacingDeg = 2,
            expected = 18.969,
            data = createAltazConstantMotionTrackingErrors(latitudeRad, constantTrackRateTimeRad, spacingDeg),
            results = data[5][2] / uom.arcsecToRad;

        equal(withinRange(results, expected, 0.001), true, 'The constant track rate error over 5 minutes should be ' + expected + ', is ' + results);
    });

    QUnit.module('slumping');

    QUnit.test('sharply slumped: dia=30, FR=1', function () {
        var mirrorDia = 30,
            focalRatio = 1,
            expectedEffectiveEntranceAperture = 29.688475110542754,
            result = calcMirrorSlumpingParms(mirrorDia, focalRatio);
        equal(withinRange(result.effectiveDia, expectedEffectiveEntranceAperture, 0.000001), true, 'result = ' + result.effectiveDia);
    });

    QUnit.test('barely slumped: dia=30, FR=5', function () {
        var mirrorDia = 30,
            focalRatio = 5,
            expectedEffectiveEntranceAperture = 29.987501562406997,
            result = calcMirrorSlumpingParms(mirrorDia, focalRatio);
        equal(withinRange(result.effectiveDia, expectedEffectiveEntranceAperture, 0.000001), true, 'result = ' + result.effectiveDia);
    });

    QUnit.test('13" F3', function () {
        var mirrorDia = 13.2,
            focalRatio = 3,
            expectedEffectiveEntranceAperture = 13.18472752612914,
            expectedSphericalSagitta = 0.275,
            expectedEdgeAngleDeg = 4.775,
            result = calcMirrorSlumpingParms(mirrorDia, focalRatio);
        equal(withinRange(result.effectiveDia, expectedEffectiveEntranceAperture, 0.000001), true, 'result = ' + result.effectiveDia);
        equal(withinRange(result.sphericalSagitta, expectedSphericalSagitta, 0.001), true, 'result = ' + result.sphericalSagitta);
        equal(withinRange(result.edgeAngleDeg, expectedEdgeAngleDeg, 0.001), true, 'result = ' + result.edgeAngleDeg);
    });

    QUnit.test('42" F2.9', function () {
        var mirrorDia = 42,
            focalRatio = 2.9,
            expectedEffectiveEntranceAperture = 41.94799792367687,
            expectedSphericalSagitta = 0.905,
            expectedEdgeAngleDeg = 4.939,
            result = calcMirrorSlumpingParms(mirrorDia, focalRatio);
        equal(withinRange(result.effectiveDia, expectedEffectiveEntranceAperture, 0.000001), true, 'result = ' + result.effectiveDia);
        equal(withinRange(result.sphericalSagitta, expectedSphericalSagitta, 0.001), true, 'result = ' + result.sphericalSagitta);
        equal(withinRange(result.edgeAngleDeg, expectedEdgeAngleDeg, 0.001), true, 'result = ' + result.edgeAngleDeg);
    });

    QUnit.module('sphere to parabola difference');

    QUnit.test('6 inch F8', function () {
        var mirrorDia = 6,
            focalRatio = 8,
            expectedEffectiveEntranceAperture = 0.0000114,
            result = calcSphereParabolaDifference(mirrorDia, focalRatio);
        equal(withinRange(result, expectedEffectiveEntranceAperture, 0.0000001), true, 'result = ' + result);
    });

    QUnit.module('ronchi');

    QUnit.test('wavefrontError', function () {
        var mirrorDia = 20,
            radiusOfCurvature = 200,
            correctionFactor = 0.86,
            result = wavefrontError(mirrorDia, radiusOfCurvature, correctionFactor),
            expected = 0.5108704878136372;
        equal(result, expected, 'result = ' + result + ', should be ' + expected);
    });

    // parabolic correction tolerances: focalRatio 1: 98.3%; focalRatio 2: 96.7%; focalRatio 3: 95%; focalRatio 4: 93.3%; focalRatio 5: 91.7%; focalRatio 6: 90%; focalRatio 7: 88.4%; focalRatio 8: 86.7%; focalRatio 9: 85%; focalRatio 10: 83.4%;
    QUnit.test('findAllowableCorrection, for a range of focal ratios from f/1 to f/10, mirror dia = 10', function () {
        var mirrorDia = 10,
            focalRatio,
            results = [],
            ix,
            displayResults = 'parabolic correction tolerances: ',
            expected = 0.83359375;

        for (ix = 0; ix < 10; ix++) {
            focalRatio = (ix + 1);
            results[ix] = findAllowableCorrection(mirrorDia, mirrorDia * focalRatio * 2);
            displayResults += 'focalRatio ' + focalRatio + ': ' + Math.round(results[ix] * 1000) / 10 + '%; ';
        }

        equal(results[9], expected, 'results[9] = ' + results[9] + ', should be ' + expected);
    });

    // as above, but double the aperture to demonstrate that aperture has no bearing on allowable correction
    QUnit.test('findAllowableCorrection, for a range of focal ratios from f/1 to f/10, mirror dia = 20', function () {
        var mirrorDia = 20,
            focalRatio,
            results = [],
            ix,
            displayResults = 'parabolic correction tolerances: ',
            expected = 0.83359375;

        for (ix = 0; ix < 10; ix++) {
            focalRatio = (ix + 1);
            results[ix] = findAllowableCorrection(mirrorDia, mirrorDia * focalRatio * 2);
            displayResults += 'focalRatio ' + focalRatio + ': ' + Math.round(results[ix] * 1000) / 10 + '%; ';
        }

        equal(results[9], expected, 'results[9] = ' + results[9] + ', should be ' + expected);
    });

    QUnit.test('calcAllowableParabolicDeviationForQuarterWavefront for f/10', function () {
        var focalRatio = 10,
            expected = 0.16699999999999998,
            result = calcAllowableParabolicDeviationForQuarterWavefront(focalRatio);
        equal(result, expected, 'result = ' + result + ', should be ' + expected);
    });

    QUnit.module('Dob friction of movement');

    /*
    Dob friction, from Telescope Making #8, pg 36-, Richard Berry

    Alt: f*w*sec(ba)*r/l
    Az: f*w*r/(l*cos(ba))
    F=friction (Teflon on formica) =0.1
    W=weight (that the bearing is carrying)
    R=bearing radius
    Ba=bearing angle
    L=length of the moment arm

    Example 16 inch f5:
        AZ radius 9, weight 120 lbs, 45deg bearing angle, moment arm 40inches, f=0.083
        0.088*120*9/(cos(45)*40)=3.2
        ALT radius 4, weight 80 lbs, 60deg bearing angle, moment arm 40inches, f=0.088
        1.3*80*(1/cos(60))*4/40=2.1
    */
    QUnit.test('az and alt friction', function () {
        var allowableError = 0.000000000000001,
            azimuthFrictionCoefficient = 0.083,
            altitudeFrictionCoefficient = 0.13,
            momentArm = 40,
            azWeight = 120,
            altWeight = 80,
            azBearingRadius = 9,
            altBearingRadius = 4,
            altBearingAngleDegFromVertical = 60,
            altitudeAngleDegFromHorizontal = 45,
            result = MLB.calcLib.calcDobFriction(azimuthFrictionCoefficient, altitudeFrictionCoefficient, momentArm, azWeight, altWeight, azBearingRadius, altBearingRadius, altBearingAngleDegFromVertical, altitudeAngleDegFromHorizontal),
            expected = [3.169252593278106, 2.08];

        equal(withinRange(result.az, expected[0], allowableError), true, 'az result = ' + result.az + ', should be ' + expected[0]);
        equal(withinRange(result.alt, expected[1], allowableError), true, 'alt result = ' + result.alt + ', should be ' + expected[1]);
    });

    QUnit.module('SQM to NELM converter');

    // from http://www.unihedron.com/projects/darksky/NELM2BCalc.html

    QUnit.test('SQMtoNELMconverter', function () {
        var expected,
            result,
            allowableError = 0.0001;

        expected = 6;
        result = SQMtoNELMconverter(20.8);
        equal(withinRange(result, expected, allowableError), true, 'result = ' + result + ', should be ' + expected);
    });

    QUnit.test('NELMtoSQMconverter', function () {
        var expected,
            result,
            allowableError = 0.0001;

        expected = 20.8;
        result = NELMtoSQMconverter(6);
        equal(withinRange(result, expected, allowableError), true, 'result = ' + result + ', should be ' + expected);
    });

    QUnit.module('artificialStarDistance');

    QUnit.test('artificialStarDistanceMM', function () {
        var expected,
            result;

        expected = '8984';
        result = artificialStarDistanceMM(152, 912);
        equal(result, expected, result + ' should be ' + expected);
    });

    QUnit.test('artificialStarDistanceInches', function () {
        var expected,
            result;

        expected = '355';
        result = artificialStarDistanceInches(6, 36);
        equal(result, expected, result + ' should be ' + expected);
    });

    QUnit.test('artificialStarDistanceInches', function () {
        var expected,
            result;

        expected = '4495';
        result = artificialStarDistanceInches(16, 16 * 4.5);
        equal(result, expected, result + ' should be ' + expected);
    });

    QUnit.module('telescope optimizer');

    var MLBScopeTest5Parms = function () {
        this.apertureInches = 13.1,
        this.FOVdeg = 1.762,
        this.eyepieceFocalLengthmm = 21,
        this.eyepieceFieldStopmm = 36.2,
        this.eyePupilmm = 5.936,    // ignores coma corrector, assumes focal ratio of 3.54; with coma corrector mag of 1.15, focal ratio would be 3.08
        this.expected = undefined,
        this.allowableError = 0.01
    };

    QUnit.test('calcApertureFromFOV_EyepieceFL_EyepieceFieldStop_EyePupil', function () {
        var parms = new MLBScopeTest5Parms(),
            expected = parms.apertureInches,
            result;

        result = calcApertureFromFOV_EyepieceFL_EyepieceFieldStop_EyePupil(parms.FOVdeg, parms.eyepieceFocalLengthmm, parms.eyepieceFieldStopmm, parms.eyePupilmm);
        equal(withinRange(result, expected, parms.allowableError), true, 'result = ' + result + ', should be ' + expected);
    });

    QUnit.test('calcFOVFromAperture_EyepieceFL_EyepieceFieldStop_EyePupil', function () {
        var parms = new MLBScopeTest5Parms(),
            expected = parms.FOVdeg,
            result;

        result = calcFOVFromAperture_EyepieceFL_EyepieceFieldStop_EyePupil(parms.apertureInches, parms.eyepieceFocalLengthmm, parms.eyepieceFieldStopmm, parms.eyePupilmm);
        equal(withinRange(result, expected, parms.allowableError), true, 'result = ' + result + ', should be ' + expected);
    });

    QUnit.test('calcEyePupilFromAperture_FOV_EyepieceFL_EyepieceFieldStop', function () {
        var parms = new MLBScopeTest5Parms(),
            expected = parms.eyePupilmm,
            result;

        result = calcEyePupilFromAperture_FOV_EyepieceFL_EyepieceFieldStop(parms.apertureInches, parms.FOVdeg, parms.eyepieceFocalLengthmm, parms.eyepieceFieldStopmm);
        equal(withinRange(result, expected, parms.allowableError), true, 'result = ' + result + ', should be ' + expected);
    });

    QUnit.test('calcEyepieceFieldStopFromAperture_FOV_EyepieceFL_EyePupil', function () {
        var parms = new MLBScopeTest5Parms(),
            expected = parms.eyepieceFieldStopmm,
            result;

        result = calcEyepieceFieldStopFromAperture_FOV_EyepieceFL_EyePupil(parms.apertureInches, parms.FOVdeg, parms.eyepieceFocalLengthmm, parms.eyePupilmm);
        equal(withinRange(result, expected, parms.allowableError), true, 'result = ' + result + ', should be ' + expected);
    });

    QUnit.test('calcEyepieceFLFromAperture_FOV_EyepieceFieldStop_EyePupil', function () {
        var parms = new MLBScopeTest5Parms(),
            expected = parms.eyepieceFocalLengthmm,
            result;

        result = calcEyepieceFLFromAperture_FOV_EyepieceFieldStop_EyePupil(parms.apertureInches, parms.FOVdeg, parms.eyepieceFieldStopmm, parms.eyePupilmm);
        equal(withinRange(result, expected, parms.allowableError), true, 'result = ' + result + ', should be ' + expected);
    });

    var MLBScopeTest4Parms = function () {
        this.apertureInches = 13.1,
        this.FOVdeg = 1.762,
        this.focalRatio = 3.54,    // ignores coma corrector; with coma corrector mag of 1.15, FR would be 3.08
        this.eyepieceFieldStopmm = 36.2,
        this.expected = undefined,
        this.allowableError = 0.02
    };

    QUnit.test('calcApertureFromFOV_FocalRatio_EyepieceFieldStop', function () {
        var parms = new MLBScopeTest4Parms(),
            expected = parms.apertureInches,
            result;

        result = calcApertureFromFOV_FocalRatio_EyepieceFieldStop(parms.FOVdeg, parms.focalRatio, parms.eyepieceFieldStopmm);
        equal(withinRange(result, expected, parms.allowableError), true, 'result = ' + result + ', should be ' + expected);
    });

    QUnit.test('calcFOVFromAperture_FocalRatio_EyepieceFieldStop', function () {
        var parms = new MLBScopeTest4Parms(),
            expected = parms.FOVdeg,
            result;

        result = calcFOVFromAperture_FocalRatio_EyepieceFieldStop(parms.apertureInches, parms.focalRatio, parms.eyepieceFieldStopmm);
        equal(withinRange(result, expected, parms.allowableError), true, 'result = ' + result + ', should be ' + expected);
    });

    QUnit.test('calcFocalRatioFromAperture_FOV_EyepieceFieldStop', function () {
        var parms = new MLBScopeTest4Parms(),
            expected = parms.focalRatio,
            result;

        result = calcFocalRatioFromAperture_FOV_EyepieceFieldStop(parms.apertureInches, parms.FOVdeg, parms.eyepieceFieldStopmm);
        equal(withinRange(result, expected, parms.allowableError), true, 'result = ' + result + ', should be ' + expected);
    });

    QUnit.test('calcEyepieceFieldStopFromAperture_FOV_FocalRatio', function () {
        var parms = new MLBScopeTest4Parms(),
            expected = parms.eyepieceFieldStopmm,
            result;

        result = calcEyepieceFieldStopFromAperture_FOV_FocalRatio(parms.apertureInches, parms.FOVdeg, parms.focalRatio);
        equal(withinRange(result, expected, parms.allowableError), true, 'result = ' + result + ', should be ' + expected);
    });

    var MLBScopeTest4ParmsComaCorrectorFactor = function () {
        this.apertureInches = 13.1,
        this.FOVdeg = 1.762,
        this.focalRatio = 3.08,
        this.eyepieceFieldStopmm = 36.24,
        this.comaCorrectorFactor = 1.15,
        this.expected = undefined,
        this.allowableError = 0.02
    };

    QUnit.test('calcApertureFromFOV_FocalRatio_EyepieceFieldStop_ComaCorrectorFactor', function () {
        var parms = new MLBScopeTest4ParmsComaCorrectorFactor(),
            expected = parms.apertureInches,
            result;

        result = calcApertureFromFOV_FocalRatio_EyepieceFieldStop_ComaCorrectorFactor(parms.FOVdeg, parms.focalRatio, parms.eyepieceFieldStopmm, parms.comaCorrectorFactor);
        equal(withinRange(result, expected, parms.allowableError), true, 'result including coma corrector = ' + result + ', should be ' + expected);
    });

    QUnit.test('calcFOVFromAperture_FocalRatio_EyepieceFieldStop_ComaCorrectorFactor', function () {
        var parms = new MLBScopeTest4ParmsComaCorrectorFactor(),
            expected = parms.FOVdeg,
            result;

        result = calcFOVFromAperture_FocalRatio_EyepieceFieldStop_ComaCorrectorFactor(parms.apertureInches, parms.focalRatio, parms.eyepieceFieldStopmm, parms.comaCorrectorFactor);
        equal(withinRange(result, expected, parms.allowableError), true, 'result including coma corrector = ' + result + ', should be ' + expected);
    });

    QUnit.test('calcFocalRatioFromAperture_FOV_EyepieceFieldStop_ComaCorrectorFactor', function () {
        var parms = new MLBScopeTest4ParmsComaCorrectorFactor(),
            expected = parms.focalRatio,
            result;

        result = calcFocalRatioFromAperture_FOV_EyepieceFieldStop_ComaCorrectorFactor(parms.apertureInches, parms.FOVdeg, parms.eyepieceFieldStopmm, parms.comaCorrectorFactor);
        equal(withinRange(result, expected, parms.allowableError), true, 'result including coma corrector = ' + result + ', should be ' + expected);
    });

    QUnit.test('calcEyepieceFieldStopFromAperture_FOV_FocalRatio_ComaCorrectorFactor', function () {
        var parms = new MLBScopeTest4ParmsComaCorrectorFactor(),
            expected = parms.eyepieceFieldStopmm,
            result;

        result = calcEyepieceFieldStopFromAperture_FOV_FocalRatio_ComaCorrectorFactor(parms.apertureInches, parms.FOVdeg, parms.focalRatio, parms.comaCorrectorFactor);
        equal(withinRange(result, expected, parms.allowableError), true, 'result including coma corrector = ' + result + ', should be ' + expected);
    });

    QUnit.test('resolutionFromAperture_Magnification', function () {
        var apertureInches = 5,
            magnification,
            result,
            expected;

        // can't reach DawesLimit: resolution limited by magnification
        magnification = 30;
        expected = 8;
        result = resolutionFromAperture_Magnification(apertureInches, magnification);
        equal(withinRange(result, expected, 0.001), true, 'result = ' + result + ', should be ' + expected);

        // reaches DawesLimit: magnification limited by Dawes Limit
        magnification = 300;
        expected = 0.92;
        result = resolutionFromAperture_Magnification(apertureInches, magnification);
        equal(withinRange(result, expected, 0.001), true, 'result = ' + result + ', should be ' + expected);
    });

    QUnit.test('calcTheoreticalResolutionArcsec', function () {
        var apertureInches = 10,
            result,
            expected = 0.46;

        result = calcTheoreticalResolutionArcsec(apertureInches);
        equal(withinRange(result, expected, 0.001), true, 'result = ' + result + ', should be ' + expected);
    });

    QUnit.test('calcAiryDiskInches', function () {
        var focalRatio = 5,
            result,
            expected = 0.000268;

        result = calcAiryDiskInches(focalRatio);
        equal(withinRange(result, expected, 0.00001), true, 'result = ' + result + ', should be ' + expected);
    });

    QUnit.test('calcProjectedFocuserBaffleRadius', function () {
        var eyepieceFieldStop = 2,
            barrelTubeID = 3,
            focalPlaneToFocuserBarrelBottomDistance = 3,
            focalPlaneToDiagDistance = 10,
            telescopeTubeOD = 17,
            telescopeTubeThickness = 0.5,
            expected = 14,
            result = calcProjectedFocuserBaffleRadius(eyepieceFieldStop, barrelTubeID, focalPlaneToFocuserBarrelBottomDistance, focalPlaneToDiagDistance, telescopeTubeOD, telescopeTubeThickness);

        equal(withinRange(result, expected, 0.001), true, 'The projected focuser baffle radius should be ' + expected + ', is ' + result);
    });

    QUnit.test('scalingFactor', function () {
        var maxWidth = 1020,
            maxHeight = 420,
            modelWidth = 40,
            modelHeight = 5,
            border = 10,
            expectedScalingFactor = 25,
            expectedWidth = 1020,
            expectedHeight = 145,
            result = scalingFactor(maxWidth, maxHeight, modelWidth, modelHeight, border);

        equal(withinRange(result.scalingFactor, expectedScalingFactor, 0.001), true, 'The scaling factor should be ' + expectedScalingFactor + ', is ' + result.scalingFactor);
        equal(withinRange(result.width, expectedWidth, 0.001), true, 'The width should be ' + expectedWidth + ', is ' + result.width);
        equal(withinRange(result.height, expectedHeight, 0.001), true, 'The height should be ' + expectedHeight + ', is ' + result.height);
    });

    QUnit.test('calcMaxMagnification', function () {
        var apertureInches = 2.5,
            expected = 67.5,
            result = calcMaxMagnification(apertureInches);

        equal(withinRange(result, expected, 0.001), true, 'Max magnification should be ' + expected + ', is ' + result);
    });

    QUnit.test('calcMinMagnification', function () {
        var apertureInches = 2.5,
            expected = 9,
            result = calcMinMagnification(apertureInches);

        equal(withinRange(result, expected, 0.001), true, 'Min magnification should be ' + expected + ', is ' + result);
    });

    QUnit.test('calcComaFreeDiaInches', function () {
        var focalRatio = 5,
            expected = 0.0875,
            result = calcComaFreeDiaInches(focalRatio);

        equal(withinRange(result, expected, 0.001), true, 'coma free diameter in inches should be ' + expected + ', is ' + result);
    });

    QUnit.test('calcDiopter', function () {
        var focalLengthInches = 17,
            expected =  2.3159,
            result = calcDiopter(focalLengthInches);

        equal(withinRange(result, expected, 0.01), true, 'diopter should be ' + expected + ', is ' + result);
    });

    QUnit.test('calcFocalLengthInches', function () {
        var diopter = 2.3159,
            expected = 17,
            result = calcFocalLengthInches(diopter);

        equal(withinRange(result, expected, 0.01), true, 'telescope focal length should be ' + expected + ', is ' + result);
    });

    QUnit.test('calcMagnifyingLensPower', function () {
        var diopter = 4,
            expected = 2,
            result = calcMagnifyingLensPower(diopter).lensHeldCloseToEye;

        equal(withinRange(result, expected, 0.01), true, 'lens magnifying power should be ' + expected + ', is ' + result);
    });

    // http://www.rfroyce.com/standards.htm

    QUnit.test('calcStrehlFromRMS', function () {
        var rms = 0.028,
            expected = 0.969,
            result = calcStrehlFromRMS(rms);

        equal(withinRange(result, expected, 0.001), true, 'Strehl should be ' + expected + ', is ' + result);
    });

    QUnit.test('calcRMSFromStrehl', function () {
        var Strehl = 0.969,
            expected = 0.028,
            result = calcRMSFromStrehl(Strehl);

        equal(withinRange(result, expected, 0.001), true, 'RMS should be ' + expected + ', is ' + result);
    });

    QUnit.test('calcPVFromRMS', function () {
        var rms = 0.071,
            expected = 1 / 4,
            result = calcPVFromRMS(rms);

        equal(withinRange(result, expected, 0.001), true, 'PV should be ' + expected + ', is ' + result);
    });

    QUnit.test('calcRMSFromPV', function () {
        var PV = 1 / 4,
            expected = 0.071,
            result = calcRMSFromPV(PV);

        equal(withinRange(result, expected, 0.001), true, 'RMS should be ' + expected + ', is ' + result);
    });

    QUnit.test('calcApertureFromEyepieceApparentFOVdegs_Pupil_ObjectApparentSize', function () {
        var eyepieceApparentFOVdegs = [100, 80, 60, 40],
            pupilInches = 7 / 25.4, // keep it all in inches - could just as well use mm
            objectSizeArcmin1 = 60,
            objectSizeArcmin2 = 30,
            expectedApertures = [27.56, 22.05, 16.54, 11.02],
            expectedAperture,
            expectedLuminances = [759.50, 486.08, 273.42, 121.52],
            expectedLuminance,
            result = calcApertureFromEyepieceApparentFOVdegs_Pupil_ObjectApparentSize(eyepieceApparentFOVdegs, pupilInches, objectSizeArcmin1, objectSizeArcmin2),
            resultFOV,
            resultAperture,
            resultLuminance;

        expectedApertures.forEach(function (e, ix) {
            resultFOV = result[ix]['apparentFOVdegs'];
            resultAperture = result[ix]['aperture'];
            resultLuminance = result[ix]['luminance'];
            expectedAperture = expectedApertures[ix];
            expectedLuminance = expectedLuminances[ix];
            equal(withinRange(resultAperture, expectedAperture, 0.01), true, 'for ' + resultFOV + ' field of view in degrees, aperture should be ' + expectedAperture + ', is ' + resultAperture);
            equal(withinRange(resultLuminance, expectedLuminance, 0.01), true, '... and luminance should be ' + expectedLuminance + ' in^2deg^2, is ' + resultLuminance);
        });
    });

    QUnit.test('calcComa', function () {
        var eyepieceFieldStopmm = 6.85,
            focalRatio = 6.85,
            expected = {
                lowOrderComaRMS: 0.07, // per Nils Olaf's example
                linearComaRMS: 0.22
            },
            allowableError = 0.01,
            result = calcComa(eyepieceFieldStopmm, focalRatio);

        equal(withinRange(result.lowOrderComaRMS, expected.lowOrderComaRMS, allowableError), true, 'lowOrderComaRMS should be ' + expected.lowOrderComaRMS + ', is ' + result.lowOrderComaRMS);
        equal(withinRange(result.linearComaRMS, expected.linearComaRMS, allowableError), true, 'linearComaRMS should be ' + expected.linearComaRMS + ', is ' + result.linearComaRMS);
    });

    QUnit.test('calcGreaterComa', function () {
        var eyepieceFieldStopmm = 3,
            focalRatio = 6,
            expected = 0.13,
            allowableError = 0.01,
            result = calcGreaterComa(eyepieceFieldStopmm, focalRatio);

        // selects for linearComaRMS
        equal(withinRange(result, expected, allowableError), true, 'greatest coma should be ' + expected + ', is ' + result);

        // selects for lowOrderComaRMS
        eyepieceFieldStopmm = 20,
        focalRatio = 2,
        expected = 8.38,
        result = calcGreaterComa(eyepieceFieldStopmm, focalRatio);
        equal(withinRange(result, expected, allowableError), true, 'greatest coma should be ' + expected + ', is ' + result);
    });

    QUnit.test('calcGreaterComaWithComaCorrector', function () {
        var eyepieceFieldStopmm = 20,
            focalRatio = 3,
            useComaCorrector = false,
            expected = 3.33,
            allowableError = 0.01,
            result = calcGreaterComaWithComaCorrector(eyepieceFieldStopmm, focalRatio, useComaCorrector);

        equal(withinRange(result, expected, allowableError), true, 'coma without coma corrector should be ' + expected + ', is ' + result);

        useComaCorrector = true;
        expected = 0.21,
        result = calcGreaterComaWithComaCorrector(eyepieceFieldStopmm, focalRatio, useComaCorrector);
        equal(withinRange(result, expected, allowableError), true, 'coma with coma corrector should be ' + expected + ', is ' + result);
    });

    QUnit.test('calcCollimationToleranceInches', function () {
        var focalRatio = 4,
            expected = 0.0448,
            allowableError = 0.001,
            result = calcCollimationToleranceInches(focalRatio);

        equal(withinRange(result, expected, allowableError), true, 'collimation tolerance should be ' + expected + ', is ' + result);
    });

    QUnit.test('calcMinimumMirrorSupportPoints', function () {
        var aperture = 16,
            expected = 6,
            result = calcMinimumMirrorSupportPoints(aperture);

        equal(result, expected, result + ' should be ' + expected);

        aperture = 30;
        expected = 27;
        result = calcMinimumMirrorSupportPoints(aperture);
        equal(result, expected, result + ' should be ' + expected);

        aperture = 8;
        expected = 3;
        result = calcMinimumMirrorSupportPoints(aperture);
        equal(result, expected, result + ' should be ' + expected);

        aperture = 60;
        expected = undefined;
        result = calcMinimumMirrorSupportPoints(aperture);
        equal(result, expected, result + ' should be ' + expected);
    });

    QUnit.test('calcMirrorCellDimensions', function () {
        // 3 pt
        var aperture = 6,
            expected = {
                radius: 1.2
            },
            allowableError = 0.01,
            result = calcMirrorCellDimensions(3, aperture / 2);

        equal(withinRange(result.radius, expected.radius, allowableError), true, '3 pt mirror cell radius should be ' + expected.radius + ', is ' + result.radius);

        // 6 pt
        aperture = 12;
        expected = {
            radius: 3.42,
            balanceRadius: 2.962
        };
        result = calcMirrorCellDimensions(6, aperture / 2);
        equal(withinRange(result.radius, expected.radius, allowableError), true, '6 pt mirror cell radius should be ' + expected.radius + ', is ' + result.radius);
        equal(withinRange(result.balanceRadius, expected.balanceRadius, allowableError), true, '6 pt mirror cell balance radius should be ' + expected.balanceRadius + ', is ' + result.balanceRadius);

        // 9 pt
        aperture = 18;
        expected = {
            innerRadius: 2.97,
            outerRadius: 6.48,
            balanceRadius: 4.731
        };
        result = calcMirrorCellDimensions(9, aperture / 2);
        equal(withinRange(result.innerRadius, expected.innerRadius, allowableError), true, '9 pt mirror cell inner radius should be ' + expected.innerRadius + ', is ' + result.innerRadius);
        equal(withinRange(result.outerRadius, expected.outerRadius, allowableError), true, '9 pt mirror cell outer radius should be ' + expected.outerRadius + ', is ' + result.outerRadius);
        equal(withinRange(result.balanceRadius, expected.balanceRadius, allowableError), true, '9 pt mirror cell balance radius should be ' + expected.balanceRadius + ', is ' + result.balanceRadius);

        // 12 pt
        aperture = 20;
        expected = {
            innerRadius: 1.9,
            outerRadius: 7.2,
            collimationRadius: 5.3,
            innerBarLength: 5.5,
            midBarLength: 6.4,
            outerBarLength: 4.9,
            innerBarBalance: 3.52,
            midBarBalance: 3.584,
            outerBarBalance: 2.45
        };
        result = calcMirrorCellDimensions(12, aperture / 2);
        equal(withinRange(result.innerRadius, expected.innerRadius, allowableError), true, '12 pt mirror cell inner radius should be ' + expected.innerRadius + ', is ' + result.innerRadius);
        equal(withinRange(result.outerRadius, expected.outerRadius, allowableError), true, '12 pt mirror cell outer radius should be ' + expected.outerRadius + ', is ' + result.outerRadius);
        equal(withinRange(result.collimationRadius, expected.collimationRadius, allowableError), true, '12 pt mirror cell collimation radius should be ' + expected.collimationRadius + ', is ' + result.collimationRadius);
        equal(withinRange(result.innerBarLength, expected.innerBarLength, allowableError), true, '12 pt mirror cell innerBarLength should be ' + expected.innerBarLength + ', is ' + result.innerBarLength);
        equal(withinRange(result.midBarLength, expected.midBarLength, allowableError), true, '12 pt mirror cell midBarLength should be ' + expected.midBarLength + ', is ' + result.midBarLength);
        equal(withinRange(result.outerBarLength, expected.outerBarLength, allowableError), true, '12 pt mirror cell outerBarLength should be ' + expected.outerBarLength + ', is ' + result.outerBarLength);
        equal(withinRange(result.innerBarBalance, expected.innerBarBalance, allowableError), true, '12 pt mirror cell innerBarBalance should be ' + expected.innerBarBalance + ', is ' + result.innerBarBalance);
        equal(withinRange(result.midBarBalance, expected.midBarBalance, allowableError), true, '12 pt mirror cell midBarBalance should be ' + expected.midBarBalance + ', is ' + result.midBarBalance);
        equal(withinRange(result.outerBarBalance, expected.outerBarBalance, allowableError), true, '12 pt mirror cell outerBarBalance should be ' + expected.outerBarBalance + ', is ' + result.outerBarBalance);

        // 18 pt
        aperture = 24;
        expected = {
            innerRadius: 4.56,
            outerRadius: 9.12,
            triangleBalanceRadius: 7.393,
            pivotBarBalanceRadius: 6.403
        };
        result = calcMirrorCellDimensions(18, aperture / 2);
        equal(withinRange(result.innerRadius, expected.innerRadius, allowableError), true, '18 pt mirror cell inner radius should be ' + expected.innerRadius + ', is ' + result.innerRadius);
        equal(withinRange(result.outerRadius, expected.outerRadius, allowableError), true, '18 pt mirror cell outer radius should be ' + expected.outerRadius + ', is ' + result.outerRadius);
        equal(withinRange(result.triangleBalanceRadius, expected.triangleBalanceRadius, allowableError), true, '18 pt mirror cell triangle balance radius should be ' + expected.triangleBalanceRadius + ', is ' + result.triangleBalanceRadius);
        equal(withinRange(result.pivotBarBalanceRadius, expected.pivotBarBalanceRadius, allowableError), true, '18 pt mirror cell pivot bar balance radius should be ' + expected.pivotBarBalanceRadius + ', is ' + result.pivotBarBalanceRadius);

        // 27 pt
        aperture = 30;
        expected = {
            inner6Radius: 4.96,
            mid9Radius: 9.65,
            outer12Radius: 12.74,
            baseTriangleBalanceRadius: 8.43,
            innerTriangleBalanceRadius: 6.06,
            outerTriangleBalanceRadius: 11.41,
            outerTriangleBalancePtAngles2: 87 * uom.degToRad
        };
        result = calcMirrorCellDimensions(27, aperture / 2);
        equal(withinRange(result.inner6Radius, expected.inner6Radius, allowableError), true, '27 pt mirror cell inner 6 radius should be ' + expected.inner6Radius + ', is ' + result.inner6Radius);
        equal(withinRange(result.mid9Radius, expected.mid9Radius, allowableError), true, '27 pt mirror cell mid 9 radius should be ' + expected.mid9Radius + ', is ' + result.mid9Radius);
        equal(withinRange(result.outer12Radius, expected.outer12Radius, allowableError), true, '27 pt mirror cell outer radius should be ' + expected.outer12Radius + ', is ' + result.outer12Radius);
        equal(withinRange(result.baseTriangleBalanceRadius, expected.baseTriangleBalanceRadius, allowableError), true, '27 pt mirror cell base triangle balance radius should be ' + expected.baseTriangleBalanceRadius + ', is ' + result.baseTriangleBalanceRadius);
        equal(withinRange(result.innerTriangleBalanceRadius, expected.innerTriangleBalanceRadius, allowableError), true, '27 pt mirror cell inner triangle balance radius should be ' + expected.innerTriangleBalanceRadius + ', is ' + result.innerTriangleBalanceRadius);
        equal(withinRange(result.outerTriangleBalanceRadius, expected.outerTriangleBalanceRadius, allowableError), true, '27 pt mirror cell outer triangle balance radius should be ' + expected.outerTriangleBalanceRadius + ', is ' + result.outerTriangleBalanceRadius);
        equal(withinRange(result.outerTriangleBalancePtAngles[1], expected.outerTriangleBalancePtAngles2, allowableError), true, '27 pt mirror cell outer triangle balance #2 point angle should be ' + expected.outerTriangleBalancePtAngles2 + ', is ' + result.outerTriangleBalancePtAngles[1]);

        // other
        aperture = 1000;
        expected = undefined;
        result = calcMirrorCellDimensions(54, aperture / 2);
        equal(result, expected, result + ' should result in an undefined cell: ' + expected);
    });

    QUnit.test('calcRMSCausedByCentralObstruction', function () {
        var centralObstructionByDiameter = 1 / 3,
            expected = 0.07,
            allowableError = 0.1,
            result = calcRMSCausedByCentralObstruction(centralObstructionByDiameter);

        equal(withinRange(result, expected, allowableError), true, 'RMS deformation should be ' + expected + ', is ' + result);
    });

    QUnit.test('findWeightedCenterOfPoints', function () {
        var points = [{x: 1, y: 0}, {x: 2, y: 4}, {x: 3, y: 5}],
            expected = {
                x: 2,
                y: 3
            },
            allowableError = 0.00001,
            result = findWeightedCenterOfPoints(points);

        equal(withinRange(result.x, expected.x, allowableError), true, 'weighted x should be ' + expected.x + ', is ' + result.x);
        equal(withinRange(result.y, expected.y, allowableError), true, 'weighted y should be ' + expected.y + ', is ' + result.y);
    });

    QUnit.test('findOffsetCenterBetweenTwoPoints', function () {
        var point = MLB.sharedLib.point,
            pointA = point(4, 10),
            pointB = point(12, 20),
            offset = 0.5,
            expected = {
                x: 8,
                y: 15
            },
            allowableError = 0.00001,
            result = findOffsetCenterBetweenTwoPoints(pointA, pointB, offset);

        equal(withinRange(result.x, expected.x, allowableError), true, 'offset x should be ' + expected.x + ', is ' + result.x);
        equal(withinRange(result.y, expected.y, allowableError), true, 'offset y should be ' + expected.y + ', is ' + result.y);

        // reverse the points
        pointA = point(12, 20),
        pointB = point(4, 10),
        offset = 0.5,
        expected = {
            x: 8,
            y: 15
        },
        allowableError = 0.00001,
        result = findOffsetCenterBetweenTwoPoints(pointA, pointB, offset);

        equal(withinRange(result.x, expected.x, allowableError), true, 'offset x should be ' + expected.x + ', is ' + result.x);
        equal(withinRange(result.y, expected.y, allowableError), true, 'offset y should be ' + expected.y + ', is ' + result.y);

        // offset 80% of the way towards pointB
        pointA = point(4, 10),
        pointB = point(12, 20),
        offset = 0.8,
        expected = {
            x: 10.4,
            y: 18
        },
        allowableError = 0.00001,
        result = findOffsetCenterBetweenTwoPoints(pointA, pointB, offset);

        equal(withinRange(result.x, expected.x, allowableError), true, 'offset x should be ' + expected.x + ', is ' + result.x);
        equal(withinRange(result.y, expected.y, allowableError), true, 'offset y should be ' + expected.y + ', is ' + result.y);
    });

});

</script>
</html>