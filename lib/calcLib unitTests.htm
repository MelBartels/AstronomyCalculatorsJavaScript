<!DOCTYPE HTML>
<html>
<head>
	<title>QUnit test for calcLib.js</title>
	
	<!--
	<link rel='stylesheet' href='http://code.jquery.com/qunit/qunit-1.16.0.css' />
	<script src='http://code.jquery.com/jquery-1.11.0.min.js'></script>
	<script src='http://code.jquery.com/qunit/qunit-1.16.0.js'></script>

	<script>window.jQuery || document.write('<script src='local-source.js'><\/script>')</script>
	-->
	
	<link rel='stylesheet' href='qunit/qunit-1.16.0.css' />
	<script src='jquery/jquery-2.1.1.min.js'></script>
	<script src='qunit/qunit-1.16.0.js'></script>
	<script src='underscore/underscore-min.js'></script>

	<script src="sharedLib.js"></script>
	<script src="coordLib.js"></script>
	<script src="calcLib.js"></script>
</head>
<body>
	<div id="qunit"></div>
	<div id="qunit-fixture"></div>
</body>

<script>$(document).ready(function () {
	'use strict';
	var withinRange = MLB.sharedLib.withinRange,
	    uom = MLB.sharedLib.uom,
		calcSagitta = MLB.calcLib.calcSagitta,
		calcSagittaSpherical = MLB.calcLib.calcSagittaSpherical,
		calcFocalRatio = MLB.calcLib.calcFocalRatio,
		calcFocalRatioFromSphericalSagitta = MLB.calcLib.calcFocalRatioFromSphericalSagitta,
		calcSagittalVolume = MLB.calcLib.calcSagittalVolume,
		calcOffAxisIllumination = MLB.calcLib.calcOffAxisIllumination,
		magnitudeDrop = MLB.calcLib.magnitudeDrop,
		magnitudeDifferenceBetweenApertures = MLB.calcLib.magnitudeDifferenceBetweenApertures,
		inverseMagnitudeDrop = MLB.calcLib.inverseMagnitudeDrop,
		diagObstructionArea = MLB.calcLib.diagObstructionArea,
		calcDiagOffset = MLB.calcLib.calcDiagOffset,
		calcDiagOffset2 = MLB.calcLib.calcDiagOffset2,
		getDiagIllumArray = MLB.calcLib.getDiagIllumArray,
	    getFoldedNewtonianScalingFactor = MLB.calcLib.getFoldedNewtonianScalingFactor,
		calcFoldedNewtonian = MLB.calcLib.calcFoldedNewtonian,
		limitingMagnitude = MLB.calcLib.limitingMagnitude,
		VisualDetectCalcParms = MLB.calcLib.VisualDetectCalcParms,
		visualDetectCalcData = MLB.calcLib.visualDetectCalcData,
	    VisualDetectCalc = MLB.calcLib.VisualDetectCalc,
		VisualDetectCalcExitPupils = MLB.calcLib.VisualDetectCalcExitPupils,
		VisualDetectCalcApertures = MLB.calcLib.VisualDetectCalcApertures,
		calcNewtBaffle = MLB.calcLib.calcNewtBaffle,
		createAltazConstantMotionTrackingErrors = MLB.calcLib.createAltazConstantMotionTrackingErrors,
		calcMirrorSlumpingParms = MLB.calcLib.calcMirrorSlumpingParms,
		calcSphereParabolaDifference = MLB.calcLib.calcSphereParabolaDifference,
		wavefrontError = MLB.calcLib.wavefrontError,
		findAllowableCorrection = MLB.calcLib.findAllowableCorrection,
		calcAllowableParabolicDeviationForQuarterWavefront = MLB.calcLib.calcAllowableParabolicDeviationForQuarterWavefront,
		calcDobFriction = MLB.calcLib.calcDobFriction,
		SQMtoNELMconverter = MLB.calcLib.SQMtoNELMconverter,
		NELMtoSQMconverter = MLB.calcLib.NELMtoSQMconverter,
		artificialStarDistanceMM = MLB.calcLib.artificialStarDistanceMM,
		artificialStarDistanceInches = MLB.calcLib.artificialStarDistanceInches,
		calcApertureFromFOV_EyepieceFL_EyepieceFieldStop_EyePupil = MLB.calcLib.calcApertureFromFOV_EyepieceFL_EyepieceFieldStop_EyePupil,
		calcFOVFromAperture_EyepieceFL_EyepieceFieldStop_EyePupil = MLB.calcLib.calcFOVFromAperture_EyepieceFL_EyepieceFieldStop_EyePupil,
		calcEyePupilFromAperture_FOV_EyepieceFL_EyepieceFieldStop = MLB.calcLib.calcEyePupilFromAperture_FOV_EyepieceFL_EyepieceFieldStop,
		calcEyepieceFieldStopFromAperture_FOV_EyepieceFL_EyePupil = MLB.calcLib.calcEyepieceFieldStopFromAperture_FOV_EyepieceFL_EyePupil,
		calcEyepieceFLFromAperture_FOV_EyepieceFieldStop_EyePupil = MLB.calcLib.calcEyepieceFLFromAperture_FOV_EyepieceFieldStop_EyePupil;

	QUnit.module('sagitta');

	QUnit.test('calcSagitta', function () {
		var result = calcSagitta(13, 3);
		equal(withinRange(result, 0.271305, 0.000001), true, 'The sagitta should be 0.271305, is ' + result);
	});

	QUnit.test('calcFocalRatio', function () {
		var result = calcFocalRatio(13, 0.2713051698409146);
		equal(withinRange(result, 3, 0.000001), true, 'The focal ratio should be 3.0, is ' + result);
	});
	
	QUnit.test('calcSagittaSpherical', function () {
		var mirrorDia = 30,
		    focalRatio = 0.25,
			expectedSphericalSagitta = 7.5,
			result = calcSagittaSpherical(mirrorDia, focalRatio);
		equal(result, expectedSphericalSagitta, 'sagitta is ' + result);
	});

	QUnit.test('calcFocalRatioFromSphericalSagitta', function () {
		var result = calcFocalRatioFromSphericalSagitta(30, 7.5);
		equal(withinRange(result, 0.25, 0.000001), true, 'The focal ratio should be 0.25, is ' + result);
	});
	
	// http://www.1728.org/sphere.htm and http://www.had2know.com/academics/spherical-cap-volume-surface-area-calculator.html
	QUnit.test('calcSagittalVolume', function () {
		var expected = 6.1439,
		    result = calcSagittalVolume(10, 4);
		equal(withinRange(result, expected, 0.0001), true, 'The sagittal volume should be ' + expected + ', is ' + result);

		expected = 56287;
		result = calcSagittalVolume(70, 37 / 70 / 2);
		equal(withinRange(result, expected, 1), true, 'The sagittal volume should be ' + expected + ', is ' + result);
	});
	
	
	
	QUnit.module('diagonal sizing');

	QUnit.test('calcOffAxisIllumination', function () {
		var result = calcOffAxisIllumination(13.2, 40.3, 3.1, 9, 0.5);
		equal(withinRange(result, 0.878, 0.001), true, 'The off-axis illumination should be .878, is ' + result);

		result = calcOffAxisIllumination(13.2, 40.3, 3.1, 9, 0.1);
		equal(withinRange(result, 0.999, 0.001), true, 'The off-axis illumination should be .999, is ' + result);

		result = calcOffAxisIllumination(13.2, 40.3, 3.1, 9, 0);
		equal(withinRange(result, 1.0, 0.001), true, 'The off-axis illumination should be 1.0, is ' + result);

		result = calcOffAxisIllumination(13.2, 40.3, 3.5, 9, 0.5);
		equal(withinRange(result, 0.973, 0.001), true, 'The off-axis illumination should be .973, is ' + result);

		result = calcOffAxisIllumination(13.2, 40.3, 3.5, 9, 0.1);
		equal(withinRange(result, 1.0, 0.001), true, 'The off-axis illumination should be 1.0, is ' + result);

		result = calcOffAxisIllumination(13.2, 40.3, 3.5, 9, 0);
		equal(withinRange(result, 1.0, 0.001), true, 'The off-axis illumination should be 1.0, is ' + result);
	});

	QUnit.test('magnitudeDrop', function () {
		var result = magnitudeDrop(0.878011030887435);
		equal(withinRange(result, 0.141, 0.001), true, 'The magnitude drop should be 0.141, is ' + result);
	});

	QUnit.test('magnitudeDrop', function () {
		var result = magnitudeDrop(0.71);
		equal(withinRange(result, 0.37, 0.01), true, 'The magnitude drop should be 0.37, is ' + result);
	});

	QUnit.test('magnitudeDrop as a percentage', function () {
		var result = magnitudeDrop(0.96);
		equal(withinRange(result, 0.04, 0.01), true, 'The magnitude drop should be 0.04, is ' + result);
	});

	QUnit.test('magnitudeDrop as a percentage', function () {
		var result = magnitudeDrop(1.04);
		equal(withinRange(result, -0.04, 0.01), true, 'The magnitude drop should be -0.04, is ' + result);
	});

	QUnit.test('magnitudeDifferenceBetweenApertures', function () {
		var result = magnitudeDifferenceBetweenApertures(10, 20);
		equal(withinRange(result, -1.5, 0.01), true, 'The difference in magnitude between apertures of 10 and 20 should be -1.5, is ' + result);
	});
	
	QUnit.test('inverseMagnitudeDrop', function () {
		var result = inverseMagnitudeDrop(0.37);
		equal(withinRange(result, 0.71, 0.01), true, 'The inverse magnitude drop should be .71, is ' + result);
	});

	QUnit.test('diagObstructionArea', function () {
		var result = diagObstructionArea(10, 1);
		equal(withinRange(result, 0.01, 0), true, 'The diagonal obstruction should be 0.01, is ' + result);
	});

	QUnit.test('calcDiagOffset', function () {
		var result = calcDiagOffset(42, 121.8, 10, 28);
		equal(withinRange(result, 0.85, 0.01), true, 'The diagonal offset should be -.85, is ' + result);
	});

	QUnit.test('calcDiagOffset', function () {
		var result = calcDiagOffset(13.2, 40.3, 3.1, 9);
		equal(withinRange(result, 0.25, 0.01), true, 'The diagonal offset should be .25, is ' + result);
	});

	QUnit.test('calcDiagOffset2', function () {
		var result = calcDiagOffset2(13.2, 40.3, 3.1, 9);
		equal(withinRange(result, -0.26, 0.01), true, 'The diagonal offset should be -.26, is ' + result);
	});

	/* eg, 
	-0.7000000000000001,0.8109570241529027
	-0.6000000000000001,0.8444947700225293,
	-0.5,0.878011030887435,
	-0.4,0.9113610077701036,
	-0.30000000000000004,0.9442331974332544,
	-0.2,0.9757007976643087,
	-0.1,0.9999028396353284,
	0,1,
	0.1,0.9999028396353284,
	0.2,0.9757007976643087,
	0.30000000000000004,0.9442331974332544,
	0.4,0.9113610077701036,
	0.5,0.878011030887435,
	0.6000000000000001,0.8444947700225293,
	0.7000000000000001,0.8109570241529027 
	*/
	QUnit.test('getDiagIllumArray', function () {
		var result = getDiagIllumArray(13.2, 40.3, 3.1, 9, 0.1, 1.38);
		equal(result.length, 15, 'the array length should be 15, is ' + result.length + '; the array is ' + result);
		equal(withinRange(result[1][1], 0.844, 0.001), true, 'The off-axis illumination should be 0.844, is ' + result[1][1]);
		equal(withinRange(result[13][1], 0.844, 0.001), true, 'The off-axis illumination should be 0.844, is ' + result[13][1]);

		result = getDiagIllumArray(13.2, 40.3, 3.5, 9, 0.1, 1.38);
		equal(result.length, 15, 'the array length should be 15, is ' + result.length + '; the array is ' + result);
		equal(withinRange(result[1][1], 0.945, 0.001), true, 'The off-axis illumination should be 0.945, is ' + result[1][1]);
		equal(withinRange(result[13][1], 0.945, 0.001), true, 'The off-axis illumination should be 0.945, is ' + result[13][1]);
	});

	QUnit.module('foldedNewtonian.js');

	// example: mirror = 30, focal ratio = 3, diag = 8, tertiary distance = 2, eyepiece to mirror = 50, diag to mirror = 66
	// therefore maxWidth = diag to mirror = 66, 
	// maxHeight = (diag * focal ratio + tertiary) * 2 = (8*3 + 2)*2 = 52 (primary axis is centered),
	// model width to height = 66/52 = 1.2692308,
	// graphics width = 200, height = 100,
	// graphics width to height = 200/100 = 2,
	// fit model into graphics:
	// if model's width/height > graphics width/height, then model wider than display, else display wider than model,
	// if model w/h > graphics w/h then scale by width: model width / display width, else scale by height: model height / display height,
	// eg, if model w/h = 1.2692308 and display w/h = 2, then display wider than model, given same height,
	// given model w = 66, h = 52 and graphics w = 200, h = 100:
	// therefore scale by height: graphics height of 100 / model height of 52 = scaling factor of 1.9230769,
	// otherwise would scale by width: graphics width of 200 / model width of 66 = scaling factor of 3.030303,
	// using scaling factor of 1.9230769, width = 1.9230769 * 66 = 126.92308, height = 1.9230769 * 52 = 100:
	// so some display width wasted since the narrower model has to fit within;
	// returned scalingFactor made smaller by a margin, eg if scaling factor is 1.9230769 then returned value is 1.53846152;
	// this test ignores tertiaryOffsetFromEdgeOfPrimary;
	QUnit.test('getFoldedNewtonianScalingFactor', function () {
		var result = getFoldedNewtonianScalingFactor(200, 100, 3, 8, 2, 0, 66);
		equal(withinRange(result, 1.538461, 0.000001), true, 'scalingFactor should be 1.538461, is ' + result);
	});	
	
	QUnit.module('folded Newtonian');

	// function call is calcFoldedNewtonian(mirrorDia, focalRatio, diagSize, focalPlaneToTertiaryDistance, tertiaryOffsetFromEdgeOfPrimary)
	QUnit.test('calcFoldedNewtonian', function () {
		var result = calcFoldedNewtonian(30, 2.9, 7, 3, 0);
		equal(result.diagTooSmall, false, 'The diagTooSmall should be false, is ' + result.diagTooSmall);
		equal(result.diagTooLarge, false, 'The diagTooLarge should be false, is ' + result.diagTooLarge);
		equal(withinRange(result.diagToMirrorDistance, 63.7, 0.01), true, 'The diagToMirrorDistance should be 66.7, is ' + result.diagToMirrorDistance);
		equal(withinRange(result.eyepieceToMirrorDistance, 55.08, 0.01), true, 'The eyepieceToMirrorDistance should be 55.08, is ' + result.eyepieceToMirrorDistance);
		equal(withinRange(result.elbowAngleDeg, 60.12, 0.01), true, 'The elbowAngleDeg should be 60.12, is ' + result.elbowAngleDeg);
		equal(withinRange(result.diagMajorAxisSize, 8.09, 0.01), true, 'The diagMajorAxisSize should be 8.09, is ' + result.diagMajorAxisSize);
	});

	QUnit.test('calcFoldedNewtonian diagTooSmall error', function () {
		var result = calcFoldedNewtonian(30, 2.9, 6, 3, 0);
		equal(result.diagTooSmall, true, 'The diagTooSmall should be true, is ' + result.diagTooSmall);
	});

	QUnit.test('calcFoldedNewtonian diagTooLarge error', function () {
		var result = calcFoldedNewtonian(30, 2.9, 16, 3, 0);
		equal(result.diagTooLarge, true, 'The diagTooLarge should be true, is ' + result.diagTooLarge);
	});

	QUnit.test('calcFoldedNewtonian mirrorDia=0 et al error', function () {
		var result = calcFoldedNewtonian(0, 2.9, 6, 3, 0);
		equal(result, undefined, 'The result should be undefined, is ' + result);
	});

	// tertiaryOffsetFromEdgeOfPrimary tests
	QUnit.test('calcFoldedNewtonian diagTooSmall error', function () {
		var result = calcFoldedNewtonian(30, 3, 5, 0, 1),
		    expected = true;
		equal(result.diagTooSmall, expected, 'The diagTooSmall should be ' + expected + ', is ' + result.diagTooSmall);
	});

	QUnit.test('calcFoldedNewtonian diagTooSmall error', function () {
		var result = calcFoldedNewtonian(30, 3, 6, 0, 1),
		    expected = false;
		equal(result.diagTooSmall, expected, 'The diagTooSmall should be ' + expected + ', is ' + result.diagTooSmall);
	});

	QUnit.test('calcFoldedNewtonian diagToMirrorDistance and tertiaryOffsetFromEdgeOfPrimary', function () {
		var result = calcFoldedNewtonian(30, 3, 6, 0, 0),
		    expected = 72;
		equal(result.diagToMirrorDistance, expected, 'The diagToMirrorDistance with no tertiary offset should be ' + expected + ', is ' + result.diagToMirrorDistance);

		// tertiaryOffsetFromEdgeOfPrimary of 1 should shrink diagonal to mirror distance by 1
		result = calcFoldedNewtonian(30, 3, 6, 0, 1),
		    expected = 73;
		equal(result.diagToMirrorDistance, expected, 'The diagToMirrorDistance with tertiary offset of 1 should be ' + expected + ', is ' + result.diagToMirrorDistance);

		result = calcFoldedNewtonian(30, 3, 6, 0, -1),
		    expected = 71;
		equal(result.diagToMirrorDistance, expected, 'The diagToMirrorDistance with tertiary offset of -1 should be ' + expected + ', is ' + result.diagToMirrorDistance);
	});

	QUnit.module('visual detection calculator: parms and data');
	
	QUnit.test('limiting magnitude', function () {
		var apertureIn = 13;
		var expectedLimitingMag = 16.37;
		var result = limitingMagnitude(apertureIn);
		equal(withinRange(result, expectedLimitingMag, 0.01), true, 'limiting magnitude of ' + apertureIn +' should be ' + expectedLimitingMag + ', is ' + result);
	});
	
	QUnit.test('parms.apertureIn', function () {
		var parms, result, parms2, result2, originalResult;
		parms = new VisualDetectCalcParms();
		parms.apertureIn = 13.2;
		result = parms.apertureIn;
		equal(result, 13.2, 'apertureIn should be 13.2, is ' + result);
		
		parms2 = new VisualDetectCalcParms();
		parms2.apertureIn = 30;
		result2 = parms2.apertureIn;
		equal(result2, 30, 'copied apertureIn should be 30, is ' + result2);

		originalResult = parms.apertureIn;
		equal(originalResult, 13.2, 'original apertureIn should be 13.2, is ' + result);
	});

	QUnit.test('parms.apertureIn', function () {
		var parms, result, copiedParms, result2, originalResult;
		parms = new VisualDetectCalcParms();
		parms.apertureIn = 13.2;
		result = parms.apertureIn;
		equal(result, 13.2, 'apertureIn should be 13.2, is ' + result);
		
		copiedParms = parms.copyFrom();
		copiedParms.apertureIn = 30;
		result2 = copiedParms.apertureIn;
		equal(result2, 30, 'copied apertureIn should be 30, is ' + result2);

		originalResult = parms.apertureIn;
		equal(originalResult, 13.2, 'original apertureIn should be 13.2, is ' + result);
	});

	QUnit.test('visualDetectCalcData.logAngle[1]', function () {
		var data, result;
		data = visualDetectCalcData;
		result = data.logAngle[1];
		equal(result, 0.5563, 'logAngle[1] should be 0.5563, is ' + result);

		result = data.ltc[1][1];
		equal(result, -1.7747, 'ltc[1][1] should be -1.7747, is ' + result);
	});

	QUnit.module('visual detection calculator: the calculator');

	var visualDetectCalcParms = new VisualDetectCalcParms();
	visualDetectCalcParms.apertureIn = 13;
	visualDetectCalcParms.bkgndBrightEye = 21.5;
	visualDetectCalcParms.objName = 'California Nebula';
	visualDetectCalcParms.objMag = 5;
	visualDetectCalcParms.maxObjArcmin = 145;
	visualDetectCalcParms.minObjArcmin = 40;
	visualDetectCalcParms.eyepieceExitPupilmm = 6;
	visualDetectCalcParms.apparentFoV = 100;
	// can override defaults if desired
	//visualDetectCalcParms.eyeLimitMag = ;
	//visualDetectCalcParms.exitPupilmm = ;
	//visualDetectCalcParms.scopeTrans = ;
	//visualDetectCalcParms.singleEyeFactor = ;

	var visualDetectCalc = new VisualDetectCalc();
	            
	QUnit.test('visualDetectCalc.calc()', function () {
		var parms, result;
		parms = visualDetectCalcParms.copyFrom();
		result = visualDetectCalc.calc(parms);
		equal(withinRange(result.logContrastDiff, 0.81793677405235943, 0.000001), true, 'The logContrastDiff should be 0.81793677405235943, is ' + result.logContrastDiff);
		equal(withinRange(result.actualFoV, 1.81708055723804, 0.000001), true, 'The actualFoV should be 1.81708055723804, is ' + result.actualFoV);
		equal(result.fitsFoV, true, 'The object should  fit the field of view, is ' + result.fitsFoV);
		equal(result.detectable, true, 'The object should  be detectable, is ' + result.detectable);
	});
	
	QUnit.test('visualDetectCalc.calc()', function () {
		var parms, result;
		parms = visualDetectCalcParms.copyFrom();
		parms.eyepieceExitPupilmm = 4;
		result = visualDetectCalc.calc(parms);
		equal(withinRange(result.logContrastDiff, 0.848671579113636, 0.000001), true, 'The logContrastDiff should be 0.848671579113636, is ' + result.logContrastDiff);
		equal(withinRange(result.actualFoV, 1.21138703815869, 0.000001), true, 'The actualFoV should be 1.21138703815869, is ' + result.actualFoV);
		equal(result.fitsFoV, true, 'The object should  fit the field of view, is ' + result.fitsFoV);
		equal(result.detectable, true, 'The object should  be detectable, is ' + result.detectable);
	});	

	QUnit.test('NGC 134 example from Clarke\'s book', function () {
		var parms, result;
		parms = new VisualDetectCalcParms();
		parms.apertureIn = 8;
		parms.bkgndBrightEye = 24.25;
		parms.objName = 'NGC 134';
		parms.objMag = 11.4;
		parms.maxObjArcmin = 5;
		parms.minObjArcmin = 1;
		// for 187x per book
		parms.eyepieceExitPupilmm = 1.09;
		parms.apparentFoV = 60;
		// overriding defaults
		parms.exitPupilmm = 9;
		parms.scopeTrans = .7;
		parms.singleEyeFactor = 1;
		result = visualDetectCalc.calc(parms);
		equal(withinRange(result.logContrastDiff, 0.4, 0.1), true, 'The logContrastDiff should be 0.4, is ' + result.logContrastDiff);
	});
	
	QUnit.test('Sculptor System example from Clarke\'s book', function () {
		var parms, result;
		parms = new VisualDetectCalcParms();
		parms.apertureIn = 8;
		parms.bkgndBrightEye = 24.25;
		parms.objName = 'Sculptor System';
		parms.objMag = 8.8;
		parms.maxObjArcmin = 60;
		parms.minObjArcmin = 60;
		// for 27x per book
		parms.eyepieceExitPupilmm = 7.5;
		parms.apparentFoV = 60;
		// overriding defaults
		parms.exitPupilmm = 9;
		parms.scopeTrans = .7;
		parms.singleEyeFactor = 1;
		result = visualDetectCalc.calc(parms);
		/* book says 0.4 but this appears incorrect; 
		   book states that object with no telescope=26.3 and object in telescope at ODM is 24.5 (includes background!?), and background at magnification is 24.6:
		   this last value appears incorrect, either ignoring reduction due to magnification or reduction due to scope transmission factor (both are approx 0.4), 
		   so correct value should be 24.25 - 0.4 - 0.4 = 25.05
		 ie
			input values:
			  aperture (in)                8
			  eye limiting magnitude       6
			  eye max exit pupil mm        9
			  sky background brightness    24.25
			  object name                  Sculptor System
			  object integrated magnitude  8.8
			  object dimensions arcmin     60 x 60
			  eyepiece apparent field deg  60
			calculated values:
			  magnification                27
			  minimum useful X             23
			  maximum useful X varies from 60 to 60
			  actual field deg             2.2145669291338583
			  object fits FoV?             true
			  faintest star                15.268405970862784
			  single eye mag reduction     0
			  scope xmit mag reduction     0.38725489996435797
			  brightness (mag/arcsec^2):
				object without telescope    26.319070773142013
				brightness reduction at X   0.395906230238124
				object in scope at X        27.102231903344496
				background in scope at X    25.033161130202483
				object+bkgnd in scope at X  24.495370025041154
			  log object contrast          -0.8276283092568051
			  log contrast required        -1.103609326833303
			  log contrast difference      0.27598101757649784
			  detectable?                  true
		*/
		equal(withinRange(result.logContrastDiff, 0.3, 0.1), true, 'The logContrastDiff should be 0.4, is ' + result.logContrastDiff);
	});
	
	QUnit.test('visualDetectCalc.calc()', function () {
		// compare to my previous C version based on Clark's Visual Astronomy calculates logContrastDiff = 0.51 
		// because exitPupilmm=6.5, exitPupilmm=9, scope transmission=.85 and missing single eye factor
		var parms, result;
		parms = new VisualDetectCalcParms();
		parms.apertureIn = 20;
		parms.bkgndBrightEye = 21;
		parms.objName = 'copy from earlier ODM unit test';
		parms.objMag = 12;
		parms.maxObjArcmin = 2;
		parms.minObjArcmin = 2;
		parms.eyepieceExitPupilmm = 7;
		parms.apparentFoV = 100;
		// overriding defaults
		parms.exitPupilmm = 9;
		parms.scopeTrans = .85;
		parms.singleEyeFactor = 1;
		result = visualDetectCalc.calc(parms);
		equal(withinRange(result.logContrastDiff, 0.51, 0.01), true, 'The logContrastDiff should be 0.51, is ' + result.logContrastDiff);
	});
	
	QUnit.test('visualDetectCalc.fitsFoV', function () {
		var parms, result;
		parms = visualDetectCalcParms.copyFrom();
		parms.eyepieceExitPupilmm = 1;
		result = visualDetectCalc.calc(parms);
		equal(result.fitsFoV, false, 'The object should not fit the field of view, is ' + result.fitsFoV);
	});	

	QUnit.test('visualDetectCalc.detectable', function () {
		var parms, result;
		parms = visualDetectCalcParms.copyFrom();
		parms.objMag = 10;
		result = visualDetectCalc.calc(parms);
		equal(result.detectable, false, 'The object should not be detectable, is ' + result.detectable);
	});	

	/*
	input values:
	  aperture (in)                13
	  eye limiting magnitude       6
	  eye max exit pupil mm        7
	  sky background brightness    21.5
	  object name                  California Nebula
	  object integrated magnitude  5
	  object dimensions arcmin     145 x 40
	  eyepiece apparent field deg  100
	calculated values:
	  magnification                55
	  minimum useful X             47
	  maximum useful X varies from 41 to 150
	  actual field deg             1.8170805572380375
	  object fits FoV?             true
	  faintest star                16.115820155402638
	  single eye mag reduction     0.7525749891599529
	  scope xmit mag reduction     0.24227503252014093
	  brightness (mag/arcsec^2):
		object without telescope   23.036884505131138
		brightness reduction at X  0.3347339481530661
		object in scope at X       24.366468474964293
		background in scope at X   22.82958396983316
		object+bkgnd in scope at X 21.598732050134025
	  log object contrast          -0.614753802052455
	  log contrast required        -1.4326905761048156
	  log contrast difference      0.8179367740523606
	  detectable?                  true
	*/
	QUnit.test('visualDetectCalc.includeResultAsString', function () {
		var parms, result;
		parms = visualDetectCalcParms.copyFrom();
		result = visualDetectCalc.includeResultAsString(visualDetectCalc.calc(parms)).text;
		equal(result.length > 0, true, 'result is ' + result);
	});
	
	var visualDetectCalcParms2 = new VisualDetectCalcParms();
	visualDetectCalcParms2.apertureIn = 13;
	visualDetectCalcParms2.bkgndBrightEye = 21.5;
	visualDetectCalcParms2.objName = 'Sombrero Galaxy';
	visualDetectCalcParms2.objMag = 8;
	visualDetectCalcParms2.maxObjArcmin = 9;
	visualDetectCalcParms2.minObjArcmin = 4;
	visualDetectCalcParms2.eyepieceExitPupilmm = 6;
	visualDetectCalcParms2.apparentFoV = 110;
	// can override defaults if desired
	//visualDetectCalcParms2.eyeLimitMag = ;
	//visualDetectCalcParms2.exitPupilmm = ;
	//visualDetectCalcParms2.scopeTrans = ;
	//visualDetectCalcParms2.singleEyeFactor = ;
	
	/*
	result is 
	input values: 
		aperture (in) 13 
		eye limiting magnitude 6 
		eye max exit pupil mm 7 
		sky background brightness 21.5 
		object name Sombrero Galaxy object 
		integrated magnitude 8 
		object dimensions arcmin 9 x 4 
		eyepiece apparent field deg 110 
	calculated values: 
		magnification 55 
		minimum useful X 47 
		maximum useful X varies from 330 to 330 
		actual field deg 1.9987886129618413 
		object fits FoV? true 
		faintest star 16.115820155402638 
		single eye mag reduction 0.7525749891599529 
		scope xmit mag reduction 0.24227503252014093 
		brightness (mag/arcsec^2): 
			object without telescope 20.519070773142015 
			brightness reduction at X 0.3347339481530661 
			object in scope at X 21.84865474297517 
			background in scope at X 22.82958396983316 
			object+bkgnd in scope at X 20.48448901600736 
		log object contrast 0.39237169074319383 
		log contrast required -0.966861934161181 
		log contrast difference 1.3592336249043748 
		detectable? true 
	*/	
	QUnit.test('visualDetectCalc.includeResultAsString, Sombrero Galaxy through 13 inch f3', function () {
		var parms, result;
		parms = visualDetectCalcParms2.copyFrom();
		result = visualDetectCalc.includeResultAsString(visualDetectCalc.calc(parms)).text;
		equal(result.length > 0, true, 'result is ' + result);
	});
	
	QUnit.module('visual detection calculator: eyepiece exit pupil sequence');
		
	QUnit.test('ExitPupilSequence', function () {
		var parms, result;
		parms = visualDetectCalcParms.copyFrom();
		result = new VisualDetectCalcExitPupils(parms);
		// 7mm exit pupil, per above test
		equal(result[6].parms.exitPupilmm, 7, 'The exitPupilmm should be 7, is ' + result[6].parms.exitPupilmm);
		equal(result[6].parms.eyepieceExitPupilmm, 7, 'The eyepieceExitPupilmm should be 7, is ' + result[6].parms.eyepieceExitPupilmm);
		equal(withinRange(result[6].logContrastDiff, 0.827429778789198, 0.000001), true, 'The logContrastDiff should be 0.827429778789198, is ' + result[6].logContrastDiff);
		equal(withinRange(result[6].actualFoV, 2.11992731677771, 0.000001), true, 'The actualFoV should be 2.11992731677771, is ' + result[6].actualFoV);
		// 4mm exit pupil
		equal(result[3].parms.exitPupilmm, 7, 'The exitPupilmm should be 7, is ' + result[3].parms.exitPupilmm);
		equal(result[3].parms.eyepieceExitPupilmm, 4, 'The eyepieceExitPupilmm should be 4, is ' + result[3].parms.eyepieceExitPupilmm);
		equal(withinRange(result[3].logContrastDiff, 0.848671579113636, 0.000001), true, 'The logContrastDiff should be 0.848671579113636, is ' + result[3].logContrastDiff);
		equal(withinRange(result[3].actualFoV, 1.21138703815869, 0.000001), true, 'The actualFoV should be 1.21138703815869, is ' + result[3].actualFoV);
		// 1mm exit pupil
		equal(result[0].parms.exitPupilmm, 7, 'The exitPupilmm should be 7, is ' + result[0].parms.exitPupilmm);
		equal(result[0].parms.eyepieceExitPupilmm, 1, 'The eyepieceExitPupilmm should be 1, is ' + result[0].parms.eyepieceExitPupilmm);
		equal(withinRange(result[0].logContrastDiff, 0.779495670342709, 0.000001), true, 'The logContrastDiff should be 0.779495670342709, is ' + result[0].logContrastDiff);
		equal(withinRange(result[0].actualFoV, 0.302846759539673, 0.000001), true, 'The actualFoV should be 0.302846759539673, is ' + result[0].actualFoV);
	});
	
	QUnit.module('visual detection calculator: aperture sequence');
		
	QUnit.test('VisualDetectCalcApertures', function () {
		var parms, result, halfAperture, dblAperture, halfApertureParms, halfApertureResults, dblApertureParms, dblApertureResults;
		parms = visualDetectCalcParms.copyFrom();
		result = new VisualDetectCalcApertures(parms);
		// 7mm exit pupil, per above test
		equal(result[1][6].parms.exitPupilmm, 7, 'The exitPupilmm should be 7, is ' + result[1][6].parms.exitPupilmm);
		equal(result[1][6].parms.eyepieceExitPupilmm, 7, 'The eyepieceExitPupilmm should be 7, is ' + result[1][6].parms.eyepieceExitPupilmm);
		equal(withinRange(result[1][6].logContrastDiff, 0.827429778789198, 0.000001), true, 'The logContrastDiff should be 0.827429778789198, is ' + result[1][6].logContrastDiff);
		equal(withinRange(result[1][6].actualFoV, 2.11992731677771, 0.000001), true, 'The actualFoV should be 2.11992731677771, is ' + result[1][6].actualFoV);
		// 4mm exit pupil
		equal(result[1][3].parms.exitPupilmm, 7, 'The exitPupilmm should be 7, is ' + result[1][3].parms.exitPupilmm);
		equal(result[1][3].parms.eyepieceExitPupilmm, 4, 'The eyepieceExitPupilmm should be 4, is ' + result[1][3].parms.eyepieceExitPupilmm);
		equal(withinRange(result[1][3].logContrastDiff, 0.848671579113636, 0.000001), true, 'The logContrastDiff should be 0.848671579113636, is ' + result[1][3].logContrastDiff);
		equal(withinRange(result[1][3].actualFoV, 1.21138703815869, 0.000001), true, 'The actualFoV should be 1.21138703815869, is ' + result[1][3].actualFoV);
		// 1mm exit pupil
		equal(result[1][0].parms.exitPupilmm, 7, 'The exitPupilmm should be 7, is ' + result[1][0].parms.exitPupilmm);
		equal(result[1][0].parms.eyepieceExitPupilmm, 1, 'The eyepieceExitPupilmm should be 1, is ' + result[1][0].parms.eyepieceExitPupilmm);
		equal(withinRange(result[1][0].logContrastDiff, 0.779495670342709, 0.000001), true, 'The logContrastDiff should be 0.779495670342709, is ' + result[1][0].logContrastDiff);
		equal(withinRange(result[1][0].actualFoV, 0.302846759539673, 0.000001), true, 'The actualFoV should be 0.302846759539673, is ' + result[1][0].actualFoV);
		
		// test apertures
		halfAperture = result[2][0].parms.apertureIn;
		equal(result[1][0].parms.apertureIn/2, halfAperture, 'The aperture should be half of ' + result[1][0].parms.apertureIn + ', is ' + halfAperture);
		dblAperture = result[0][0].parms.apertureIn;
		equal(result[1][0].parms.apertureIn*2, dblAperture, 'The aperture should be double of ' + result[1][0].parms.apertureIn + ', is ' + dblAperture);
		
		// test logContrasts, at exitPupilmm=6
		halfApertureParms = visualDetectCalcParms.copyFrom();
		halfApertureParms.apertureIn /= 2;
		halfApertureResults = visualDetectCalc.calc(halfApertureParms);
		equal(halfApertureResults.logContrastDiff, result[2][5].logContrastDiff, 'The log contrast should be ' + result[2][5].logContrastDiff + ', is ' + halfApertureResults.logContrastDiff);
		dblApertureParms = visualDetectCalcParms.copyFrom();
		dblApertureParms.apertureIn *= 2;
		dblApertureResults = visualDetectCalc.calc(dblApertureParms);
		equal(dblApertureResults.logContrastDiff, result[0][5].logContrastDiff, 'The log contrast should be ' + result[0][5].logContrastDiff + ', is ' + dblApertureResults.logContrastDiff);
	});
	
	QUnit.module('calcNewtBaffle');

	// test values verified by graph in baffle.html
	QUnit.test('calcNewtBaffle', function () {	
		var focalPlaneDia, focuserBarrelBottomToFocalPlaneDistance, focuserBarrelID, diagSizeMinorAxis, diagToFocalPlaneDistance, diagtoFocuserBaffleDistance, diagToOppositeSideBaffleDistance, primaryMirrorDia, primaryMirrorFocalLength, primaryToBaffleDistance, tubeID, results;
		focalPlaneDia = 1.4;
		focuserBarrelBottomToFocalPlaneDistance = 2.5;
		focuserBarrelID = 1.8;
		diagSizeMinorAxis = 3.1;
		diagToFocalPlaneDistance = 9;
		diagtoFocuserBaffleDistance = 6;
		diagToOppositeSideBaffleDistance = 7;
		primaryMirrorDia = 13.2;
		primaryMirrorFocalLength = 40.2;
		primaryToBaffleDistance = 4;
		tubeID = primaryMirrorDia + 2;
		results = calcNewtBaffle(focalPlaneDia, focuserBarrelBottomToFocalPlaneDistance, focuserBarrelID, diagSizeMinorAxis, diagToFocalPlaneDistance, diagtoFocuserBaffleDistance, diagToOppositeSideBaffleDistance, primaryMirrorFocalLength, primaryToBaffleDistance, tubeID);
		equal(withinRange(results.focuserBaffleID, 1.97, 0.01), true, 'The focuser baffle ID should be 1.97, is ' + results.focuserBaffleID);
		equal(withinRange(results.focuserBaffleOD, 2.44, 0.01), true, 'The focuser baffle ID should be 2.44, is ' + results.focuserBaffleOD);
		equal(withinRange(results.diagonalBaffleOD, 16.55, 0.01), true, 'The diagonal baffle OD should be 16.55, is ' + results.diagonalBaffleOD);
		equal(withinRange(results.primaryBaffleOD, 16.70, 0.01), true, 'The primary mirror baffle OD should be 16.70, is ' + results.primaryBaffleOD);
		equal(withinRange(results.tubeExtension, 7, 0.01), true, 'The tube extension beyond the primary mirror to act as primary baffle should be 7, is ' + results.tubeExtension);		
	});
	
	QUnit.module('createAltazConstantMotionTrackingErrors');
	
	QUnit.test('data return', function () {
		var latitudeRad = 40 * uom.degToRad, 
		    constantTrackRateTimeRad = 300 * uom.secToRad, 
			spacingDeg = 2,
			expected = 18.969,
			data = createAltazConstantMotionTrackingErrors(latitudeRad, constantTrackRateTimeRad, spacingDeg),
			results = data[5][2] / uom.arcsecToRad;

		equal(withinRange(results, expected, 0.001), true, 'The constant track rate error over 5 minutes should be ' + expected + ', is ' + results);
	});
		
	QUnit.module('slumping');
	
	QUnit.test('sharply slumped: dia=30, FR=1', function () {
		var mirrorDia = 30,
			focalRatio = 1,
			expectedEffectiveEntranceAperture = 29.688475110542754,
			result = calcMirrorSlumpingParms(mirrorDia, focalRatio);
		equal(withinRange(result.effectiveDia, expectedEffectiveEntranceAperture, 0.000001), true, 'result = ' + result.effectiveDia);
	});
	
	QUnit.test('barely slumped: dia=30, FR=5', function () {
		var mirrorDia = 30,
			focalRatio = 5,
			expectedEffectiveEntranceAperture = 29.987501562406997,
			result = calcMirrorSlumpingParms(mirrorDia, focalRatio);
		equal(withinRange(result.effectiveDia, expectedEffectiveEntranceAperture, 0.000001), true, 'result = ' + result.effectiveDia);
	});
	
	QUnit.test('13" F3', function () {
		var mirrorDia = 13.2,
			focalRatio = 3,
			expectedEffectiveEntranceAperture = 13.18472752612914,
			expectedSphericalSagitta = 0.275,
			expectedEdgeAngleDeg = 4.775,
			result = calcMirrorSlumpingParms(mirrorDia, focalRatio);
		equal(withinRange(result.effectiveDia, expectedEffectiveEntranceAperture, 0.000001), true, 'result = ' + result.effectiveDia);
		equal(withinRange(result.sphericalSagitta, expectedSphericalSagitta, 0.001), true, 'result = ' + result.sphericalSagitta);	
		equal(withinRange(result.edgeAngleDeg, expectedEdgeAngleDeg, 0.001), true, 'result = ' + result.edgeAngleDeg);	
	});
	
	QUnit.test('42" F2.9', function () {
		var mirrorDia = 42,
			focalRatio = 2.9,
			expectedEffectiveEntranceAperture = 41.94799792367687,
			expectedSphericalSagitta = 0.905,
			expectedEdgeAngleDeg = 4.939,
			result = calcMirrorSlumpingParms(mirrorDia, focalRatio);
		equal(withinRange(result.effectiveDia, expectedEffectiveEntranceAperture, 0.000001), true, 'result = ' + result.effectiveDia);
		equal(withinRange(result.sphericalSagitta, expectedSphericalSagitta, 0.001), true, 'result = ' + result.sphericalSagitta);	
		equal(withinRange(result.edgeAngleDeg, expectedEdgeAngleDeg, 0.001), true, 'result = ' + result.edgeAngleDeg);	
	});
	
	QUnit.module('sphere to parabola difference');
	
	QUnit.test('6 inch F8', function () {
		var mirrorDia = 6,
			focalRatio = 8,
			expectedEffectiveEntranceAperture = 0.0000114,
			result = calcSphereParabolaDifference(mirrorDia, focalRatio);
		equal(withinRange(result, expectedEffectiveEntranceAperture, 0.0000001), true, 'result = ' + result);
	});	

	QUnit.module('ronchi');
		
	QUnit.test('wavefrontError', function () {
		var mirrorDia = 20,
			radiusOfCurvature = 200,
			correctionFactor = 0.86,			
			result = wavefrontError(mirrorDia, radiusOfCurvature, correctionFactor),
			expected = 0.5108704878136372;
		equal(result, expected, 'result = ' + result + ', should be ' + expected);		
	});
	
	// parabolic correction tolerances: focalRatio 1: 98.3%; focalRatio 2: 96.7%; focalRatio 3: 95%; focalRatio 4: 93.3%; focalRatio 5: 91.7%; focalRatio 6: 90%; focalRatio 7: 88.4%; focalRatio 8: 86.7%; focalRatio 9: 85%; focalRatio 10: 83.4%;
	QUnit.test('findAllowableCorrection, for a range of focal ratios from f/1 to f/10, mirror dia = 10', function () {
		var mirrorDia = 10,
		    focalRatio,
			results = [],
			ix,
			displayResults = 'parabolic correction tolerances: ',
			expected = 0.83359375;
			
		for (ix = 0; ix < 10; ix++) {
		    focalRatio = (ix + 1);
			results[ix] = findAllowableCorrection(mirrorDia, mirrorDia * focalRatio * 2);
			displayResults += 'focalRatio ' + focalRatio + ': ' + Math.round(results[ix] * 1000) / 10 + '%; ';
		}
		
		equal(results[9], expected, 'results[9] = ' + results[9] + ', should be ' + expected);	
	});
	
	// as above, but double the aperture to demonstrate that aperture has no bearing on allowable correction
	QUnit.test('findAllowableCorrection, for a range of focal ratios from f/1 to f/10, mirror dia = 20', function () {
		var mirrorDia = 20,
		    focalRatio,
			results = [],
			ix,
			displayResults = 'parabolic correction tolerances: ',
			expected = 0.83359375;
			
		for (ix = 0; ix < 10; ix++) {
		    focalRatio = (ix + 1);
			results[ix] = findAllowableCorrection(mirrorDia, mirrorDia * focalRatio * 2);
			displayResults += 'focalRatio ' + focalRatio + ': ' + Math.round(results[ix] * 1000) / 10 + '%; ';
		}
		
		equal(results[9], expected, 'results[9] = ' + results[9] + ', should be ' + expected);	
	});
	
	QUnit.test('calcAllowableParabolicDeviationForQuarterWavefront for f/10', function () {
		var focalRatio = 10,
		    expected = 0.16699999999999998,
			result = calcAllowableParabolicDeviationForQuarterWavefront(focalRatio);
		equal(result, expected, 'result = ' + result + ', should be ' + expected);	
	});

	QUnit.module('Dob friction of movement');
		
	/* 
	Dob friction, from Telescope Making #8, pg 36-, Richard Berry

	Alt: f*w*sec(ba)*r/l
	Az: f*w*r/(l*cos(ba))
	F=friction (Teflon on formica) =0.1
	W=weight (that the bearing is carrying)
	R=bearing radius
	Ba=bearing angle
	L=length of the moment arm
	
	Example 16 inch f5:
		AZ radius 9, weight 120 lbs, 45deg bearing angle, moment arm 40inches, f=0.083
		0.088*120*9/(cos(45)*40)=3.2
		ALT radius 4, weight 80 lbs, 60deg bearing angle, moment arm 40inches, f=0.088
		1.3*80*(1/cos(60))*4/40=2.1
	*/
	QUnit.test('az and alt friction', function () {
		var allowableError = 0.000000000000001,
		    azimuthFrictionCoefficient = 0.083,
		    altitudeFrictionCoefficient = 0.13,
			momentArm = 40,
			azWeight = 120,
			altWeight = 80,
			azBearingRadius = 9,
			altBearingRadius = 4,
			altBearingAngleDegFromVertical = 60,
			altitudeAngleDegFromHorizontal = 45,
			result = MLB.calcLib.calcDobFriction(azimuthFrictionCoefficient, altitudeFrictionCoefficient, momentArm, azWeight, altWeight, azBearingRadius, altBearingRadius, altBearingAngleDegFromVertical, altitudeAngleDegFromHorizontal),
			expected = [3.169252593278106, 2.08];

		equal(withinRange(result.az, expected[0], allowableError), true, 'az result = ' + result.az + ', should be ' + expected[0]);
		equal(withinRange(result.alt, expected[1], allowableError), true, 'alt result = ' + result.alt + ', should be ' + expected[1]);
	});
	
	QUnit.module('SQM to NELM converter');
	
	// from http://www.unihedron.com/projects/darksky/NELM2BCalc.html
	
	QUnit.test('SQMtoNELMconverter', function () {
		var expected,
		    result,
			allowableError = 0.0001;

		expected = 6;
		result = SQMtoNELMconverter(20.8);
		equal(withinRange(result, expected, allowableError), true, 'result = ' + result + ', should be ' + expected);
	});

	QUnit.test('NELMtoSQMconverter', function () {
		var expected,
		    result,
			allowableError = 0.0001;

		expected = 20.8;
		result = NELMtoSQMconverter(6);
		equal(withinRange(result, expected, allowableError), true, 'result = ' + result + ', should be ' + expected);
	});
	
	QUnit.module('artificialStarDistance');
	
	QUnit.test('artificialStarDistanceMM', function () {
		var expected,
		    result;
			
		expected = '8984';
		result = artificialStarDistanceMM(152, 912);
		equal(result, expected, result + ' should be ' + expected);
	});		

	QUnit.test('artificialStarDistanceInches', function () {
		var expected,
		    result;
			
		expected = '355';
		result = artificialStarDistanceInches(6, 36);
		equal(result, expected, result + ' should be ' + expected);
	});		

	QUnit.test('artificialStarDistanceInches', function () {
		var expected,
		    result;
			
		expected = '4495';
		result = artificialStarDistanceInches(16, 16 * 4.5);
		equal(result, expected, result + ' should be ' + expected);
	});		

	QUnit.module('aperture, FOV, eyepiece');
	
	var scopeTestParms = function () {
		this.apertureInches = 13.1,
		this.FOVdeg = 1.762, 
		this.eyepieceFocalLengthmm = 21, 
		this.eyepieceFieldStopmm = 36.2, 
		this.eyePupilmm = 5.936,
		this.expected = undefined,
		this.allowableError = 0.01
	};
	
	QUnit.test('calcApertureFromFOV_EyepieceFL_EyepieceFieldStop_EyePupil', function () {
		var parms = new scopeTestParms(),
		    expected = parms.apertureInches,
		    result;
			
		result = calcApertureFromFOV_EyepieceFL_EyepieceFieldStop_EyePupil(parms.FOVdeg, parms.eyepieceFocalLengthmm, parms.eyepieceFieldStopmm, parms.eyePupilmm);
		equal(withinRange(result, expected, parms.allowableError), true, 'result = ' + result + ', should be ' + expected);
	});		

	QUnit.test('calcFOVFromAperture_EyepieceFL_EyepieceFieldStop_EyePupil', function () {
		var parms = new scopeTestParms(),
		    expected = parms.FOVdeg,
		    result;
			
		result = calcFOVFromAperture_EyepieceFL_EyepieceFieldStop_EyePupil(parms.apertureInches, parms.eyepieceFocalLengthmm, parms.eyepieceFieldStopmm, parms.eyePupilmm);
		equal(withinRange(result, expected, parms.allowableError), true, 'result = ' + result + ', should be ' + expected);
	});		

	QUnit.test('calcEyePupilFromAperture_FOV_EyepieceFL_EyepieceFieldStop', function () {
		var parms = new scopeTestParms(),
		    expected = parms.eyePupilmm,
		    result;
			
		result = calcEyePupilFromAperture_FOV_EyepieceFL_EyepieceFieldStop(parms.apertureInches, parms.FOVdeg, parms.eyepieceFocalLengthmm, parms.eyepieceFieldStopmm);
		equal(withinRange(result, expected, parms.allowableError), true, 'result = ' + result + ', should be ' + expected);
	});		
	
	QUnit.test('calcEyepieceFieldStopFromAperture_FOV_EyepieceFL_EyePupil', function () {
		var parms = new scopeTestParms(),
		    expected = parms.eyepieceFieldStopmm,
		    result;
			
		result = calcEyepieceFieldStopFromAperture_FOV_EyepieceFL_EyePupil(parms.apertureInches, parms.FOVdeg, parms.eyepieceFocalLengthmm, parms.eyePupilmm);
		equal(withinRange(result, expected, parms.allowableError), true, 'result = ' + result + ', should be ' + expected);
	});		
	
	QUnit.test('calcEyepieceFLFromAperture_FOV_EyepieceFieldStop_EyePupil', function () {
		var parms = new scopeTestParms(),
		    expected = parms.eyepieceFocalLengthmm,
		    result;
			
		result = calcEyepieceFLFromAperture_FOV_EyepieceFieldStop_EyePupil(parms.apertureInches, parms.FOVdeg, parms.eyepieceFieldStopmm, parms.eyePupilmm);
		equal(withinRange(result, expected, parms.allowableError), true, 'result = ' + result + ', should be ' + expected);
	});		
	
});

</script>
</html>