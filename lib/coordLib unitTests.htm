<!DOCTYPE HTML>
<html>
<head>
	<title>QUnit test for coordLib.js</title>
	
	<!--
	<link rel='stylesheet' href='http://code.jquery.com/qunit/qunit-1.16.0.css' />
	<script src='http://code.jquery.com/jquery-1.11.0.min.js'></script>
	<script src='http://code.jquery.com/qunit/qunit-1.16.0.js'></script>
	<script src='http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.7.0/underscore-min.js'></script>
	
	<script>window.jQuery || document.write('<script src='local-source.js'><\/script>')</script>
	-->
	
	<link rel='stylesheet' href='qunit/qunit-1.16.0.css' />
	<script src='jquery/jquery-2.1.1.min.js'></script>
	<script src='qunit/qunit-1.16.0.js'></script>
	<script src='underscore/underscore-min.js'></script>

	<script src='sharedLib.js'></script>
	<script src='coordLib.js'></script>
</head>
<body>
	<div id="qunit"></div>
	<div id="qunit-fixture"></div>
</body>

<script>$(document).ready(function () {
	'use strict';
	var withinRange = MLB.sharedLib.withinRange,
	    uom = MLB.sharedLib.uom,
		mInt = MLB.sharedLib.int,
		validRev = MLB.coordLib.validRev,
		validHalfRev = MLB.coordLib.validHalfRev,
		validDec = MLB.coordLib.validDec,
		reverseRev = MLB.coordLib.reverseRev,
		calcDecIsFlipped = MLB.coordLib.calcDecIsFlipped,
		flipRa = MLB.coordLib.flipRa,
		flipDec = MLB.coordLib.flipDec,
		convertHMSMToRad = MLB.coordLib.convertHMSMToRad,
		convertDMSMToRad = MLB.coordLib.convertDMSMToRad,
		convertRadToHMSM = MLB.coordLib.convertRadToHMSM,
		convertRadToHMS = MLB.coordLib.convertRadToHMS,
		convertRadToDMSM = MLB.coordLib.convertRadToDMSM,
		convertRadToDMS = MLB.coordLib.convertRadToDMS,
		convertHMSMToString = MLB.coordLib.convertHMSMToString,
		convertDMSMToString = MLB.coordLib.convertDMSMToString,
		convertRadiansToHMSMString = MLB.coordLib.convertRadiansToHMSMString,
		convertRadiansToHMSString = MLB.coordLib.convertRadiansToHMSString,
		convertRadiansToDMSMString = MLB.coordLib.convertRadiansToDMSMString,
		dateFromString = MLB.coordLib.dateFromString,
		dateToString = MLB.coordLib.dateToString,
		getMonth = MLB.coordLib.getMonth,
		isLeapYear = MLB.coordLib.isLeapYear,
		calcDayOfTheYear = MLB.coordLib.calcDayOfTheYear,
		calcJulianYear = MLB.coordLib.calcJulianYear,
		calcJDFromJulianYear = MLB.coordLib.calcJDFromJulianYear,
		calcJD = MLB.coordLib.calcJD,
		calcDateFromJD = MLB.coordLib.calcDateFromJD,
		calcSidT = MLB.coordLib.calcSidT,
		calcProperMotion = MLB.coordLib.calcProperMotion,
		calcPrecessionQuick = MLB.coordLib.calcPrecessionQuick,
		calcPrecessionRigorous = MLB.coordLib.calcPrecessionRigorous,
		celestialParms = MLB.coordLib.celestialParms,
		calcNutation = MLB.coordLib.calcNutation,
		calcAnnualAberration = MLB.coordLib.calcAnnualAberration,
		calcProperMotionPrecessionNutationAnnualAberration = MLB.coordLib.calcProperMotionPrecessionNutationAnnualAberration,
		Position = MLB.coordLib.Position,
		calcAngularSepUsingEquat = MLB.coordLib.calcAngularSepUsingEquat,
		calcAngularSepUsingAltaz = MLB.coordLib.calcAngularSepUsingAltaz,
		calcAirMass = MLB.coordLib.calcAirMass,
		calcAirMass2 = MLB.coordLib.calcAirMass2,
		calcRefractionFromTrue = MLB.coordLib.calcRefractionFromTrue,
		calcRefractionFromApparent = MLB.coordLib.calcRefractionFromApparent,
		parseCoordinateIntoStringArray = MLB.coordLib.parseCoordinateIntoStringArray,
		parseCoordinate = MLB.coordLib.parseCoordinate,
		parseCoordinateGetValueInRadians = MLB.coordLib.parseCoordinateGetValueInRadians,
		setPositionDeg = MLB.coordLib.setPositionDeg,
		setPositionDegFromString = MLB.coordLib.setPositionDegFromString,
		copyPosition = MLB.coordLib.copyPosition,
		isValidPosition = MLB.coordLib.isValidPosition,
		FabErrors = MLB.coordLib.FabErrors,
		setFabErrorsDeg = MLB.coordLib.setFabErrorsDeg,
		MeridianFlip = MLB.coordLib.MeridianFlip,
		setFlipState = MLB.coordLib.setFlipState,
		isFlipped = MLB.coordLib.isFlipped,
		flipAltazAcrossPole = MLB.coordLib.flipAltazAcrossPole,
		translateAltazAcrossPoleBasedOnMeridianFlip = MLB.coordLib.translateAltazAcrossPoleBasedOnMeridianFlip,
		calcMeridianFlipFromCurrentAltaz = MLB.coordLib.calcMeridianFlipFromCurrentAltaz,
		getAltazTrig = MLB.coordLib.getAltazTrig,
		getEquatTrig = MLB.coordLib.getEquatTrig,
		create2DArray = MLB.coordLib.create2DArray,
		ConvertSubroutineType = MLB.coordLib.ConvertSubroutineType,
		InitType = MLB.coordLib.InitType,
		ConvertMatrixWorkingStorage = MLB.coordLib.ConvertMatrixWorkingStorage,
		getAltazMatrix = MLB.coordLib.getAltazMatrix,
		getEquatMatrix = MLB.coordLib.getEquatMatrix,
		initMatrix = MLB.coordLib.initMatrix,
		clearPosition = MLB.coordLib.clearPosition,
		initMatrixFacade = MLB.coordLib.initMatrixFacade,
		Hemisphere = MLB.coordLib.Hemisphere,
		presetEquat = MLB.coordLib.presetEquat,
		presetAltaz = MLB.coordLib.presetAltaz,
		initAltazResults = MLB.coordLib.initAltazResults,
		ConvertStyle = MLB.coordLib.ConvertStyle,
		calcAltOffsetDirectly = MLB.coordLib.calcAltOffsetDirectly,
		calcAltOffsetIteratively = MLB.coordLib.calcAltOffsetIteratively,
		calcFieldRotationAngle = MLB.coordLib.calcFieldRotationAngle,
		bestZ3 = MLB.coordLib.bestZ3,
		bestZ123 = MLB.coordLib.bestZ123,
		XForm = MLB.coordLib.XForm,
		calcKingRateMinutesPerDay = MLB.coordLib.calcKingRateMinutesPerDay,
		calcKingRateArcsecPerSec = MLB.coordLib.calcKingRateArcsecPerSec,
		calcFieldRotationRateSidTrackFormula = MLB.coordLib.calcFieldRotationRateSidTrackFormula,
		calcAltazTrackingRates = MLB.coordLib.calcAltazTrackingRates,
		calcRefractionFromTrueEquatorialCorrection = MLB.coordLib.calcRefractionFromTrueEquatorialCorrection,
		calcRefractionFromApparentEquatorialCorrection = MLB.coordLib.calcRefractionFromApparentEquatorialCorrection,
		TrackingRatesStrategy = MLB.coordLib.TrackingRatesStrategy,
		TrackingRates = MLB.coordLib.TrackingRates,
		ThreeAxis = MLB.coordLib.ThreeAxis;

	QUnit.module('conversions');

	QUnit.test('validRev', function () {
		var value = 390 * uom.degToRad,
		    expected = 30 * uom.degToRad,
		    result = validRev(value);
		equal(withinRange(result, expected, 0.000000001), true, 'validRev should be ' + expected + ', is ' + result);
	});

	QUnit.test('validRev', function () {
		var value = 570 * uom.degToRad,
		    expected = 210 * uom.degToRad,
		    result = validRev(value);
		equal(withinRange(result, expected, 0.000000001), true, 'validRev should be ' + expected + ', is ' + result);
	});

	QUnit.test('validHalfRev', function () {
		var value = 30 * uom.degToRad,
		    expected = 30 * uom.degToRad,
		    result = validHalfRev(value);
		equal(withinRange(result, expected, 0.000000001), true, 'validHalfRev should be ' + expected + ', is ' + result);
	});

	QUnit.test('validHalfRev', function () {
		var value = 210 * uom.degToRad,
		    expected = -150 * uom.degToRad,
		    result = validHalfRev(value);
		equal(withinRange(result, expected, 0.000000001), true, 'validHalfRev should be ' + expected + ', is ' + result);
	});

	QUnit.test('validDec', function () {
		// 30 degrees maps to 30 degrees
		var value = 30 * uom.degToRad,
		    expected = 30 * uom.degToRad,
		    result = validDec(value);
		equal(withinRange(result, expected, 0.000000001), true, 'validDec should be ' + expected + ', is ' + result);
		// 120 degrees maps to 60 degrees
		value = 120 * uom.degToRad;
		expected = 60 * uom.degToRad;
		result = validDec(value);
		equal(withinRange(result, expected, 0.000000001), true, 'validDec should be ' + expected + ', is ' + result);
		// 210 degrees maps to -30 degrees
		value = 210 * uom.degToRad;
		expected = -30 * uom.degToRad;
		result = validDec(value);
		equal(withinRange(result, expected, 0.000000001), true, 'validDec should be ' + expected + ', is ' + result);
		// 300 degrees maps to -60 degrees
		value = 300 * uom.degToRad;
		expected = -60 * uom.degToRad;
		result = validDec(value);
		equal(withinRange(result, expected, 0.000000001), true, 'validDec should be ' + expected + ', is ' + result);
	});
	
	QUnit.test('reverseRev', function () {
		var initialValue = 170 * uom.degToRad,
		    expectedValue = 190 * uom.degToRad,
		    result = reverseRev(initialValue);
		equal(withinRange(result, expectedValue, 0.000000001), true, 'reversed Rev should be ' + expectedValue / uom.degToRad + ', is ' + result / uom.degToRad);
	});

	QUnit.test('calcDecIsFlipped', function () {
		// 30 degrees: not flipped
		var value = 30 * uom.degToRad,
		    result = calcDecIsFlipped(value);
		equal(result, false, 'calcDecIsFlipped should be false, is ' + result);
		// 120 degrees: flipped
		value = 210 * uom.degToRad;
		result = calcDecIsFlipped(value);
		equal(result, true, 'calcDecIsFlipped should be true, is ' + result);
		// -30 degrees: not flipped
		value = -30 * uom.degToRad;
		result = calcDecIsFlipped(value);
		equal(result, false, 'calcDecIsFlipped should be false, is ' + result);
		// -120 degrees: flipped
		value = -120 * uom.degToRad;
		result = calcDecIsFlipped(value);
		equal(result, true, 'calcDecIsFlipped should be true, is ' + result);
	});

	QUnit.test('flipRa', function () {
		var value = 6 * uom.hrToRad,
		    expected = 18 * uom.hrToRad,
		    result = flipRa(value);
		equal(withinRange(result, expected, 0.000000001), true, 'flipRa should be ' + expected + ', is ' + result);
	});

	QUnit.test('flipDec', function () {
		// 30 degrees flips to 150 degrees
		var value = 30 * uom.degToRad,
		    expected = 150 * uom.degToRad,
		    result = flipDec(value);
		equal(withinRange(result, expected, 0.000000001), true, 'flipped Dec should be ' + expected + ', is ' + result);
		// 150 degrees unflips to 30 degrees
		value = 150 * uom.degToRad;
		expected = 30 * uom.degToRad;
		result = flipDec(value);
		equal(withinRange(result, expected, 0.000000001), true, 'unflipped Dec should be ' + expected + ', is ' + result);
		// -30 degrees flips to -150 degrees
		value = -30 * uom.degToRad;
		expected = -150 * uom.degToRad;
		result = flipDec(value);
		equal(withinRange(result, expected, 0.000000001), true, 'flipped Dec should be ' + expected + ', is ' + result);
		// -150 degrees unflips to -30 degrees
		value = -150 * uom.degToRad;
		expected = -30 * uom.degToRad;
		result = flipDec(value);
		equal(withinRange(result, expected, 0.000000001), true, 'unflipped Dec should be ' + expected + ', is ' + result);
	});

	QUnit.test('convertHMSMToRad', function () {
		var result = convertHMSMToRad(1, 2, 3, 4);
		equal(withinRange(result, 0.270744491, 0.000000001), true, 'time of 01:02:03.004 converted to radians should be 0.270744491, is ' + result);
	});

	QUnit.test('convertDMSMToRad', function () {
		var result = convertDMSMToRad(1, 2, 3, 4);
		equal(withinRange(result, 0.0180496327, 0.000000001), true, 'degrees of 01:02:03.004 converted to radians should be 0.0180496327, is ' + result);
	});

	QUnit.test('convertDMSMToRad', function () {
		var result = convertDMSMToRad(1.5, 1.5, 0, 0);
		equal(withinRange(result, 0.0266162711, 0.000000001), true, 'degrees of 01:02:03.004 converted to radians should be 0.0266162711, is ' + result);
	});

	QUnit.test('convertDMSMToRad', function () {
		var result = convertDMSMToRad(-1.5, 1.5, 0, 0);
		equal(withinRange(result, -0.0266162711, 0.000000001), true, 'degrees of -01:02:03.004 converted to radians should be -0.0266162711, is ' + result);
	});

	QUnit.test('convertDMSMToRad', function () {
		var result = convertDMSMToRad(1.5, -1.5, 0, 0);
		equal(withinRange(result, -0.0266162711, 0.000000001), true, 'degrees of -01:02:03.004 converted to radians should be -0.0266162711, is ' + result);
	});

	QUnit.test('convertRadToHMSM', function () {
		var hours = 1 + 2 / 60 + 3 / 3600 + 4 / 3600000,
		    radians = hours * uom.hrToRad,
		    result = convertRadToHMSM(radians);
		equal(result.sign, uom.plus, 'sign should be ' + uom.plus + ', is ' + result.sign);
		equal(result.hours, 1, 'hours should be 1, is ' + result.hours);
		equal(result.minutes, 2, 'minutes should be 2, is ' + result.minutes);
		equal(result.seconds, 3, 'seconds should be 3, is ' + result.seconds);
		equal(result.milliSeconds, 4, 'milliSeconds should be 4, is ' + result.milliSeconds);
	});

	QUnit.test('convertRadToHMSM', function () {
		var hours = -(1 + 2 / 60 + 3 / 3600 + 4 / 3600000),
		    radians = hours * uom.hrToRad,
		    result = convertRadToHMSM(radians);
		equal(result.sign, uom.minus, 'sign should be ' + uom.minus + ', is ' + result.sign);
		equal(result.hours, 1, 'hours should be 1, is ' + result.hours);
		equal(result.minutes, 2, 'minutes should be 2, is ' + result.minutes);
		equal(result.seconds, 3, 'seconds should be 3, is ' + result.seconds);
		equal(result.milliSeconds, 4, 'milliSeconds should be 4, is ' + result.milliSeconds);
	});

	QUnit.test('convertRadToHMS', function () {
		var hours = 1 + 2 / 60 + 3 / 3600 + 750 / 3600000,
		    radians = hours * uom.hrToRad,
		    result = convertRadToHMS(radians);
		equal(result.sign, uom.plus, 'sign should be ' + uom.plus + ', is ' + result.sign);
		equal(result.hours, 1, 'hours should be 1, is ' + result.hours);
		equal(result.minutes, 2, 'minutes should be 2, is ' + result.minutes);
		equal(result.seconds, 4, 'rounded seconds should be 4, is ' + result.seconds);
	});

	QUnit.test('convertRadToHMS', function () {
		var hours = -(1 + 2 / 60 + 3 / 3600 + 750 / 3600000),
		    radians = hours * uom.hrToRad,
		    result = convertRadToHMS(radians);
		equal(result.sign, uom.minus, 'sign should be ' + uom.minus + ', is ' + result.sign);
		equal(result.hours, 1, 'hours should be 1, is ' + result.hours);
		equal(result.minutes, 2, 'minutes should be 2, is ' + result.minutes);
		equal(result.seconds, 4, 'rounded seconds should be 4, is ' + result.seconds);
	});

	QUnit.test('convertRadToDMSM', function () {
		var degrees = 1 + 2 / 60 + 3 / 3600 + 4 / 3600000,
		    radians = degrees * uom.degToRad,
		    result = convertRadToDMSM(radians);
		equal(result.sign, uom.plus, 'sign should be ' + uom.plus + ', is ' + result.sign);
		equal(result.degrees, 1, 'degrees should be 1, is ' + result.degrees);
		equal(result.minutes, 2, 'minutes should be 2, is ' + result.minutes);
		equal(result.seconds, 3, 'seconds should be 3, is ' + result.seconds);
		equal(result.milliSeconds, 4, 'milliSeconds should be 4, is ' + result.milliSeconds);
	});

	QUnit.test('convertRadToDMSM', function () {
		var degrees = -(1 + 2 / 60 + 3 / 3600 + 4 / 3600000),
		    radians = degrees * uom.degToRad,
		    result = convertRadToDMSM(radians);
		equal(result.sign, uom.minus, 'sign should be ' + uom.minus + ', is ' + result.sign);
		equal(result.degrees, 1, 'degrees should be 1, is ' + result.degrees);
		equal(result.minutes, 2, 'minutes should be 2, is ' + result.minutes);
		equal(result.seconds, 3, 'seconds should be 3, is ' + result.seconds);
		equal(result.milliSeconds, 4, 'milliSeconds should be 4, is ' + result.milliSeconds);
	});

	QUnit.test('convertRadToDMS', function () {
		var degrees = 1 + 2 / 60 + 3 / 3600 + 750 / 3600000,
		    radians = degrees * uom.degToRad,
		    result = convertRadToDMS(radians);
		equal(result.sign, uom.plus, 'sign should be ' + uom.plus + ', is ' + result.sign);
		equal(result.degrees, 1, 'degrees should be 1, is ' + result.degrees);
		equal(result.minutes, 2, 'minutes should be 2, is ' + result.minutes);
		equal(result.seconds, 4, 'rounded seconds should be 4, is ' + result.seconds);
	});

	QUnit.test('convertRadToDMS', function () {
		var degrees = -(1 + 2 / 60 + 3 / 3600 + 750 / 3600000),
		    radians = degrees * uom.degToRad,
		    result = convertRadToDMS(radians);
		equal(result.sign, uom.minus, 'sign should be ' + uom.minus + ', is ' + result.sign);
		equal(result.degrees, 1, 'degrees should be 1, is ' + result.degrees);
		equal(result.minutes, 2, 'minutes should be 2, is ' + result.minutes);
		equal(result.seconds, 4, 'rounded seconds should be 4, is ' + result.seconds);
	});
	
	QUnit.test('convertHMSMToString', function () {
		var hours = 1 + 2 / 60 + 3 / 3600 + 4 / 3600000,
		    radians = hours * uom.hrToRad,
			result = convertHMSMToString(convertRadToHMSM(radians)),
			expected = ' 1:02:03.004';
		equal(result, expected, 'expected ' + expected + ', result ' + result);
	});

	QUnit.test('convertHMSMToString', function () {
		var hours = -(1 + 2 / 60 + 3 / 3600 + 4 / 3600000),
		    radians = hours * uom.hrToRad,
			result = convertHMSMToString(convertRadToHMSM(radians)),
			expected = '- 1:02:03.004';
		equal(result, expected, 'expected ' + expected + ', result ' + result);
	});
	
	QUnit.test('convertHMSMToString', function () {
		var hours = 1 + 2 / 60 + 3 / 3600,
		    radians = hours * uom.hrToRad,
			result = convertHMSMToString(convertRadToHMS(radians)),
			expected = ' 1:02:03';
		equal(result, expected, 'expected ' + expected + ', result ' + result);
	});

	QUnit.test('convertHMSMToString', function () {
		var hours = -(1 + 2 / 60 + 3 / 3600),
		    radians = hours * uom.hrToRad,
			result = convertHMSMToString(convertRadToHMS(radians)),
			expected = '- 1:02:03';
		equal(result, expected, 'expected ' + expected + ', result ' + result);
	});

	QUnit.test('convertHMSMToString - limit to hundredths of an arcsecond', function () {
		var limitToHundredthsArcsec = true,
		    hours = 1 + 2 / 60 + 3 / 3600 + 449 / 3600000,
		    radians = hours * uom.hrToRad,
			result = convertHMSMToString(convertRadToHMSM(radians), limitToHundredthsArcsec),
			expected = ' 1:02:03.45';
		equal(result, expected, 'expected ' + expected + ', result ' + result);
	});

	QUnit.test('convertHMSMToString - limit to hundredths of an arcsecond', function () {
		var limitToHundredthsArcsec = true,
		    hours = -(1 + 2 / 60 + 3 / 3600 + 449 / 3600000),
		    radians = hours * uom.hrToRad,
			result = convertHMSMToString(convertRadToHMSM(radians), limitToHundredthsArcsec),
			expected = '- 1:02:03.45';
		equal(result, expected, 'expected ' + expected + ', result ' + result);
	});
	
	QUnit.test('convertDMSMToString', function () {
		var degrees = 1 + 2 / 60 + 3 / 3600 + 4 / 3600000,
		    radians = degrees * uom.degToRad,
			result = convertDMSMToString(convertRadToDMSM(radians)),
			expected = '  1°02\'03.004"';
		equal(result, expected, 'expected ' + expected + ', result ' + result);
	});

	QUnit.test('convertDMSMToString', function () {
		var degrees = -(1 + 2 / 60 + 3 / 3600 + 4 / 3600000),
		    radians = degrees * uom.degToRad,
			result = convertDMSMToString(convertRadToDMSM(radians)),
			expected = '-  1°02\'03.004"';
		equal(result, expected, 'expected ' + expected + ', result ' + result);
	});

	QUnit.test('convertDMSMToString', function () {
		var degrees = 1 + 2 / 60 + 3 / 3600,
		    radians = degrees * uom.degToRad,
			result = convertDMSMToString(convertRadToDMS(radians)),
			expected = '  1°02\'03"';
		equal(result, expected, 'expected ' + expected + ', result ' + result);
	});

	QUnit.test('convertDMSMToString', function () {
		var degrees = -(1 + 2 / 60 + 3 / 3600),
		    radians = degrees * uom.degToRad,
			result = convertDMSMToString(convertRadToDMS(radians)),
			expected = '-  1°02\'03"';
		equal(result, expected, 'expected ' + expected + ', result ' + result);
	});

	QUnit.test('convertDMSMToString - limit to tenths of an arcsecond', function () {
		var limitToTenthsArcsec = true,
		    degrees = 1 + 2 / 60 + 3 / 3600 + 460 / 3600000,
		    radians = degrees * uom.degToRad,
			result = convertDMSMToString(convertRadToDMSM(radians), limitToTenthsArcsec),
			expected = '  1°02\'03.5"';
		equal(result, expected, 'expected ' + expected + ', result ' + result);
	});

	QUnit.test('convertDMSMToString - limit to tenths of an arcsecond', function () {
		var limitToTenthsArcsec = true,
		    degrees = -(1 + 2 / 60 + 3 / 3600 + 460 / 3600000),
		    radians = degrees * uom.degToRad,
			result = convertDMSMToString(convertRadToDMSM(radians), limitToTenthsArcsec),
			expected = '-  1°02\'03.5"';
		equal(result, expected, 'expected ' + expected + ', result ' + result);
	});

	QUnit.test('convertRadiansToHMSMString', function () {
		var hours = 1 + 2 / 60 + 3 / 3600 + 4 / 3600000,
		    radians = hours * uom.hrToRad,
			result = convertRadiansToHMSMString(radians),
			expected = ' 1:02:03.004';
		equal(result, expected, 'expected ' + expected + ', result ' + result);
	});

	QUnit.test('convertRadiansToHMSMString', function () {
		var hours = -(1 + 2 / 60 + 3 / 3600 + 4 / 3600000),
		    radians = hours * uom.hrToRad,
			result = convertRadiansToHMSMString(radians),
			expected = '- 1:02:03.004';
		equal(result, expected, 'expected ' + expected + ', result ' + result);
	});
	
	QUnit.test('convertRadiansToHMSString', function () {
		var hours = 1 + 2 / 60 + 3 / 3600,
		    radians = hours * uom.hrToRad,
			result = convertRadiansToHMSString(radians),
			expected = ' 1:02:03';
		equal(result, expected, 'expected ' + expected + ', result ' + result);
	});

	QUnit.test('convertRadiansToHMSString', function () {
		var hours = -(1 + 2 / 60 + 3 / 3600),
		    radians = hours * uom.hrToRad,
			result = convertRadiansToHMSString(radians),
			expected = '- 1:02:03';
		equal(result, expected, 'expected ' + expected + ', result ' + result);
	});

	QUnit.test('convertRadiansToHMSMString - limit to hundredths of an arcsecond', function () {
		var limitToHundredthsArcsec = true,
		    hours = 1 + 2 / 60 + 3 / 3600 + 449 / 3600000,
		    radians = hours * uom.hrToRad,
			result = convertRadiansToHMSMString(radians, limitToHundredthsArcsec),
			expected = ' 1:02:03.45';
		equal(result, expected, 'expected ' + expected + ', result ' + result);
	});

	QUnit.test('convertRadiansToHMSMString - limit to hundredths of an arcsecond', function () {
		var limitToHundredthsArcsec = true,
		    hours = -(1 + 2 / 60 + 3 / 3600 + 449 / 3600000),
		    radians = hours * uom.hrToRad,
			result = convertRadiansToHMSMString(radians, limitToHundredthsArcsec),
			expected = '- 1:02:03.45';
		equal(result, expected, 'expected ' + expected + ', result ' + result);
	});
	
	QUnit.test('convertRadiansToDMSMString', function () {
		var degrees = 1 + 2 / 60 + 3 / 3600 + 4 / 3600000,
		    radians = degrees * uom.degToRad,
			result = convertRadiansToDMSMString(radians),
			expected = '  1°02\'03.004"';
		equal(result, expected, 'expected ' + expected + ', result ' + result);
	});

	QUnit.test('convertRadiansToDMSMString', function () {
		var degrees = -(1 + 2 / 60 + 3 / 3600 + 4 / 3600000),
		    radians = degrees * uom.degToRad,
			result = convertRadiansToDMSMString(radians),
			expected = '-  1°02\'03.004"';
		equal(result, expected, 'expected ' + expected + ', result ' + result);
	});

	QUnit.test('convertRadiansToDMSMString - limit to tenths of an arcsecond', function () {
		var limitToTenthsArcsec = true,
		    degrees = 1 + 2 / 60 + 3 / 3600 + 460 / 3600000,
		    radians = degrees * uom.degToRad,
			result = convertRadiansToDMSMString(radians, limitToTenthsArcsec),
			expected = '  1°02\'03.5"';
		equal(result, expected, 'expected ' + expected + ', result ' + result);
	});

	QUnit.test('convertRadiansToDMSMString - limit to tenths of an arcsecond', function () {
		var limitToTenthsArcsec = true,
		    degrees = -(1 + 2 / 60 + 3 / 3600 + 460 / 3600000),
		    radians = degrees * uom.degToRad,
			result = convertRadiansToDMSMString(radians, limitToTenthsArcsec),
			expected = '-  1°02\'03.5"';
		equal(result, expected, 'expected ' + expected + ', result ' + result);
	});

	QUnit.module('astro time');
	
	QUnit.test('dateFromString', function () {
		var result = dateFromString('Mar 1, 2000');
		equal(result.getFullYear(), 2000, 'year should be 2000');
		equal(result.getMonth(), 2, 'month should be 2');
		equal(result.getDate(), 1, 'day should be 1');
	});
	
	QUnit.test('dateFromString', function () {
		var result = dateFromString('May 1, 2012');
		equal(result.getFullYear(), 2012, 'year should be 2012');
		equal(result.getMonth(), 4, 'month should be 4');
		equal(result.getDate(), 1, 'day should be 1');
	});
	
	QUnit.test('dateToString', function () {
		var result = dateToString(new Date(2012, 4, 3, 14, 23, 56, 0)),
		    expected = "May 3, 2012 14:23:56";
		equal(result, expected, 'string from date should be ' + expected);
	});
	
	QUnit.test('isLeapYear', function () {
		equal(isLeapYear(2004), true, '2004 is a leap year');
		equal(isLeapYear(2001), false, '2001 is not a leap year');
		equal(isLeapYear(2000), true, '2000 is a leap year');
		equal(isLeapYear(1900), false, '1900 is not a leap year');
	});
	
	QUnit.test('day of year', function () {
		equal(calcDayOfTheYear(1978, 11, 14, 0, 0, 0, 0), 318, 'day of year should be 318');
		equal(calcDayOfTheYear(1988, 4, 22, 0, 0, 0, 0), 113, 'day of year should be 113');
	});
	
	function testDateFromJD(JD, timeZone, expectedYear, expectedMonth, expectedDay, expectedHrs, expectedMins, expectedSecs, expectedMilliseconds) {
		var result = calcDateFromJD(JD, timeZone);
		
		equal(result.year, expectedYear, 'year should be ' + expectedYear + ', is ' + result.year);
		equal(result.month, expectedMonth, 'month should be ' + expectedMonth + ', is ' + result.month);
		equal(result.day, expectedDay, 'day should be ' + expectedDay + ', is ' + result.day);	
		equal(result.hours, expectedHrs, 'hours should be ' + expectedHrs + ', is ' + result.hours);	
		equal(result.minutes, expectedMins, 'minutes should be ' + expectedMins + ', is ' + result.minutes);	
		equal(result.seconds, expectedSecs, 'seconds should be ' + expectedSecs + ', is ' + result.seconds);	
		equal(result.milliseconds, expectedMilliseconds, 'seconds should be ' + expectedMilliseconds + ', is ' + result.milliseconds);	
	}

	var Meeus1982JD = 2443825.69;
	var Meeus1998JD = 2462088.69;
	
	QUnit.test('calcJulianYear and calcJDFromJulianYear', function () {
		var allowedErrorYear = 0.0000001, // ~ 3 seconds
		    allowedErrorJD = 0.0001, // ~ 9 seconds
		    JD = Meeus1998JD,
		    expectedJulianYear = 2028.86705,
		    resultJulianYear = calcJulianYear(Meeus1998JD),
			resultJD = calcJDFromJulianYear(expectedJulianYear);
			
		equal(withinRange(resultJulianYear, expectedJulianYear, allowedErrorYear), true, 'expectedJulianYear is ' + expectedJulianYear + ', resultJulianYear is ' + resultJulianYear);
		equal(withinRange(resultJD, JD, allowedErrorJD), true, 'expected JD is ' + resultJD + ', actual JD is ' + JD);
	});

	QUnit.test('calcJD', function () {
		var JD;

		// from Meeus
		JD = calcJD(1957, 10, 4, 19, 26, 24, 0, 0);
		equal(JD, 2436116.31, 'JD should be 2436116.31, is ' + JD);
		testDateFromJD(2436116.31, 0, 1957, 10, 4, 19, 26, 24, 0);

		// Jan 1, 2000, noon
		JD = calcJD(2000, 1, 1, 12, 0, 0, 0, 0);
		equal(JD, 2451545, 'JD should be 2451545, is ' + JD);
		testDateFromJD(2451545, 0, 2000, 1, 1, 12, 0, 0, 0);

		JD = calcJD(1999, 1, 1, 0, 0, 0, 0, 0);
		equal(JD, 2451179.5, 'JD should be 2451179.5, is ' + JD);
		testDateFromJD(2451179.5, 0, 1999, 1, 1, 0, 0, 0, 0);

		JD = calcJD(1987, 1, 27, 0, 0, 0, 0, 0);
		equal(JD, 2446822.5, 'JD should be 2446822.5, is ' + JD);
		testDateFromJD(2446822.5, 0, 1987, 1, 27, 0, 0, 0, 0);

		JD = calcJD(1987, 1, 27, 1, 0, 0, 0, 0);
		equal(withinRange(JD, 2446822.5416666665, 0.00001), true, 'JD should be 2446822.5416666665, is ' + JD);
		testDateFromJD(2446822.5416666665, 0, 1987, 1, 27, 1, 0, 0, 0);

		JD = calcJD(1987, 6, 19, 12, 0, 0, 0, 0);
		equal(JD, 2446966, 'JD should be 2446966, is ' + JD);
		testDateFromJD(2446966, 0, 1987, 6, 19, 12, 0, 0, 0);

		JD = calcJD(1987, 4, 10, 19, 21, 0, 0, 0);
		equal(JD, 2446896.30625, 'JD should be 2446896.30625, is ' + JD);
		testDateFromJD(2446896.30625, 0, 1987, 4, 10, 19, 21, 0, 0);

		JD = calcJD(2012, 12, 31, 0, 0, 0, 0, 0);
		equal(JD, 2456292.5, 'JD should be 2456292.5, is ' + JD);
		testDateFromJD(2456292.5, 0, 2012, 12, 31, 0, 0, 0, 0);
		
		JD = calcJD(2028, 11, 13, 4, 33, 36, 0, 0);
		equal(JD, 2462088.69, 'JD should be 2462088.69, is ' + JD);
		testDateFromJD(2462088.69, 0, 2028, 11, 13, 4, 33, 36, 0);

		// timezone offset
		JD = calcJD(2000, 1, 11, 12, 0, 0, 0, -6);
		equal(JD, 2451555.25, 'JD should be 2451555.25, is ' + JD);
		testDateFromJD(2451555.25, -6, 2000, 1, 11, 12, 0, 0, 0);
	});
	
	QUnit.test('calcSidT', function () {
		// test example from Astronomical Algorithms, 2nd edition, Meeus
		var sidTRad = calcSidT(1987, 4, 10, 19, 21, 0, 0, 0, 0),
		    sidT = convertRadToHMSM(sidTRad),
		    result = sidT.hours + ':' + sidT.minutes + ':' + (sidT.seconds + sidT.milliSeconds / 1000),
		    expected = '8:34:57.088';
		equal(result, expected, 'sidereal time for 1987, April 10, 19:21:00 (JD = 2446896.30625) should be ' + expected);
	});

	QUnit.test('calcSidT', function () {
		// test from http://www2.arnes.si/~gljsentvid10/sidereal.htm
	    var sidTRad = calcSidT(1994, 6, 16, 18, 0, 0, 0, 0, 0),
		    sidT = convertRadToHMSM(sidTRad),
		    result = sidT.hours + ':' + sidT.minutes + ':' + (sidT.seconds + sidT.milliSeconds / 1000),
		    expected = '11:39:5.067';
		equal(result, expected, 'sidereal time should be ' + expected);
	});

	QUnit.test('calcSidT realtime', function () {
		// local sidereal time for longitude of 120 W (-120 deg)
	    var date = new Date(),
		    year = date.getFullYear(),
		    month = date.getMonth() + 1,
		    day = date.getDate(),
		    hr = date.getHours(),
		    min = date.getMinutes(),
		    sec = date.getSeconds(),
		    millisec = date.getMilliseconds(),
		    tz = -date.getTimezoneOffset() / 60,
		    longitude = -120,
		    sidTRad = calcSidT(year, month, day, hr, min, sec, millisec, tz, longitude),
		    sidT = convertRadToHMS(sidTRad);
		equal(true, true, 'local sidereal time for y' + year + ' m' + month  + ' d' + day  + ' h' + hr + ' m' + min + ' s' + sec + ' ms' + millisec + ' tz' + tz + ' lon' + longitude + ' should be ' + sidT.hours + ':' + sidT.minutes  + ':' + sidT.seconds);
	});

	var MeeusProperMotionTestRAArcsec = 0.03425;
	var MeeusProperMotionTestDecArcsec = 0.0895;
	// Meeus says 4.1, -7.1
	var Meeus1982NutationTestRA = 40.687;
	var Meeus1982NutationTestDec = 49.14;
	var nutationMeeusTest1RA = 4.1;
	var nutationMeeusTest1Dec = -7.1;
	var nutationAnnualAberrationAllowedErrorArcsec = 0.1;
	// Meeus says 15.8, 6.2
	var Meeus1998NutationAnnualAberrationTest2RA = 41.547214;
	var Meeus1998NutationAnnualAberrationTest2Dec = 49.348483;	
	var nutationMeeusTest2RA = 16.0;
	var nutationMeeusTest2Dec = 6.2;
	// Meeus says 29.6, 6.6
	var AnnualAberrationMeeusTest1RA = 29.8;
	var AnnualAberrationMeeusTest1Dec = 6.7;
	// Meeus says 30.0, 6.7
	var AnnualAberrationMeeusTest2RA = 30.0;
	var AnnualAberrationMeeusTest2Dec = 6.7;
	var precessionMeeusTest2DeltaRAArcsec = 1781.6;
	var precessionMeeusTest2DeltaDecArcsec = 431.4;
	var properMotionMeeusTestRAArcsec = 14.8304469375;
	var properMotionMeeusTestDecArcsec = 2.583600975;

	function calcJD_Nov13_2028_04_33_36() {
		return calcJD(2028, 11, 13, 4, 33, 36, 0, 0);
	}

	QUnit.module('proper motion');
	
	// Meeus' test from 2nd edition
	QUnit.test('proper motion', function () {
		var allowedErrorArcsec = 0.01,
		    expectedDeltaRAArcsec = 0.989 * 15,
		    expectedDeltaDecArcsec = 2.58,
			properMotion = calcProperMotion(MeeusProperMotionTestRAArcsec * uom.secToRad, MeeusProperMotionTestDecArcsec * uom.arcsecToRad, calcJulianYear(calcJD_Nov13_2028_04_33_36()) - 2000),
			deltaRAArcsec = properMotion.deltaRA / uom.arcsecToRad,
			deltaDecArcsec = properMotion.deltaDec / uom.arcsecToRad;
		equal(withinRange(deltaRAArcsec, expectedDeltaRAArcsec, allowedErrorArcsec), true);
		equal(withinRange(deltaDecArcsec, expectedDeltaDecArcsec, allowedErrorArcsec), true);
	});
	
	QUnit.module('precession');

	// change over 5 years (from 2000 to 2005) using position 00:00:00 00:00:00 is 00:00:15.375 00:01:40
	QUnit.test('calcPrecessionQuick', function () {
		var result, precessedRa, precessedRaResult, precessedDec, precessedDecResult;
		result = calcPrecessionQuick(0, 0, 5);
		equal(withinRange(result.deltaRA, 0.0011181, 0.000001), true, 'precession in Ra should be 0.0011181, is ' + result.deltaRA);
		equal(withinRange(result.deltaDec, 0.000485, 0.000001), true, 'precession in Dec should be 0.000485, is ' + result.deltaDec);

		precessedRa = convertRadToHMSM(result.deltaRA);
		precessedRaResult = precessedRa.hours + ':' + precessedRa.minutes + ':' + precessedRa.seconds + '.' + precessedRa.milliSeconds;
		equal(precessedRaResult, '0:0:15.375', 'precession in Ra should be 0:0:15.375, is ' + precessedRaResult);

		precessedDec = convertRadToDMS(result.deltaDec);
		precessedDecResult = precessedDec.degrees + ':' + precessedDec.minutes + ':' + precessedDec.seconds;
		equal(precessedDecResult, '0:1:40', 'precession in Dec should be 0:1:40, is ' + precessedDecResult);
	});

	/* from communication w/ Don Ware:
       Alpha Andromeda
       J2000.0 from Yale Bright Star and Hipparcos
       Ra  00:08:23
       Dec 29:05:26
       After precession over 5 yrs:
       Ra  00:08:39
       Dec 29:07:06	*/
	QUnit.test('calcPrecessionQuick', function () {
		var startingRa = convertHMSMToRad(0, 8, 23, 0),
		    startingDec = convertDMSMToRad(29, 5, 26, 0),
		    result = calcPrecessionQuick(startingRa, startingDec, 5),
		    precessedRa = convertRadToHMS(startingRa + result.deltaRA),
		    precessedRaResult = precessedRa.hours + ':' + precessedRa.minutes + ':' + precessedRa.seconds,
		    precessedDec = convertRadToDMS(startingDec + result.deltaDec),
		    precessedDecResult = precessedDec.degrees + ':' + precessedDec.minutes + ':' + precessedDec.seconds;
		equal(precessedRaResult, '0:8:39', 'precession in Ra should be 0:8:39, is ' + precessedRaResult);
		equal(precessedDecResult, '29:7:6', 'precession in Dec should be 29:7:6, is ' + precessedDecResult);
	});

	// from Astronomical Algorithms, 2nd edition, Meeus; includes proper motion
	function testPrecessionRegulus(strategy) {
		var RegulusJ1978RaRad = convertHMSMToRad(10, 7, 12.1, 0),
            RegulusJ1978DecRad = convertDMSMToRad(12, 4, 31, 0),

	        RegulusJ2000RaRad = convertHMSMToRad(10, 8, 22.3, 0),
            RegulusJ2000DecRad = convertDMSMToRad(11, 58, 2, 0),

            JulianYearsSinceYear2000 = -22,
			properMotion = calcProperMotion(-0.0169 * uom.secToRad, 0.006 * uom.arcsecToRad, JulianYearsSinceYear2000),
            RegulusJ2000RaProperMotionRad = RegulusJ2000RaRad + properMotion.deltaRA,
            RegulusJ2000DecProperMotionRad = RegulusJ2000DecRad + properMotion.deltaDec,

			result, precessedRaRad, precessedRa, precessedRaResult, precessedDecRad, precessedDec, precessedDecResult;

		if (strategy === 'quick') {
			result = calcPrecessionQuick(RegulusJ2000RaProperMotionRad, RegulusJ2000DecProperMotionRad, JulianYearsSinceYear2000);
		} else if (strategy === 'rigorous') {
			result = calcPrecessionRigorous(RegulusJ2000RaProperMotionRad, RegulusJ2000DecProperMotionRad, 2000, JulianYearsSinceYear2000);
		}

		precessedRaRad = RegulusJ2000RaProperMotionRad + result.deltaRA;
		precessedRa = convertRadToHMSM(precessedRaRad);
		precessedRaResult = precessedRa.hours + ':' + precessedRa.minutes + ':' + precessedRa.seconds + '.' + precessedRa.milliSeconds;
		equal(withinRange(RegulusJ1978RaRad, precessedRaRad, uom.arcsecToRad), true, 'precession in Ra should be 10:7:12.1, is ' + precessedRaResult);

		precessedDecRad = RegulusJ2000DecProperMotionRad + result.deltaDec;
		precessedDec = convertRadToDMSM(precessedDecRad);
		precessedDecResult = precessedDec.degrees + ':' + precessedDec.minutes + ':' + precessedDec.seconds + '.' + precessedDec.milliSeconds;
		equal(withinRange(RegulusJ1978DecRad, precessedDecRad, uom.arcsecToRad), true, 'precession in Dec should be 12:4:31, is ' + precessedDecResult);
	}

	// from Astronomical Algorithms, 2nd edition, Meeus; includes proper motion
	function testPrecessionThetaPersei(strategy) {
		var ThetaPerseiJ2028RaRad = convertHMSMToRad(2, 46, 11.331, 0),
            ThetaPerseiJ2028DecRad = convertDMSMToRad(49, 20, 54.54, 0),

	        ThetaPerseiJ2000RaRad = convertHMSMToRad(2, 44, 11.986, 0),
            ThetaPerseiJ2000DecRad = convertDMSMToRad(49, 13, 42.48, 0),

            JulianYearsSinceYear2000 = 28.86705,
			properMotion = calcProperMotion(MeeusProperMotionTestRAArcsec * uom.secToRad, -MeeusProperMotionTestDecArcsec * uom.arcsecToRad, JulianYearsSinceYear2000),
            ThetaPerseiJ2000RaProperMotionRad = ThetaPerseiJ2000RaRad + properMotion.deltaRA,
            ThetaPerseiJ2000DecProperMotionRad = ThetaPerseiJ2000DecRad + properMotion.deltaDec,

			result, precessedRaRad, precessedRa, precessedRaResult, precessedDecRad, precessedDec, precessedDecResult;

		if (strategy === 'quick') {
		    result = calcPrecessionQuick(ThetaPerseiJ2000RaProperMotionRad, ThetaPerseiJ2000DecProperMotionRad, JulianYearsSinceYear2000);
		} else if (strategy === 'rigorous') {
		    result = calcPrecessionRigorous(ThetaPerseiJ2000RaProperMotionRad, ThetaPerseiJ2000DecProperMotionRad, 2000, JulianYearsSinceYear2000);
		}

	    precessedRaRad = ThetaPerseiJ2000RaProperMotionRad + result.deltaRA;
	    precessedRa = convertRadToHMSM(precessedRaRad);
	    precessedRaResult = precessedRa.hours + ':' + precessedRa.minutes + ':' + precessedRa.seconds + '.' + precessedRa.milliSeconds;
		equal(withinRange(ThetaPerseiJ2028RaRad, precessedRaRad, uom.arcsecToRad), true, 'precession in Ra should be 2:46:11.331, is ' + precessedRaResult);

	    precessedDecRad = ThetaPerseiJ2000DecProperMotionRad + result.deltaDec;
	    precessedDec = convertRadToDMSM(precessedDecRad);
	    precessedDecResult = precessedDec.degrees + ':' + precessedDec.minutes + ':' + precessedDec.seconds + '.' + precessedDec.milliSeconds;
		equal(withinRange(ThetaPerseiJ2028DecRad, precessedDecRad, uom.arcsecToRad), true, 'precession in Dec should be 49:20:54.54, is ' + precessedDecResult);
	}

	// from Astronomical Algorithms, 2nd edition, Meeus: high Declination example
	function testPrecessionPolaris(strategy) {
		var PolarisJ2100RaRad = convertHMSMToRad(5, 53, 29.17, 0),
            PolarisJ2100DecRad = convertDMSMToRad(89, 32, 22.18, 0),

	        PolarisJ2000RaRad = convertHMSMToRad(2, 31, 48.704, 0),
            PolarisJ2000DecRad = convertDMSMToRad(89, 15, 50.72, 0),

            JulianYearsSinceYear2000 = 100,
			properMotion = calcProperMotion(0.19877 * uom.secToRad, -0.0152 * uom.arcsecToRad, JulianYearsSinceYear2000),
            PolarisJ2000RaProperMotionRad = PolarisJ2000RaRad + properMotion.deltaRA,
            PolarisJ2000DecProperMotionRad = PolarisJ2000DecRad + properMotion.deltaDec,

			result, precessedRaRad, precessedRa, precessedRaResult, precessedDecRad, precessedDec, precessedDecResult;

		if (strategy === 'quick') {
		    result = calcPrecessionQuick(PolarisJ2000RaProperMotionRad, PolarisJ2000DecProperMotionRad, JulianYearsSinceYear2000);
		} else if (strategy === 'rigorous') {
		    result = calcPrecessionRigorous(PolarisJ2000RaProperMotionRad, PolarisJ2000DecProperMotionRad, 2000, JulianYearsSinceYear2000);
		}

	    precessedRaRad = PolarisJ2000RaProperMotionRad + result.deltaRA;
	    precessedRa = convertRadToHMSM(precessedRaRad);
	    precessedRaResult = precessedRa.hours + ':' + precessedRa.minutes + ':' + precessedRa.seconds + '.' + precessedRa.milliSeconds;
		// note: need to increase Ra tolerance to 12 arcseconds
		equal(withinRange(PolarisJ2100RaRad, precessedRaRad, 12 * uom.arcsecToRad), true, 'precession in Ra should be 5:53:29.17, is ' + precessedRaResult);

	    precessedDecRad = PolarisJ2000DecProperMotionRad + result.deltaDec;
	    precessedDec = convertRadToDMSM(precessedDecRad);
	    precessedDecResult = precessedDec.degrees + ':' + precessedDec.minutes + ':' + precessedDec.seconds + '.' + precessedDec.milliSeconds;
		equal(withinRange(PolarisJ2100DecRad, precessedDecRad, uom.arcsecToRad), true, 'precession in Dec should be 89:32:22.18, is ' + precessedDecResult);
	}

	QUnit.test('testPrecessionRegulus: quick', function () {
		testPrecessionRegulus('quick');
	});

	QUnit.test('testPrecessionRegulus: rigorous', function () {
		testPrecessionRegulus('rigorous');
	});

	// quick algorithm fails - needs the rigorous algorithm
	QUnit.test('testPrecessionThetaPersei: rigorous', function () {
		testPrecessionThetaPersei('rigorous');
	});

	// quick algorithm fails - needs the rigorous algorithm
	QUnit.test('testPrecessionPolaris: rigorous', function () {
		testPrecessionPolaris('rigorous');
	});
	
	QUnit.test('precession - starting year is same as ending year meaning no precession', function () {
		var precession = calcPrecessionQuick(1, 1, 0);
		equal(precession.deltaRA, 0, 'RA should be zero');
		equal(precession.deltaDec, 0, 'Dec should be zero');

		precession = calcPrecessionRigorous(1, 1, 2000, 0);
		equal(precession.deltaRA, 0, 'RA should be zero');
		equal(precession.deltaDec, 0, 'Dec should be zero');

		precession = calcPrecessionRigorous(1, 1, 2020, 0);
		equal(precession.deltaRA, 0, 'RA should be zero');
		equal(precession.deltaDec, 0, 'Dec should be zero');
	});
	
	QUnit.module('nutation');

	QUnit.test('calcNutation', function () {
		// nutation test from Astronomical Algorithms, Meeus, 1982
		var JulianYearsSinceJD2000 = calcJulianYear(Meeus1982JD) - 2000,
		    cp = celestialParms(JulianYearsSinceJD2000),
		    result = calcNutation(Meeus1982NutationTestRA * uom.degToRad, Meeus1982NutationTestDec * uom.degToRad, cp.eclipticObliquity, cp.nutationLon, cp.nutationObliquity),
		    deltaRAArcsec = result.deltaRA / uom.arcsecToRad,
		    deltaDecArcsec = result.deltaDec / uom.arcsecToRad;
		equal(withinRange(deltaRAArcsec, nutationMeeusTest1RA, nutationAnnualAberrationAllowedErrorArcsec), true, 'nutation in RA should be ' + nutationMeeusTest1RA + ' (Meeus says 4.059), is ' + deltaRAArcsec);
		equal(withinRange(deltaDecArcsec, nutationMeeusTest1Dec, nutationAnnualAberrationAllowedErrorArcsec), true, 'nutation in Dec should be ' + nutationMeeusTest1Dec + ' (Meeus says -7.096), is ' + deltaDecArcsec);
	});
	
	QUnit.test('calcNutation', function () {
        // nutation test #2 from Astronomical Algorithms, 2nd edition, Meeus, 1998
	    var JulianYearsSinceJD2000 = calcJulianYear(Meeus1998JD) - 2000,
		    cp = celestialParms(JulianYearsSinceJD2000),
		    result = calcNutation(Meeus1998NutationAnnualAberrationTest2RA * uom.degToRad, Meeus1998NutationAnnualAberrationTest2Dec * uom.degToRad, cp.eclipticObliquity, cp.nutationLon, cp.nutationObliquity),
		    deltaRAArcsec = result.deltaRA / uom.arcsecToRad,
		    deltaDecArcsec = result.deltaDec / uom.arcsecToRad;
		equal(withinRange(deltaRAArcsec, nutationMeeusTest2RA, nutationAnnualAberrationAllowedErrorArcsec), true, 'nutation in RA should be ' + nutationMeeusTest2RA + ' (Meeus says 15.843), is ' + deltaRAArcsec);
		equal(withinRange(deltaDecArcsec, nutationMeeusTest2Dec, nutationAnnualAberrationAllowedErrorArcsec), true, 'nutation in Dec should be ' + nutationMeeusTest2Dec + ' (Meeus says 6.219), is ' + deltaDecArcsec);
	});

	QUnit.module('annual aberration');

	QUnit.test('calcAnnualAberration', function () {
		// annual aberration test from Astronomical Algorithms, Meeus, 1982
		var JulianYearsSinceJD2000 = calcJulianYear(Meeus1982JD) - 2000,
		    cp = celestialParms(JulianYearsSinceJD2000),
		    result = calcAnnualAberration(Meeus1982NutationTestRA * uom.degToRad, Meeus1982NutationTestDec * uom.degToRad, cp.SunTrueLon, cp.eclipticObliquity, cp.eEarthOrbit, cp.EarthPerihelionLon),
		    deltaRAArcsec = result.deltaRA / uom.arcsecToRad,
		    deltaDecArcsec = result.deltaDec / uom.arcsecToRad;
		equal(withinRange(deltaRAArcsec, AnnualAberrationMeeusTest1RA, nutationAnnualAberrationAllowedErrorArcsec), true, 'annual aberration in RA should be ' + AnnualAberrationMeeusTest1RA + ' (Meeus says 29.619), is ' + deltaRAArcsec);
		equal(withinRange(deltaDecArcsec, AnnualAberrationMeeusTest1Dec, nutationAnnualAberrationAllowedErrorArcsec), true, 'annual aberration in Dec should be ' + AnnualAberrationMeeusTest1Dec + ' (Meeus says 6.554), is ' + deltaDecArcsec);
	});

	QUnit.test('calcAnnualAberration', function () {
		// annual aberration test from Astronomical Algorithms, 2nd edition, Meeus, 1998
	    var JulianYearsSinceJD2000 = calcJulianYear(Meeus1998JD) - 2000,
		    cp = celestialParms(JulianYearsSinceJD2000),
		    result = calcAnnualAberration(Meeus1998NutationAnnualAberrationTest2RA * uom.degToRad, Meeus1998NutationAnnualAberrationTest2Dec * uom.degToRad, cp.SunTrueLon, cp.eclipticObliquity, cp.eEarthOrbit, cp.EarthPerihelionLon),
		    deltaRAArcsec = result.deltaRA / uom.arcsecToRad,
		    deltaDecArcsec = result.deltaDec / uom.arcsecToRad;
		equal(withinRange(deltaRAArcsec, AnnualAberrationMeeusTest2RA, nutationAnnualAberrationAllowedErrorArcsec), true, 'annual aberration in RA should be ' + AnnualAberrationMeeusTest2RA + ' (Meeus says 30.045), is ' + deltaRAArcsec);
		equal(withinRange(deltaDecArcsec, AnnualAberrationMeeusTest2Dec, nutationAnnualAberrationAllowedErrorArcsec), true, 'annual aberration in Dec should be ' + AnnualAberrationMeeusTest2Dec + ' (Meeus says 6.697), is ' + deltaDecArcsec);
	});
	
	QUnit.module('facade for precession, nutation and annual aberration');
	
	QUnit.test('calcProperMotionPrecessionNutationAnnualAberration - ignore proper motion', function () {
        // nutation test #2 and annual aberration test from Astronomical Algorithms, 2nd edition, Meeus, 1998
		var coordJD = uom.JD2000,
		    JD = Meeus1998JD,
			expectedTotalDeltaRAArcsec = precessionMeeusTest2DeltaRAArcsec + nutationMeeusTest2RA + AnnualAberrationMeeusTest2RA,
			expectedTotalDeltaDecArcsec = precessionMeeusTest2DeltaDecArcsec + nutationMeeusTest2Dec + AnnualAberrationMeeusTest2Dec,
		    corrections = calcProperMotionPrecessionNutationAnnualAberration(Meeus1998NutationAnnualAberrationTest2RA * uom.degToRad, Meeus1998NutationAnnualAberrationTest2Dec * uom.degToRad, coordJD, JD, 0, 0),
			deltaPrecessionRAArcsec = corrections.precession.deltaRA / uom.arcsecToRad,
			deltaPrecessionDecArcsec = corrections.precession.deltaDec / uom.arcsecToRad,
			deltaNutationRAArcsec = corrections.nutation.deltaRA / uom.arcsecToRad,
			deltaNutationDecArcsec = corrections.nutation.deltaDec / uom.arcsecToRad,	
			deltaAnnualAberrationRAArcsec = corrections.annualAberration.deltaRA / uom.arcsecToRad,
			deltaAnnualAberrationDecArcsec = corrections.annualAberration.deltaDec / uom.arcsecToRad,	
			deltaTotalRAArcsec = corrections.total.deltaRA / uom.arcsecToRad,
			deltaTotalDecArcsec = corrections.total.deltaDec / uom.arcsecToRad;
		equal(withinRange(deltaPrecessionRAArcsec, precessionMeeusTest2DeltaRAArcsec, nutationAnnualAberrationAllowedErrorArcsec), true, 'precession in RA');
		equal(withinRange(deltaPrecessionDecArcsec, precessionMeeusTest2DeltaDecArcsec, nutationAnnualAberrationAllowedErrorArcsec), true, 'precession in Dec');
		equal(withinRange(deltaNutationRAArcsec, nutationMeeusTest2RA, nutationAnnualAberrationAllowedErrorArcsec), true, 'nutation in RA');
		equal(withinRange(deltaNutationDecArcsec, nutationMeeusTest2Dec, nutationAnnualAberrationAllowedErrorArcsec), true, 'nutation in Dec');		
		equal(withinRange(deltaAnnualAberrationRAArcsec, AnnualAberrationMeeusTest2RA, nutationAnnualAberrationAllowedErrorArcsec), true, 'annualAberration in RA');
		equal(withinRange(deltaAnnualAberrationDecArcsec, AnnualAberrationMeeusTest2Dec, nutationAnnualAberrationAllowedErrorArcsec), true, 'annualAberration in Dec');		
		equal(withinRange(deltaTotalRAArcsec, expectedTotalDeltaRAArcsec, deltaTotalRAArcsec), true, 'total in RA');
		equal(withinRange(deltaTotalDecArcsec, expectedTotalDeltaDecArcsec, deltaTotalDecArcsec), true, 'total in Dec');
	});
	
	QUnit.test('calcProperMotionPrecessionNutationAnnualAberration - only proper motion', function () {
		var allowedErrorArcsec = 0.000001,
			// 28.86705 Julian Years
			corrections = calcProperMotionPrecessionNutationAnnualAberration(0, 0, uom.JD2000, calcJD_Nov13_2028_04_33_36(),  MeeusProperMotionTestRAArcsec * uom.secToRad, MeeusProperMotionTestDecArcsec * uom.arcsecToRad),
			deltaRAArcsec = corrections.properMotion.deltaRA / uom.arcsecToRad,
			deltaDecArcsec = corrections.properMotion.deltaDec / uom.arcsecToRad;
		equal(withinRange(deltaRAArcsec, properMotionMeeusTestRAArcsec, allowedErrorArcsec), true, 'RA');
		equal(withinRange(deltaDecArcsec, properMotionMeeusTestDecArcsec, allowedErrorArcsec), true, 'Dec');
	});
	
	QUnit.module('angular separation routines');

	QUnit.test('calcAngularSep', function () {
		// Ra 4:44:24.033, Dec -10:10:55, Az 150, Alt 30, SidT 3:00:00
		var positionA = new Position(convertHMSMToRad(4, 44, 24.033, 0), convertDMSMToRad(-10, 10, 55, 0), 150 * uom.degToRad, 30 * uom.degToRad, convertHMSMToRad(3, 0, 0, 0), 0),

		// Ra 5:58:05.788, Dec 2:16:04, Az 140, Alt 40, SidT 4:00:00
	    positionZ = new Position(convertHMSMToRad(5, 58, 5.788, 0), convertDMSMToRad(2, 16, 4, 0), 140 * uom.degToRad, 40 * uom.degToRad, convertHMSMToRad(4, 0, 0, 0), 0),

	    angularSepDegUsingEquat = calcAngularSepUsingEquat(positionA, positionZ) / uom.degToRad,
	    angularSepDegUsingAltaz = calcAngularSepUsingAltaz(positionA, positionZ) / uom.degToRad,
		// 1 arcsecond (accuracy of Dec)
	    allowedVariance = 1 / 3600;
		equal(withinRange(angularSepDegUsingEquat, angularSepDegUsingAltaz, allowedVariance), true, 'separation (deg) should be ' + angularSepDegUsingEquat + ', is ' + angularSepDegUsingAltaz);
	});

	QUnit.module('air mass calc');
	
	function testAirMass(strategy, elevationDegrees, expected, variance) {
	    var result = strategy(elevationDegrees);
		equal(withinRange(result, expected, variance), true, 'airmass should be ' + expected + ', is ' + result);		
	}

	QUnit.test('calcAirMass', function () {
		testAirMass(calcAirMass, 60, 1.15, 0.01);
	});

	QUnit.test('calcAirMass', function () {
		testAirMass(calcAirMass, 30, 1.99, 0.01);
	});
	
	QUnit.test('calcAirMass', function () {
		testAirMass(calcAirMass, 0, 38, 1);
	});
	
	QUnit.test('calcAirMass2', function () {
		testAirMass(calcAirMass2, 60, 1.15, 0.01);
	});

	QUnit.test('calcAirMass2', function () {
		testAirMass(calcAirMass2, 30, 1.99, 0.01);
	});

	QUnit.test('calcAirMass2', function () {
		testAirMass(calcAirMass2, 0, 38, 1);
	});
	
	QUnit.module('refraction');
	
	QUnit.test('calcRefractionFromTrue', function () {
	    var trueElevationDegrees = 25,
		    resultRad = calcRefractionFromTrue(trueElevationDegrees),
		    resultArcminutes = resultRad / uom.arcminToRad,
		    expectedArcminutes = 2.15;
		equal(withinRange(resultArcminutes, expectedArcminutes, 0.01), true, 'refraction in arcminutes should be ' + expectedArcminutes + ', is ' + resultArcminutes);		
	});
	
	QUnit.test('calcRefractionFromTrue', function () {
	    var trueElevationDegrees = 1,
		    resultRad = calcRefractionFromTrue(trueElevationDegrees),
		    resultArcminutes = resultRad / uom.arcminToRad,
		    expectedArcminutes = 26.25;
		equal(withinRange(resultArcminutes, expectedArcminutes, 0.01), true, 'refraction in arcminutes should be ' + expectedArcminutes + ', is ' + resultArcminutes);		
	});
	
	QUnit.test('calcRefractionFromApparent', function () {
	    var apparentElevationDegrees = 25 + 2.15 / 60,
		    resultRad = calcRefractionFromApparent(apparentElevationDegrees),
		    resultArcminutes = resultRad / uom.arcminToRad,
		    expectedArcminutes = 2.15;
		equal(withinRange(resultArcminutes, expectedArcminutes, 0.01), true, 'refraction in arcminutes should be ' + expectedArcminutes + ', is ' + resultArcminutes);		
	});
	
	QUnit.test('calcRefractionFromApparent', function () {
	    var apparentElevationDegrees = 1 + 26.25 / 60,
		    resultRad = calcRefractionFromApparent(apparentElevationDegrees),
		    resultArcminutes = resultRad / uom.arcminToRad,
		    expectedArcminutes = 26.25;
		equal(withinRange(resultArcminutes, expectedArcminutes, 0.01), true, 'refraction in arcminutes should be ' + expectedArcminutes + ', is ' + resultArcminutes);		
	});
	
	QUnit.module('coordinate parser');
	
	function testParseCoordinateIntoStringArray(expected, inputString) {
		var ix, result = parseCoordinateIntoStringArray(inputString);
		for (ix = 0; ix < expected.length; ix++) {
			equal(result[ix], expected[ix], 'should be ' + expected[ix] + ', is ' + result[ix]); 
		}
	}
	
	QUnit.test('parseCoordinateIntoStringArray', function () {	
		testParseCoordinateIntoStringArray(['1.2', 'r'], '1.2 r');
		testParseCoordinateIntoStringArray(['-1.2', 'radians'], ' -1.2radians');
		testParseCoordinateIntoStringArray(['1', '2.3', '4'], '1:2.3:4');
		testParseCoordinateIntoStringArray(['-1', '2.3', '4'], '-1:2.3:4');
		testParseCoordinateIntoStringArray(['-1.2', 'degs', '3.4', 'mins', '5.6', 'secs'], '-1.2 degs 3.4 mins 5.6 secs');
		testParseCoordinateIntoStringArray(['00', 'h', '42', 'm', '44.30', 's'], ' 00h42m44.30s ');
		testParseCoordinateIntoStringArray(['+41', '°', '16', '\'', '10.0', '"'], '+41°16\'10.0"');
		testParseCoordinateIntoStringArray(['-10', '^', '05', '02'], '-10^05:02#');
		testParseCoordinateIntoStringArray(['123.456'], '123.456');
		testParseCoordinateIntoStringArray(['-1', '-3'], ' - 1 - 3 ');
		testParseCoordinateIntoStringArray(['-1', '--3'], ' - 1 - -3 ');
		testParseCoordinateIntoStringArray(['-1', '-', 'mins', '3'], ' - 1 - mins 3 ');
		testParseCoordinateIntoStringArray(['-0', '°', '16', '\'', '10.0', '"'], '- 0°16\'10.0"');
	});
	
	function testParseCoordinate(expected, inputString, useHours) {
		var ix, result = parseCoordinate(inputString, useHours).values;
		for (ix = 0; ix < expected.length; ix++) {
			equal(result[ix], expected[ix], inputString + ' should be ' + expected[ix] + ', is ' + result[ix]);
		}
	}
	
	function testParseCoordinateError(expected, inputString, useHours) {
		var result = parseCoordinate(inputString, useHours).errors;
		equal(result, expected, inputString + ' error ' + expected + ', is ' + result);
	}
	
	QUnit.test('parseCoordinate', function () {
		testParseCoordinate([undefined, undefined, 1, 2, 3], '1 2 3');
		testParseCoordinate([undefined, undefined, 1, 2, 3], '1d 2m 3s');
		testParseCoordinate([undefined, 1, undefined, 2, 3], '1h 2m 3s');
		testParseCoordinate([undefined, undefined, 1, 2, 3], '3s 2m 1d');
		testParseCoordinate([undefined, 1, undefined, 2, 3], '1h 2 3');
		testParseCoordinate([undefined, undefined, 1, 2, 3], '1 d 2 3');
		testParseCoordinate([undefined, undefined, 1, 2, 3], '1° 2\' 3"');
		testParseCoordinate([undefined, undefined, 1, 2, 3], '1:2:3');
		testParseCoordinate([undefined, undefined, 1.2, 3.4, 5.6], '1.2 3.4 5.6');
		testParseCoordinate([undefined, undefined, -1.2, -3.4, -5.6], ' -1.2 -3.4 - 5.6');
		testParseCoordinate([undefined, 0, undefined, 42, 44.3], '00h42m44.30s');
		testParseCoordinate([undefined, undefined, 41, 16, 10], '+41°16\'10.0"');
		testParseCoordinate([undefined, undefined, 41, 16, 10], '+41^16\'10.0"');
		testParseCoordinate([undefined, undefined, 1.2, 3.4, 5.6], ' +1.2 +3.4 + 5.6');
		testParseCoordinate([undefined, undefined, 1, 12, 30], '1 12 +30');		
		testParseCoordinate([undefined, undefined, -1, 12, 30], '-1 12 +30');
		testParseCoordinate([undefined, undefined, 1, 2, undefined], '1 2');
		testParseCoordinate([undefined, undefined, 1.2, 12, undefined], '+1.2 12');		
		testParseCoordinate([undefined, undefined, 1.2, 12, undefined], '+1.2:12');
		testParseCoordinate([undefined, undefined, 5, 2, undefined], '05:02#');
		testParseCoordinate([undefined, undefined, -10, 5, 2], '-10^05:02#');
		testParseCoordinate([undefined, undefined, -10, 5.5, undefined], '-10^05.5#');
		testParseCoordinate([undefined, undefined, -0, 5, 2], '- 0^05:02#');
		testParseCoordinate([1, undefined, undefined, undefined, undefined], '1 rad');
		testParseCoordinate([undefined, undefined, -1.2, undefined, undefined], '- 1.2');
		testParseCoordinate([undefined, undefined, 3, undefined, undefined], '1d 2d');
		testParseCoordinate([undefined, undefined, undefined, undefined, 3], '1s 2s');
		testParseCoordinate([undefined, undefined, 2, undefined, 1], '1s 2');
		testParseCoordinate([undefined, undefined, 2, 4, 6], '1 2 3 1d 2m 3s');
		testParseCoordinate([undefined, 1, undefined, 2, 3], '1 2 3', true);
		testParseCoordinate([undefined, undefined, 1, 2, 3], '1 2 3', false);
		testParseCoordinate([undefined, 1, undefined, 2, 3], '1:2:3', true);
		testParseCoordinate([undefined, undefined, 1, 2, 3], '1:2:3', false);
		testParseCoordinate([undefined, 0, undefined, 0, 0], '00.0:00.0:00.0', true);
		testParseCoordinate([undefined, undefined, 0, 2, 3], '0:2:3');
		testParseCoordinateError('I do not know what to do with \'4\'', '1 2 3 4');
		testParseCoordinateError('I do not know what to do with \'1 x\'', '1 x 2 3');
		testParseCoordinateError('I do not know what to do with \'1 x\'', '1x2 3');
	});
	
	QUnit.test('parseCoordinateGetValueInRadians', function () {
		var input, expected, results;
		
		input = '1 radians';
		expected = 1;
		results = parseCoordinateGetValueInRadians(input).radians;
		equal(results, expected, input);

		input = '1 rad';
		expected = 1;
		results = parseCoordinateGetValueInRadians(input).radians;
		equal(results, expected, input);

		input = '1r';
		expected = 1;
		results = parseCoordinateGetValueInRadians(input).radians;
		equal(results, expected, input);

		input = '1:2:3';
		expected = uom.degToRad + 2 * uom.arcminToRad + 3 * uom.arcsecToRad;
		results = parseCoordinateGetValueInRadians(input).radians;
		equal(results, expected, input);

		input = '1h 2 3';
		expected = uom.hrToRad + 2 * uom.minToRad + 3 * uom.secToRad;
		results = parseCoordinateGetValueInRadians(input).radians;
		equal(results, expected, input);

		input = '1 2 3';
		expected = uom.hrToRad + 2 * uom.minToRad + 3 * uom.secToRad;
		results = parseCoordinateGetValueInRadians(input, true).radians;
		equal(results, expected, input);

		input = '1d 2m 3s';
		expected = uom.degToRad + 2 * uom.arcminToRad + 3 * uom.arcsecToRad;
		results = parseCoordinateGetValueInRadians(input).radians;
		equal(results, expected, input);

		input = '1.1 2.2 3.3';
		expected = 1.1 * uom.hrToRad + 2.2 * uom.minToRad + 3.3 * uom.secToRad;
		results = parseCoordinateGetValueInRadians(input, true).radians;
		equal(results, expected, input);

		input = '-1.1 -2.2 -3.3';
		expected = -1.1 * uom.hrToRad + -2.2 * uom.minToRad + -3.3 * uom.secToRad;
		results = parseCoordinateGetValueInRadians(input, true).radians;
		equal(results, expected, input);

		input = '+10:05:02';
		expected = 10 * uom.degToRad + 5 * uom.arcminToRad + 2 * uom.arcsecToRad;
		results = parseCoordinateGetValueInRadians(input).radians;
		equal(results, expected, input);

		input = '-10:05:02';
		expected = -10 * uom.degToRad + -5 * uom.arcminToRad + -2 * uom.arcsecToRad;
		results = parseCoordinateGetValueInRadians(input).radians;
		equal(results, expected, input);

		input = '+10:05:02';
		expected = 10 * uom.hrToRad + 5 * uom.minToRad + 2 * uom.secToRad;
		results = parseCoordinateGetValueInRadians(input, true).radians;
		equal(results, expected, input);

		input = '05:06:17#';
		expected = 5 * uom.hrToRad + 6 * uom.minToRad + 17 * uom.secToRad;
		results = parseCoordinateGetValueInRadians(input, true).radians;
		equal(results, expected, input);

		input = '+10:06#';
		expected = 10 * uom.degToRad + 6 * uom.arcminToRad;
		results = parseCoordinateGetValueInRadians(input).radians;
		equal(results, expected, input);

		input = '-08°12\'16.2"';
		expected = -8 * uom.degToRad + -12 * uom.arcminToRad + -16.2 * uom.arcsecToRad;
		results = parseCoordinateGetValueInRadians(input).radians;
		equal(results, expected, input);

		input = '- 0:05:02';
		expected = -0 * uom.degToRad + -5 * uom.arcminToRad + -2 * uom.arcsecToRad;
		results = parseCoordinateGetValueInRadians(input).radians;
		equal(results, expected, input);

		input = '-  0:05:02';
		expected = -0 * uom.degToRad + -5 * uom.arcminToRad + -2 * uom.arcsecToRad;
		results = parseCoordinateGetValueInRadians(input).radians;
		equal(results, expected, input);
	});
	
	QUnit.test('parse coordinates round trip', function () {
		var input = '-08°12\'16.2"',
		expected = '-  8°12\'16.200"',
		result = convertDMSMToString(convertRadToDMSM(parseCoordinateGetValueInRadians(input).radians));
		equal(result, expected, 'input is ' + input + ', expected is ' + expected + ', result is ' + result);
	});
	
	QUnit.test('parse coordinates round trip', function () {
		var input = '1h 2 3',
		expected = ' 1:02:03.000',
		result = convertHMSMToString(convertRadToHMSM(parseCoordinateGetValueInRadians(input).radians));
		equal(result, expected, 'input is ' + input + ', expected is ' + expected + ', result is ' + result);
	});
	
	QUnit.test('parse coordinates round trip', function () {
		var input = '0h 2 3',
		expected = ' 0:02:03.000',
		result = convertHMSMToString(convertRadToHMSM(parseCoordinateGetValueInRadians(input).radians));
		equal(result, expected, 'input is ' + input + ', expected is ' + expected + ', result is ' + result);
	});

	QUnit.module('position');
	
	function testSetPositionDegFromString(position) {
		equal(position.RA / uom.degToRad, 0.1, 'RA');
		equal(position.Dec / uom.degToRad, 2, 'Dec');
		equal(position.az / uom.degToRad, 3.3, 'az');
		equal(position.alt / uom.degToRad, 4, 'alt');
		equal(position.SidT / uom.degToRad, 0.5, 'SidT');
	}
	
	function testSetPositionDegFromStringNegativeNumbers(position) {
		equal(position.RA / uom.degToRad, -0.1, 'RA');
		equal(position.Dec / uom.degToRad, -2, 'Dec');
		equal(position.az / uom.degToRad, -3.3, 'az');
		equal(position.alt / uom.degToRad, -4, 'alt');
		equal(position.SidT / uom.degToRad, -0.5, 'SidT');
	}
	
	QUnit.test('setPositionDegFromString', function () {
		var position = new Position();

		setPositionDegFromString('.1 2 3.3 4 0.5', position);
		testSetPositionDegFromString(position);
		setPositionDegFromString('RA:.1 Dec:2 az:3.3 alt:4 SidT:0.5', position);
		testSetPositionDegFromString(position);
		setPositionDegFromString('RA: .1  Dec: 2  az: 3.3  alt: 4  SidT: 0.5 ', position);
		testSetPositionDegFromString(position);
	});
	
	QUnit.test('testSetPositionDegFromStringNegativeNumbers', function () {
		var position = new Position();

		setPositionDegFromString('-.1 -2 -3.3 -4 -0.5', position);
		testSetPositionDegFromStringNegativeNumbers(position);
		setPositionDegFromString('RA:-.1 Dec:-2 az:-3.3 alt:-4 SidT:-0.5', position);
		testSetPositionDegFromStringNegativeNumbers(position);
		setPositionDegFromString('RA: -.1  Dec: -2  az: -3.3  alt: -4  SidT: -0.5 ', position);
		testSetPositionDegFromStringNegativeNumbers(position);
	});
	
	QUnit.test('isValidPosition', function () {
		var position = new Position();

		equal(isValidPosition(position), false, 'not a valid position');
		position.RA = '';
		equal(isValidPosition(position), false, 'not a valid position');
		position.RA = 'undefined';
		equal(isValidPosition(position), false, 'not a valid position');
		position.RA = 'foo';
		equal(isValidPosition(position), false, 'not a valid position');
	});
	
	QUnit.module('flipAltazAcrossPole');

	QUnit.test('flipAltazAcrossPole', function () {
		var position, expectedAzDeg, expectedAz, expectedAltDeg, expectedAlt;

		position = new Position();
		setPositionDeg(0, 0, 90, 45, 0, 0, position);
		flipAltazAcrossPole(position);
		expectedAzDeg = 270;
		expectedAz = expectedAzDeg * uom.degToRad;
		equal(position.az, expectedAz, 'translated az (deg) should be ' + expectedAzDeg + ', is ' + position.az / uom.degToRad);
		expectedAltDeg = 135;
		expectedAlt = expectedAltDeg * uom.degToRad;
		equal(position.alt, expectedAlt, 'translated az (deg) should be ' + expectedAltDeg + ', is ' + position.alt / uom.degToRad);
	});
	
	QUnit.module('meridianFlip');

	QUnit.test('calcMeridianFlipFromCurrentAltaz', function () {
		var position, fabErrors, flipped, expectedFlip;

		position = new Position();
		fabErrors = new FabErrors();
		setPositionDeg(0, 0, 0, 45, 0, 0, position);
		flipped = calcMeridianFlipFromCurrentAltaz(position, fabErrors);
		expectedFlip = false;
		equal(flipped, expectedFlip, 'flipped should be ' + expectedFlip + ', is ' + flipped);

		setPositionDeg(0, 0, 0, 135, 0, 0, position);
		flipped = calcMeridianFlipFromCurrentAltaz(position, fabErrors);
		expectedFlip = true;
		equal(flipped, expectedFlip, 'flipped should be ' + expectedFlip + ', is ' + flipped);
	});

	QUnit.test('setFlipState, isFlipped', function () {
		var meridianFlip = new MeridianFlip();
		meridianFlip.canFlip = true;
		equal(isFlipped(meridianFlip), false, 'flipped should be false');
		setFlipState(true, meridianFlip);
		equal(isFlipped(meridianFlip), true, 'flipped should be true');
	});
	
	QUnit.test('translateAltazAcrossPoleBasedOnMeridianFlip', function () {
		var meridianFlip, position, expectedAzDeg, expectedAz, expectedAltDeg, expectedAlt;

		meridianFlip = new MeridianFlip();
		meridianFlip.canFlip = true;
		setFlipState(true, meridianFlip);
		equal(isFlipped(meridianFlip), true, 'flipped should be true');

		position = new Position();
		setPositionDeg(0, 0, 270, 135, 0, 0, position);
		translateAltazAcrossPoleBasedOnMeridianFlip(position, meridianFlip);
		expectedAzDeg = 90;
		expectedAz = expectedAzDeg * uom.degToRad;
		equal(position.az, expectedAz, 'translated az (deg) should be ' + expectedAzDeg + ', is ' + position.az / uom.degToRad);
		expectedAltDeg = 45;
		expectedAlt = expectedAltDeg * uom.degToRad;
		equal(position.alt, expectedAlt, 'translated az (deg) should be ' + expectedAltDeg + ', is ' + position.alt / uom.degToRad);
	});

	QUnit.module('convertTrig');
	
	QUnit.test('from Peter Duffet-Smith Practical Astronomy With Your Calculator', function () {
		var latitudeDeg, latitudeRad, meridianFlip, position, sidThrs, HAhrs, degreesPerHr, RAdeg, DecDeg, sidTdeg, allowedErrorArcsecond, allowedErrorDeg, expectedAzDeg, resultAzDeg, expectedAltDeg, resultAltDeg, resultRADeg, resultDecDeg;

		latitudeDeg = 52;
		latitudeRad = latitudeDeg * uom.degToRad;
		meridianFlip = new MeridianFlip();
		position = new Position();
		// HA=LST-RA, so RA=LST-HA (+HA==west of meridian)
		sidThrs = 12;
		HAhrs =  5.862269;
		degreesPerHr = 15;
		RAdeg = (sidThrs - HAhrs) * degreesPerHr;
		DecDeg = 23.219444;
		sidTdeg = sidThrs * degreesPerHr;
		setPositionDeg(RAdeg, DecDeg, 0, 0, sidTdeg, 0, position);
		allowedErrorArcsecond = 0.05;
		allowedErrorDeg = allowedErrorArcsecond / 3600;

		getAltazTrig(position, meridianFlip, latitudeRad);
		expectedAzDeg = 283.271558;
		resultAzDeg = position.az / uom.degToRad;
		equal(withinRange(resultAzDeg, expectedAzDeg, allowedErrorDeg), true, 'az (deg) should be ' + expectedAzDeg + ', is ' + resultAzDeg);
		expectedAltDeg = 19.333925;
		resultAltDeg = position.alt / uom.degToRad;
		equal(withinRange(resultAltDeg, expectedAltDeg, allowedErrorDeg), true, 'alt (deg) should be ' + expectedAltDeg + ', is ' + resultAltDeg);
		
		setPositionDeg(0, 0, expectedAzDeg, expectedAltDeg, sidTdeg, 0, position);
		getEquatTrig(position, meridianFlip, latitudeRad);
		resultRADeg = position.RA / uom.degToRad;
		equal(withinRange(resultRADeg, RAdeg, allowedErrorDeg), true, 'RA (deg) should be ' + RAdeg + ', is ' + resultRADeg);
		resultDecDeg = position.Dec / uom.degToRad;
		equal(withinRange(resultDecDeg, DecDeg, allowedErrorDeg), true, 'Dec (deg) should be ' + DecDeg + ', is ' + resultDecDeg);		
	});

	QUnit.test('northern hemisphere: altazimuth alignment, latitude = 45 deg, facing directly east on horizon (az=270): on celestial meridian, 6 hr east of meridian', function () {
		var latitudeDeg, latitudeRad, meridianFlip, position, sidThrs, HAhrs, degreesPerHr, RAdeg, DecDeg, sidTdeg, allowedErrorArcsecond, allowedErrorDeg, expectedAzDeg, resultAzDeg, expectedAltDeg, resultAltDeg;

		latitudeDeg = 45;
		latitudeRad = latitudeDeg * uom.degToRad;
		meridianFlip = new MeridianFlip();
		position = new Position();
		// HA=LST-RA, so RA=LST-HA (+HA==west of meridian)
		sidThrs = 12;
		HAhrs = 6;
		degreesPerHr = 15;
		RAdeg = (sidThrs + HAhrs) * degreesPerHr;
		DecDeg = 0;
		sidTdeg = sidThrs * degreesPerHr;
		setPositionDeg(RAdeg, DecDeg, 0, 0, sidTdeg, 0, position);
		allowedErrorArcsecond = 0.05;
		allowedErrorDeg = allowedErrorArcsecond / 3600;

		getAltazTrig(position, meridianFlip, latitudeRad);
		expectedAzDeg = 90;
		resultAzDeg = position.az / uom.degToRad;
		equal(withinRange(resultAzDeg, expectedAzDeg, allowedErrorDeg), true, 'az (deg) should be ' + expectedAzDeg + ', is ' + resultAzDeg);
		expectedAltDeg = 0;
		resultAltDeg = position.alt / uom.degToRad;
		equal(withinRange(resultAltDeg, expectedAltDeg, allowedErrorDeg), true, 'alt (deg) should be ' + expectedAltDeg + ', is ' + resultAltDeg);
	});

	QUnit.test('northern hemisphere: altazimuth alignment, latitude = 45 deg, facing directly south on horizon (az=180): on celestial meridian', function () {
		var latitudeDeg, latitudeRad, meridianFlip, position, sidThrs, HAhrs, degreesPerHr, RAdeg, DecDeg, sidTdeg, allowedErrorArcsecond, allowedErrorDeg, expectedAzDeg, resultAzDeg, expectedAltDeg, resultAltDeg;

		latitudeDeg = 45;
		latitudeRad = latitudeDeg * uom.degToRad;
		meridianFlip = new MeridianFlip();
		position = new Position();
		// HA=LST-RA, so RA=LST-HA (+HA==west of meridian)
		sidThrs = 12;
		HAhrs = 0;
		degreesPerHr = 15;
		RAdeg = (sidThrs + HAhrs) * degreesPerHr;
		DecDeg = 0;
		sidTdeg = sidThrs * degreesPerHr;
		setPositionDeg(RAdeg, DecDeg, 0, 0, sidTdeg, 0, position);
		allowedErrorArcsecond = 0.05;
		allowedErrorDeg = allowedErrorArcsecond / 3600;

		getAltazTrig(position, meridianFlip, latitudeRad);
		expectedAzDeg = 180;
		resultAzDeg = position.az / uom.degToRad;
		equal(withinRange(resultAzDeg, expectedAzDeg, allowedErrorDeg), true, 'az (deg) should be ' + expectedAzDeg + ', is ' + resultAzDeg);
		expectedAltDeg = 90 - latitudeDeg;
		resultAltDeg = position.alt / uom.degToRad;
		equal(withinRange(resultAltDeg, expectedAltDeg, allowedErrorDeg), true, 'alt (deg) should be ' + expectedAltDeg + ', is ' + resultAltDeg);
	});

	QUnit.test('northern hemisphere: altazimuth alignment, latitude = 45 deg, facing directly west on horizon (az=90): on celestial meridian, 6 hr west of meridian', function () {
		var latitudeDeg, latitudeRad, meridianFlip, position, sidThrs, HAhrs, degreesPerHr, RAdeg, DecDeg, sidTdeg, allowedErrorArcsecond, allowedErrorDeg, expectedAzDeg, resultAzDeg, expectedAltDeg, resultAltDeg;

		latitudeDeg = 45;
		latitudeRad = latitudeDeg * uom.degToRad;
		meridianFlip = new MeridianFlip();
		position = new Position();
		// HA=LST-RA, so RA=LST-HA (+HA==west of meridian)
		sidThrs = 12;
		HAhrs = -6;
		degreesPerHr = 15;
		RAdeg = (sidThrs + HAhrs) * degreesPerHr;
		DecDeg = 0;
		sidTdeg = sidThrs * degreesPerHr;
		setPositionDeg(RAdeg, DecDeg, 0, 0, sidTdeg, 0, position);
		allowedErrorArcsecond = 0.05;
		allowedErrorDeg = allowedErrorArcsecond / 3600;

		getAltazTrig(position, meridianFlip, latitudeRad);
		expectedAzDeg = 270;
		resultAzDeg = position.az / uom.degToRad;
		equal(withinRange(resultAzDeg, expectedAzDeg, allowedErrorDeg), true, 'az (deg) should be ' + expectedAzDeg + ', is ' + resultAzDeg);
		expectedAltDeg = 0;
		resultAltDeg = position.alt / uom.degToRad;
		equal(withinRange(resultAltDeg, expectedAltDeg, allowedErrorDeg), true, 'alt (deg) should be ' + expectedAltDeg + ', is ' + resultAltDeg);
	});

	QUnit.test('southern hemisphere: altazimuth alignment, latitude = -45 deg, facing directly east on horizon (az=270): on celestial meridian, 6 hr east of meridian', function () {
		var latitudeDeg, latitudeRad, meridianFlip, position, sidThrs, HAhrs, degreesPerHr, RAdeg, DecDeg, sidTdeg, allowedErrorArcsecond, allowedErrorDeg, expectedAzDeg, resultAzDeg, expectedAltDeg, resultAltDeg;

		latitudeDeg = -45;
		latitudeRad = latitudeDeg * uom.degToRad;
		meridianFlip = new MeridianFlip();
		position = new Position();
		// HA=LST-RA, so RA=LST-HA (+HA==west of meridian)
		sidThrs = 12;
		HAhrs = 6;
		degreesPerHr = 15;
		RAdeg = (sidThrs + HAhrs) * degreesPerHr;
		DecDeg = 0;
		sidTdeg = sidThrs * degreesPerHr;
		setPositionDeg(RAdeg, DecDeg, 0, 0, sidTdeg, 0, position);
		allowedErrorArcsecond = 0.05;
		allowedErrorDeg = allowedErrorArcsecond / 3600;

		getAltazTrig(position, meridianFlip, latitudeRad);
		expectedAzDeg = 270;
		resultAzDeg = position.az / uom.degToRad;
		equal(withinRange(resultAzDeg, expectedAzDeg, allowedErrorDeg), true, 'az (deg) should be ' + expectedAzDeg + ', is ' + resultAzDeg);
		expectedAltDeg = 0;
		resultAltDeg = position.alt / uom.degToRad;
		equal(withinRange(resultAltDeg, expectedAltDeg, allowedErrorDeg), true, 'alt (deg) should be ' + expectedAltDeg + ', is ' + resultAltDeg);
	});

	QUnit.test('southern hemisphere: altazimuth alignment, latitude = -45 deg, facing directly north on horizion (az=180): on celestial meridian', function () {
		var latitudeDeg, latitudeRad, meridianFlip, position, sidThrs, HAhrs, degreesPerHr, RAdeg, DecDeg, sidTdeg, allowedErrorArcsecond, allowedErrorDeg, expectedAzDeg, resultAzDeg, expectedAltDeg, resultAltDeg;

		latitudeDeg = -45;
		latitudeRad = latitudeDeg * uom.degToRad;
		meridianFlip = new MeridianFlip();
		position = new Position();
		// HA=LST-RA, so RA=LST-HA (+HA==west of meridian)
		sidThrs = 12;
		HAhrs = 0;
		degreesPerHr = 15;
		RAdeg = (sidThrs + HAhrs) * degreesPerHr;
		DecDeg = 0;
		sidTdeg = sidThrs * degreesPerHr;
		setPositionDeg(RAdeg, DecDeg, 0, 0, sidTdeg, 0, position);
		allowedErrorArcsecond = 0.05;
		allowedErrorDeg = allowedErrorArcsecond / 3600;

		getAltazTrig(position, meridianFlip, latitudeRad);
		expectedAzDeg = 180;
		resultAzDeg = position.az / uom.degToRad;
		equal(withinRange(resultAzDeg, expectedAzDeg, allowedErrorDeg), true, 'az (deg) should be ' + expectedAzDeg + ', is ' + resultAzDeg);
		expectedAltDeg = 90 + latitudeDeg;
		resultAltDeg = position.alt / uom.degToRad;
		equal(withinRange(resultAltDeg, expectedAltDeg, allowedErrorDeg), true, 'alt (deg) should be ' + expectedAltDeg + ', is ' + resultAltDeg);
	});

	QUnit.test('southern hemisphere: altazimuth alignment, latitude = -45 deg, facing directly west on horizon (az=90): on celestial meridian, 6 hr west of meridian', function () {
		var latitudeDeg, latitudeRad, meridianFlip, position, sidThrs, HAhrs, degreesPerHr, RAdeg, DecDeg, sidTdeg, allowedErrorArcsecond, allowedErrorDeg, expectedAzDeg, resultAzDeg, expectedAltDeg, resultAltDeg;

		latitudeDeg = -45;
		latitudeRad = latitudeDeg * uom.degToRad;
		meridianFlip = new MeridianFlip();
		position = new Position();
		// HA=LST-RA, so RA=LST-HA (+HA==west of meridian)
		sidThrs = 12;
		HAhrs = -6;
		degreesPerHr = 15;
		RAdeg = (sidThrs + HAhrs) * degreesPerHr;
		DecDeg = 0;
		sidTdeg = sidThrs * degreesPerHr;
		setPositionDeg(RAdeg, DecDeg, 0, 0, sidTdeg, 0, position);
		allowedErrorArcsecond = 0.05;
		allowedErrorDeg = allowedErrorArcsecond / 3600;

		getAltazTrig(position, meridianFlip, latitudeRad);
		expectedAzDeg = 90;
		resultAzDeg = position.az / uom.degToRad;
		equal(withinRange(resultAzDeg, expectedAzDeg, allowedErrorDeg), true, 'az (deg) should be ' + expectedAzDeg + ', is ' + resultAzDeg);
		expectedAltDeg = 0;
		resultAltDeg = position.alt / uom.degToRad;
		equal(withinRange(resultAltDeg, expectedAltDeg, allowedErrorDeg), true, 'alt (deg) should be ' + expectedAltDeg + ', is ' + resultAltDeg);
	});
	
	QUnit.module('create2DArray');
	
	QUnit.test('create2DArray', function () {
		var dimen, a, count, i, j, expectedDimen;
		
		dimen = 3;
		a = create2DArray(dimen);

		// fill array of arrays
		count = 0;
		for (i = 0; i < dimen; i++) {
			for (j = 0; j < dimen; j++) {
				a[i][j] = count++;
			}
		}
		expectedDimen = dimen * dimen;
		equal(count, expectedDimen, 'count of cells should be ' + expectedDimen + ', is ' + count); 

		equal(a.length, dimen, 'checking array length');
		for (i = 0; i < dimen; i++) {
			equal(a[i].length, dimen, 'checking array length');
		}
	});
	
	QUnit.module('ConvertMatrix');
	
	QUnit.test('constructor', function () {
		var cmws = new ConvertMatrixWorkingStorage();
		equal(cmws, cmws, 'ConvertMatrix successfully constructed');
	});

	function initTaki(cmws) {
		setPositionDeg(79.172, 45.998, 360 - 39.9, 39.9, 39.2 * uom.sidRate / 4, 0, cmws.current);
        initMatrix(1, cmws);
        setPositionDeg(37.96, 89.264, 360 - 94.6, 36.2, 40.3 * uom.sidRate / 4, 0, cmws.current);
        initMatrix(2, cmws);
	}
	
	// from Toshimi Taki's test data, Sky and Telescope magazine, February 1989 (az direction reversed)
	// Taki rounded his results to 0.01 degree; more precise numbers taken from earlier incantations of the code (C, C++, VB.Net, CSharp.Net)
	QUnit.test('getAltazMatrix(), getEquatMatrix() for all ConvertSubroutineTypes', function () {
		// init
		var cmws, allowedTakiErrorDeg, allowedErrorDeg;
		
		cmws = new ConvertMatrixWorkingStorage();
		setFabErrorsDeg(-0.04, 0.4, -1.63, cmws.fabErrors);
		initTaki(cmws);
		allowedTakiErrorDeg = 0.01;
		// 1 arcsecond
		allowedErrorDeg = 1 / 3600;
		
		// try all the different routines that calculate FabErrors Z123; default is BellTaki
		testConvertMatrix(ConvertSubroutineType.TakiSimple, allowedTakiErrorDeg, allowedErrorDeg, cmws);
		testConvertMatrix(ConvertSubroutineType.TakiSmallAngle, allowedTakiErrorDeg, allowedErrorDeg, cmws);
		testConvertMatrix(ConvertSubroutineType.TakiIterative, allowedTakiErrorDeg, allowedErrorDeg, cmws);
		testConvertMatrix(ConvertSubroutineType.BellIterative, allowedTakiErrorDeg, allowedErrorDeg, cmws);
		testConvertMatrix(ConvertSubroutineType.BellTaki, allowedTakiErrorDeg, allowedErrorDeg, cmws);
	});

	function testConvertMatrix(convertSubroutineType, allowedTakiErrorDeg, allowedErrorDeg, cmws) {
		var expectedTakiAltDeg, expectedTakiAzDeg, expectedAltDeg, expectedAzDeg, resultAltDeg, resultAzDeg, expectedTakiRADeg, expectedTakiDecDeg, expectedRADeg, expectedDecDeg, resultRADeg, resultDecDeg;

		cmws.convertSubroutineType = convertSubroutineType;

		// first getAltazMatrix()
		
        setPositionDeg(326.05, 9.88, 0, 0, 47 * uom.sidRate / 4, 0, cmws.current);
        getAltazMatrix(cmws);
		expectedTakiAltDeg = 42.16;
        expectedTakiAzDeg = 360 - 202.54;
		expectedAltDeg = 42.16779582589686;
		expectedAzDeg = 157.461385271071;
		resultAltDeg = cmws.current.alt / uom.degToRad;
		resultAzDeg = cmws.current.az / uom.degToRad;

		equal(withinRange(resultAltDeg, expectedTakiAltDeg, allowedTakiErrorDeg), true, 'alt (deg) should be ' + expectedTakiAltDeg + ', is ' + resultAltDeg);
		equal(withinRange(resultAzDeg, expectedTakiAzDeg, allowedTakiErrorDeg), true, 'az (deg) should be ' + expectedTakiAzDeg + ', is ' + resultAzDeg);

		equal(withinRange(resultAltDeg, expectedAltDeg, allowedErrorDeg), true, 'alt (deg) should be ' + expectedAltDeg + ', is ' + resultAltDeg);
		equal(withinRange(resultAzDeg, expectedAzDeg, allowedErrorDeg), true, 'az (deg) should be ' + expectedAzDeg + ', is ' + resultAzDeg);
	
		// second getAltazMatrix()

		setPositionDeg(71.53, 17.07, 0, 0, 62 * uom.sidRate / 4, 0, cmws.current);
        getAltazMatrix(cmws);
		expectedTakiAltDeg = 40.31;
        expectedTakiAzDeg = 360 - 359.98;
		expectedAltDeg = 40.311439473946635;
		expectedAzDeg = 0.014615727197751146;
		resultAltDeg = cmws.current.alt / uom.degToRad;
		resultAzDeg = cmws.current.az / uom.degToRad;

		equal(withinRange(resultAltDeg, expectedTakiAltDeg, allowedTakiErrorDeg), true, 'alt (deg) should be ' + expectedTakiAltDeg + ', is ' + resultAltDeg);
		equal(withinRange(resultAzDeg, expectedTakiAzDeg, allowedTakiErrorDeg), true, 'az (deg) should be ' + expectedTakiAzDeg + ', is ' + resultAzDeg);

		equal(withinRange(resultAltDeg, expectedAltDeg, allowedErrorDeg), true, 'alt (deg) should be ' + expectedAltDeg + ', is ' + resultAltDeg);
		equal(withinRange(resultAzDeg, expectedAzDeg, allowedErrorDeg), true, 'az (deg) should be ' + expectedAzDeg + ', is ' + resultAzDeg);

		// getEquatMatrix()

        setPositionDeg(0, 0, 360 - 24.1, 35.5, 71.9 * uom.sidRate / 4, 0, cmws.current);
        getEquatMatrix(cmws);
		expectedTakiRADeg = 87.99;
		expectedTakiDecDeg = 32.51;
		expectedRADeg = 87.99250209468218;
		expectedDecDeg = 32.505411466033848;
		resultRADeg = cmws.current.RA / uom.degToRad;
		resultDecDeg = cmws.current.Dec / uom.degToRad;

		equal(withinRange(resultRADeg, expectedTakiRADeg, allowedTakiErrorDeg), true, 'RA (deg) should be ' + expectedTakiRADeg + ', is ' + resultRADeg);
		equal(withinRange(expectedTakiDecDeg, expectedTakiDecDeg, allowedTakiErrorDeg), true, 'Dec (deg) should be ' + expectedTakiDecDeg + ', is ' + resultDecDeg);

		equal(withinRange(resultRADeg, expectedRADeg, allowedErrorDeg), true, 'RA (deg) should be ' + expectedRADeg + ', is ' + resultRADeg);
		equal(withinRange(expectedDecDeg, expectedDecDeg, allowedErrorDeg), true, 'Dec (deg) should be ' + expectedDecDeg + ', is ' + resultDecDeg);
	}
	
	QUnit.module('preset initializations');
	
	function testGetAltaz(latitude, RA, Dec, azDeg, altDeg, allowedErrorDeg, cmws, position, meridianFlip) {
		var resultAzDeg, resultAltDeg;
		
		// matrix
		cmws.current.RA = RA;
		cmws.current.Dec = Dec;
		cmws.current.az = 0;
		cmws.current.alt = 0;
		getAltazMatrix(cmws);
		resultAzDeg = cmws.current.az / uom.degToRad;
		resultAltDeg = cmws.current.alt / uom.degToRad;
		equal(withinRange(resultAltDeg, altDeg, allowedErrorDeg), true, 'matrix alt (deg) should be ' + altDeg + ', is ' + resultAltDeg);
		equal(withinRange(resultAzDeg, azDeg, allowedErrorDeg), true, 'matrix az (deg) should be ' + azDeg + ', is ' + resultAzDeg);
		// trig
		copyPosition(cmws.current, position);
		position.az = 0;
		position.alt = 0;
		getAltazTrig(position, meridianFlip, latitude);
		resultAzDeg = position.az / uom.degToRad;
		resultAltDeg = position.alt / uom.degToRad;
		equal(withinRange(resultAltDeg, altDeg, allowedErrorDeg), true, 'trig alt (deg) should be ' + altDeg + ', is ' + resultAltDeg);
		equal(withinRange(resultAzDeg, azDeg, allowedErrorDeg), true, 'trig az (deg) should be ' + azDeg + ', is ' + resultAzDeg);	
	}

	function testGetEquat(latitude, az, alt, RADeg, DecDeg, allowedErrorDeg, cmws, position, meridianFlip) {
		var resultRADeg, resultDecDeg;
		
		// matrix
		cmws.current.az = az;
		cmws.current.alt = alt;
		cmws.current.RA = 0;
		cmws.current.Dec = 0;
		getEquatMatrix(cmws);
		resultRADeg = cmws.current.RA / uom.degToRad;
		resultDecDeg = cmws.current.Dec / uom.degToRad;
		equal(withinRange(resultDecDeg, DecDeg, allowedErrorDeg), true, 'matrix Dec (deg) should be ' + DecDeg + ', is ' + resultDecDeg);
		equal(withinRange(resultRADeg, RADeg, allowedErrorDeg), true, 'matrix RA (deg) should be ' + RADeg + ', is ' + resultRADeg);
		// trig
		copyPosition(cmws.current, position);
		position.RA = 0;
		position.Dec = 0;
		getEquatTrig(position, meridianFlip, latitude);
		resultRADeg = position.RA / uom.degToRad;
		resultDecDeg = position.Dec / uom.degToRad;
		equal(withinRange(resultDecDeg, DecDeg, allowedErrorDeg), true, 'trig Dec (deg) should be ' + DecDeg + ', is ' + resultDecDeg);
		equal(withinRange(resultRADeg, RADeg, allowedErrorDeg), true, 'trig RA (deg) should be ' + RADeg + ', is ' + resultRADeg);	
	}

	QUnit.test('presetEquat, matrix and trig', function () {
		// 1 arcsecond
		var allowedErrorDeg = 1 / 3600,	
		    DecDeg = 10,
		    Dec = DecDeg * uom.degToRad,
		    altDeg = 10,
		    alt = altDeg * uom.degToRad,
			// matrix
		    cmws = new ConvertMatrixWorkingStorage(),
			// trig
		    position = new Position(),
		    meridianFlip = new MeridianFlip(), 

			// northern hemisphere...
		
		   latitudeRad = uom.qtrRev;
		cmws.current.SidT = uom.halfRev;
		presetEquat(Hemisphere.northern, cmws);
		equal(cmws.initType, InitType.equatorial, 'preset type should be equatorial, is ' + cmws.initType);
		
		// 10 degrees above or north of celestial equator: 1 hr east of meridian, on meridian, 1 hr west of meridian
		// RA of 210 is az of 150
		// testGetAltaz(latitude, RA, Dec, azDeg, altDeg, allowedErrorDeg, cmws, position, meridianFlip)
		testGetAltaz(latitudeRad, 210 * uom.degToRad, Dec, 150, altDeg, allowedErrorDeg, cmws, position, meridianFlip);
		testGetAltaz(latitudeRad, 180 * uom.degToRad, Dec, 180, altDeg, allowedErrorDeg, cmws, position, meridianFlip);
		testGetAltaz(latitudeRad, 150 * uom.degToRad, Dec, 210, altDeg, allowedErrorDeg, cmws, position, meridianFlip);
		
		// as above
		// testGetEquat(latitude, az, alt, RADeg, DecDeg, allowedErrorDeg, cmws, position, meridianFlip)
		testGetEquat(latitudeRad, 150 * uom.degToRad, alt, 210, DecDeg, allowedErrorDeg, cmws, position, meridianFlip);
		testGetEquat(latitudeRad, 180 * uom.degToRad, alt, 180, DecDeg, allowedErrorDeg, cmws, position, meridianFlip);
		testGetEquat(latitudeRad, 210 * uom.degToRad, alt, 150, DecDeg, allowedErrorDeg, cmws, position, meridianFlip);

		// southern hemisphere...
		
		// redo matrix initialization
		presetEquat(Hemisphere.southern, cmws);
		
		// 10 degrees above or south of celestial equator: 1 hr east of meridian, on meridian, 1 hr west of meridian
		// RA of 210 is az of 210 (azimuth is reversed compared to northern hemisphere)
		testGetAltaz(-latitudeRad, 210 * uom.degToRad, -Dec, 210, altDeg, allowedErrorDeg, cmws, position, meridianFlip);
		testGetAltaz(-latitudeRad, 180 * uom.degToRad, -Dec, 180, altDeg, allowedErrorDeg, cmws, position, meridianFlip);
		testGetAltaz(-latitudeRad, 150 * uom.degToRad, -Dec, 150, altDeg, allowedErrorDeg, cmws, position, meridianFlip);

		// as above
		testGetEquat(-latitudeRad, 210 * uom.degToRad, alt, 210, -DecDeg, allowedErrorDeg, cmws, position, meridianFlip);
		testGetEquat(-latitudeRad, 180 * uom.degToRad, alt, 180, -DecDeg, allowedErrorDeg, cmws, position, meridianFlip);
		testGetEquat(-latitudeRad, 150 * uom.degToRad, alt, 150, -DecDeg, allowedErrorDeg, cmws, position, meridianFlip);
	});

	QUnit.test('presetAltaz, matrix and trig', function () {
		// 1 arcsecond
		var allowedErrorDeg = 1 / 3600,

		    DecDeg = 10,
		    Dec = DecDeg * uom.degToRad,
		    deltaDecDeg = 3.00072743979306,
		    deltaDec = deltaDecDeg * uom.degToRad,

		    altDeg = 60,
		    alt = altDeg * uom.degToRad,

		    deltaRADeg = 14.867036822734235,
		    deltaRA = deltaRADeg * uom.degToRad,

			// matrix
		    cmws = new ConvertMatrixWorkingStorage(),
			// trig
		    position = new Position(),
		    meridianFlip = new MeridianFlip(),

			// northern hemisphere...
		
		    latitudeRad = 40 * uom.degToRad;
		cmws.current.SidT = uom.halfRev;
		presetAltaz(latitudeRad, cmws);
		equal(cmws.initType, InitType.altazimuth, 'preset type should be altazimuth, is ' + cmws.initType);
		
		// latitude of 40 degrees with 10 degrees above or north of celestial equator facing south results in 60 degrees elevation
		// testGetEquat(latitude, az, alt, RADeg, DecDeg, allowedErrorDeg, cmws, position, meridianFlip)
		testGetEquat(latitudeRad, 150 * uom.degToRad, alt, 180 + deltaRADeg, DecDeg + deltaDecDeg, allowedErrorDeg, cmws, position, meridianFlip);
		testGetEquat(latitudeRad, 180 * uom.degToRad, alt, 180, DecDeg, allowedErrorDeg, cmws, position, meridianFlip);
		testGetEquat(latitudeRad, 210 * uom.degToRad, alt, 180 - deltaRADeg, DecDeg + deltaDecDeg, allowedErrorDeg, cmws, position, meridianFlip);
		
		// as above
		// testGetAltaz(latitude, RA, Dec, azDeg, altDeg, allowedErrorDeg, cmws, position, meridianFlip)
		testGetAltaz(latitudeRad, uom.halfRev + deltaRA, Dec + deltaDec, 150, altDeg, allowedErrorDeg, cmws, position, meridianFlip);
		testGetAltaz(latitudeRad, uom.halfRev, Dec, 180, altDeg, allowedErrorDeg, cmws, position, meridianFlip);
		testGetAltaz(latitudeRad, uom.halfRev - deltaRA, Dec + deltaDec, 210, altDeg, allowedErrorDeg, cmws, position, meridianFlip);

		// southern hemisphere...
		
		// redo matrix initialization
		presetAltaz(-latitudeRad, cmws);
		
		// latitude of 40 degrees with 10 degrees above or north of celestial equator facing north results in 60 degrees elevation
		// testGetEquat(latitude, az, alt, RADeg, DecDeg, allowedErrorDeg, cmws, position, meridianFlip)
		testGetEquat(-latitudeRad, 150 * uom.degToRad, alt, 180 - deltaRADeg, -DecDeg - deltaDecDeg, allowedErrorDeg, cmws, position, meridianFlip);
		testGetEquat(-latitudeRad, 180 * uom.degToRad, alt, 180, -DecDeg, allowedErrorDeg, cmws, position, meridianFlip);
		testGetEquat(-latitudeRad, 210 * uom.degToRad, alt, 180 + deltaRADeg, -DecDeg - deltaDecDeg, allowedErrorDeg, cmws, position, meridianFlip);

		// as above
		// testGetAltaz(latitude, RA, Dec, azDeg, altDeg, allowedErrorDeg, cmws, position, meridianFlip)
		testGetAltaz(-latitudeRad, uom.halfRev - deltaRA, -Dec - deltaDec, 150, altDeg, allowedErrorDeg, cmws, position, meridianFlip);
		testGetAltaz(-latitudeRad, uom.halfRev, -Dec, 180, altDeg, allowedErrorDeg, cmws, position, meridianFlip);
		testGetAltaz(-latitudeRad, uom.halfRev + deltaRA, -Dec - deltaDec, 210, altDeg, allowedErrorDeg, cmws, position, meridianFlip);
	});
	
	QUnit.module('third init');
	
	QUnit.test('after presetAltaz() getAltaz(), then add init #3 to verify that subsequent getAltaz() returns same results; finally init #3 with corrupted position and verify that getAltaz() returns a different position', function () {
		// 1 arcsecond
		var allowedErrorDeg = 1 / 3600,
		    latitudeRad = 40 * uom.degToRad,
		    cmws = new ConvertMatrixWorkingStorage(),
			resultAzDeg,
			resultAltDeg,
			expectedAzDeg = 102.88684076912884,
			expectedAltDeg = 63.627767071865904,
			result2AzDeg,
			result2AltDeg,
			expected2AzDeg = 228.5938332933342,
			expected2AltDeg = 0.590911546276355,
			result3AzDeg,
			result3AltDeg,
			expected3AzDeg = 231.97450800138523,
			expected3AltDeg = -0.07791237522052502;

		// using the 2 inits that presetAltaz() provides, then build references positions with getAltazMatrix()
		presetAltaz(latitudeRad, cmws);
		setPositionDeg(30, 30, 0, 0, 0, 0, cmws.current);
		getAltazMatrix(cmws);
		resultAzDeg = cmws.current.az / uom.degToRad;
		resultAltDeg = cmws.current.alt / uom.degToRad;
		equal(withinRange(resultAzDeg, expectedAzDeg, allowedErrorDeg), true, 'az (deg) should be ' + expectedAzDeg + ', is ' + resultAzDeg);
		equal(withinRange(resultAltDeg, expectedAltDeg, allowedErrorDeg), true, 'alt (deg) should be ' + expectedAltDeg + ', is ' + resultAltDeg);
		setPositionDeg(300, -30, 0, 0, 0, 0, cmws.current);
		getAltazMatrix(cmws);
		result2AzDeg = cmws.current.az / uom.degToRad;
		result2AltDeg = cmws.current.alt / uom.degToRad;
		equal(withinRange(result2AzDeg, expected2AzDeg, allowedErrorDeg), true, 'az (deg) should be ' + expected2AzDeg + ', is ' + result2AzDeg);
		equal(withinRange(result2AltDeg, expected2AltDeg, allowedErrorDeg), true, 'alt (deg) should be ' + expected2AltDeg + ', is ' + result2AltDeg);

		// use 1st converted position for third init
		setPositionDeg(30, 30, expectedAzDeg, expectedAltDeg, 0, 0, cmws.three);
		initMatrixFacade(cmws, 3);
		// test 2nd converted position again
		setPositionDeg(300, -30, 0, 0, 0, 0, cmws.current);
		getAltazMatrix(cmws);
		result2AzDeg = cmws.current.az / uom.degToRad;
		result2AltDeg = cmws.current.alt / uom.degToRad;
		equal(withinRange(result2AzDeg, expected2AzDeg, allowedErrorDeg), true, 'az (deg) should match above and be ' + expected2AzDeg + ', is ' + result2AzDeg);
		equal(withinRange(result2AltDeg, expected2AltDeg, allowedErrorDeg), true, 'alt (deg) should match above and be ' + expected2AltDeg + ', is ' + result2AltDeg);

		// use corrupted 1st converted position for third init
		setPositionDeg(33, 33, expectedAzDeg, expectedAltDeg, 0, 0, cmws.three);
		initMatrixFacade(cmws, 3);
		// test 2nd converted position again: should return different results
		setPositionDeg(300, -30, 0, 0, 0, 0, cmws.current);
		getAltazMatrix(cmws);
		result3AzDeg = cmws.current.az / uom.degToRad;
		result3AltDeg = cmws.current.alt / uom.degToRad;
		equal(withinRange(result3AzDeg, expected3AzDeg, allowedErrorDeg), true, 'az (deg) should not match above, is ' + result3AzDeg);
		equal(withinRange(result3AltDeg, expected3AltDeg, allowedErrorDeg), true, 'alt (deg) should not match above, is ' + result3AltDeg);		
	});
	
	QUnit.module('init results');
	
	function testInitAltazResults(hemisphere, latitudeDeg, azOffsetDeg, altOffsetDeg, SidTOffsetDeg, cmws) {
		var allowedErrorDeg, latitudeRad, decDeg, absLatitudeDeg, results, latitudeResultDeg, azOffsetResultDeg, HAOffsetResultDeg;

		// 1 arcsecond
		allowedErrorDeg = 1 / 3600;
		latitudeRad = latitudeDeg * uom.degToRad;
		// mimic presetAltaz() but with az offset
		decDeg = latitudeRad > 0 ? 90 : -90;
		absLatitudeDeg = Math.abs(latitudeRad / uom.degToRad);
		setPositionDeg(0, decDeg, azOffsetDeg, absLatitudeDeg + altOffsetDeg, 0, 0, cmws.one);
		setPositionDeg(0, 0, 180 + azOffsetDeg, 90 - absLatitudeDeg + altOffsetDeg, 0, 0, cmws.two);
		cmws.fabErrors.z3 = -altOffsetDeg * uom.degToRad;
		initMatrixFacade(cmws, 2);
		setPositionDeg(0, 0, 0, 0, SidTOffsetDeg, 0, cmws.current);
		getAltazMatrix(cmws);
		results = initAltazResults(hemisphere, cmws);
		latitudeResultDeg = results.initLatitude / uom.degToRad;
		azOffsetResultDeg = results.azOffset / uom.degToRad;
		HAOffsetResultDeg = results.HAOffset / uom.degToRad;
		equal(withinRange(latitudeResultDeg, latitudeDeg, allowedErrorDeg), true, 'initLatitude (deg) should be ' + latitudeDeg + ', is ' + latitudeResultDeg);
		equal(withinRange(azOffsetResultDeg, azOffsetDeg, allowedErrorDeg), true, 'azOffset (deg) should be ' + azOffsetDeg + ', is ' + azOffsetResultDeg);
		equal(withinRange(HAOffsetResultDeg, SidTOffsetDeg, allowedErrorDeg), true, 'HAOffset (deg) should be ' + SidTOffsetDeg + ', is ' + HAOffsetResultDeg);
	}
	
	QUnit.test('altazimuth', function () {
		var cmws = new ConvertMatrixWorkingStorage();
		testInitAltazResults(Hemisphere.northern, 40, 0, 0, 0, cmws);
		testInitAltazResults(Hemisphere.southern, -40, 0, 0, 0, cmws);
		testInitAltazResults(Hemisphere.northern, 40, 1, 0, 1, cmws);
		testInitAltazResults(Hemisphere.southern, -40, -1, 0, -1, cmws);
		testInitAltazResults(Hemisphere.northern, 40, 0, 1, 0, cmws);
		testInitAltazResults(Hemisphere.southern, -40, 0, -1, 0, cmws);
	});
	
	QUnit.module('altoffset');
	
	QUnit.test('directly', function () {
		testAltOffsetDirectly(40, 10);
		testAltOffsetDirectly(40, -10);
		testAltOffsetDirectly(-40, 10);
		testAltOffsetDirectly(-40, -10);
	});

	function testAltOffsetDirectly(latitudeDeg, altOffsetDeg) {
		var allowedErrorDeg, latitudeRad, decDeg, absLatitudeDeg, a, z, resultAltOffset;

		// 1 arcsecond
		allowedErrorDeg = 1 / 3600;
		latitudeRad = latitudeDeg * uom.degToRad;
		decDeg = latitudeRad > 0 ? 90 : -90;
		absLatitudeDeg = Math.abs(latitudeRad / uom.degToRad);
		a = new Position();
		z = new Position();
		// simulate equatorial alignment
		setPositionDeg(0, decDeg, 0, absLatitudeDeg - altOffsetDeg, 0, 0, a);
		setPositionDeg(0, 0, 180, 90 - absLatitudeDeg - altOffsetDeg, 0, 0, z);
		resultAltOffset = calcAltOffsetDirectly(a, z) / uom.degToRad;
		equal(withinRange(resultAltOffset, altOffsetDeg, allowedErrorDeg), true, 'equatorial preset altOffset (deg) should be ' + altOffsetDeg + ', is ' + resultAltOffset);		
		// simulate altazimuth alignment
		decDeg = latitudeRad > 0 ? 90 : -90;
		absLatitudeDeg = Math.abs(latitudeRad / uom.degToRad);
		setPositionDeg(0, decDeg, 0, absLatitudeDeg - altOffsetDeg, 0, 0, a);
		setPositionDeg(0, 0, 180, 90 - absLatitudeDeg - altOffsetDeg, 0, 0, z);
		resultAltOffset = calcAltOffsetDirectly(a, z) / uom.degToRad;
		equal(withinRange(resultAltOffset, altOffsetDeg, allowedErrorDeg), true, 'altazimuth preset altOffset (deg) should be ' + altOffsetDeg + ', is ' + resultAltOffset);		
	}
	
	QUnit.test('iteratively', function () {
		testAltOffsetIteratively(40, 10);
		testAltOffsetIteratively(40, -10);
		testAltOffsetIteratively(-40, 10);
		testAltOffsetIteratively(-40, -10);
	});

	function testAltOffsetIteratively(latitudeDeg, altOffsetDeg) {
		var allowedErrorDeg, latitudeRad, decDeg, absLatitudeDeg, a, z, resultAltOffset;

		// 1 arcsecond
		allowedErrorDeg = 1 / 3600;
		latitudeRad = latitudeDeg * uom.degToRad;
		decDeg = latitudeRad > 0 ? 90 : -90;
		absLatitudeDeg = Math.abs(latitudeRad / uom.degToRad);
		a = new Position();
		z = new Position();
		// simulate equatorial alignment
		setPositionDeg(0, decDeg, 0, absLatitudeDeg - altOffsetDeg, 0, 0, a);
		setPositionDeg(0, 0, 180, 90 - absLatitudeDeg - altOffsetDeg, 0, 0, z);
		resultAltOffset = calcAltOffsetIteratively(a, z) / uom.degToRad;
		equal(withinRange(resultAltOffset, altOffsetDeg, allowedErrorDeg), true, 'altOffset (deg) should be ' + altOffsetDeg + ', is ' + resultAltOffset);		
		// simulate altazimuth alignment
		decDeg = latitudeRad > 0 ? 90 : -90;
		absLatitudeDeg = Math.abs(latitudeRad / uom.degToRad);
		setPositionDeg(0, decDeg, 0, absLatitudeDeg - altOffsetDeg, 0, 0, a);
		setPositionDeg(0, 0, 180, 90 - absLatitudeDeg - altOffsetDeg, 0, 0, z);
		resultAltOffset = calcAltOffsetIteratively(a, z) / uom.degToRad;
		equal(withinRange(resultAltOffset, altOffsetDeg, allowedErrorDeg), true, 'altazimuth preset altOffset (deg) should be ' + altOffsetDeg + ', is ' + resultAltOffset);		
	}

	QUnit.module('field rotation');
	
	QUnit.test('angle, uses xform facade', function () {
		var allowedErrorDeg, latitudeRad, xform, expectedFRDeg, HAOffset, resultFRDeg;

		// 1 arcsecond
		allowedErrorDeg = 1 / 3600;
		latitudeRad = 45 * uom.degToRad;
		xform = new XForm(ConvertStyle.matrix, latitudeRad);
		xform.presetAltaz();
		xform.position.SidT = 0;
		xform.position.az = 160 * uom.degToRad;
		xform.position.alt = 45 * uom.degToRad;
		xform.getEquat();
		expectedFRDeg = 345.99805783448306;
		HAOffset = 0;
		// call function directly
		resultFRDeg = calcFieldRotationAngle(xform.position, HAOffset, latitudeRad) / uom.degToRad;
		equal(withinRange(resultFRDeg, expectedFRDeg, allowedErrorDeg), true, 'FR angle should be ' + expectedFRDeg + ', is ' + resultFRDeg);
		// now call through xform facade
		resultFRDeg = xform.calcFieldRotationAngle(HAOffset) / uom.degToRad;
		equal(withinRange(resultFRDeg, expectedFRDeg, allowedErrorDeg), true, 'FR angle should be ' + expectedFRDeg + ', is ' + resultFRDeg);		
	});

	QUnit.module('bestZ123');

	function loadTakiTestPositions() {
		var data, ix, row, position, positions;

		data = [
			// test data generated using Taki's stated Z123 values
			// a few positions more than cmws.one and cmws.two are needed to best establish Z123
			[  71.53,   17.07,  0.015, 40.31, 15.542],
			[ 45.221, -41.564,     60,    10,  9.827],
			[  5.885,      24,    120,    80, 11.281]
		];
		positions = [];
		for (ix = 0; ix < data.length; ix++) {
			row = data[ix];
			position = new Position();
			setPositionDeg(row[0], row[1], row[2], row[3], row[4], 0, position);
			positions.push(position);
		}
		return positions;
	}

	// from Taki: z1=-.04, z2=.4, z3=-1.63
	// this code: 0, 0.47, -1.59
	QUnit.test('bestZ3', function () {
		var cmws, positions, result;
		
		cmws = new ConvertMatrixWorkingStorage();
		initTaki(cmws);
		positions = loadTakiTestPositions();

		result = bestZ3(positions, cmws) / uom.degToRad;
		equal(withinRange(result, -1.6, 0.05), true, 'best Z3 (deg) should be -1.63, is ' + result);
	});

	QUnit.test('bestZ123', function () {
		var allowedErrorDeg, cmws, positions, result, z1, z2, z3;

		allowedErrorDeg = 1 / 10;
		cmws = new ConvertMatrixWorkingStorage();
		initTaki(cmws);
		positions = loadTakiTestPositions();

		result = bestZ123(positions, cmws, new FabErrors());
		z1 = result.z1 / uom.degToRad;
		equal(withinRange(z1, -0.04, allowedErrorDeg), true, 'best Z1 (deg) should be -0.04, is ' + z1);
		z2 = result.z2 / uom.degToRad;
		equal(withinRange(z2, 0.4, allowedErrorDeg), true, 'best Z2 (deg) should be 0.4, is ' + z2);
		z3 = result.z3 / uom.degToRad;
		equal(withinRange(z3, -1.63, allowedErrorDeg), true, 'best Z3 (deg) should be -1.63, is ' + z3);
	});
	
	QUnit.test('bestZ12 with presetAltaz alignment', function () {
		// latitudes of 40, 41 etc give different results
		var allowedErrorDeg, cmws, latitudeRad = 41 * uom.degToRad, positions, result, z1, z2, z3;

		allowedErrorDeg = 1 / 10;
		cmws = new ConvertMatrixWorkingStorage();
		presetAltaz(latitudeRad, cmws);
		positions = [];

		result = bestZ123(positions, cmws, new FabErrors());
		z1 = result.z1 / uom.degToRad;
		equal(withinRange(z1, 0, allowedErrorDeg), true, 'best Z1 (deg) should be 0, is ' + z1);
		z2 = result.z2 / uom.degToRad;
		equal(withinRange(z2, 0, allowedErrorDeg), true, 'best Z2 (deg) should be 0, is ' + z2);
		z3 = result.z3 / uom.degToRad;
		equal(withinRange(z3, 0, allowedErrorDeg), true, 'best Z3 (deg) should be 0, is ' + z3);
	});
	
	QUnit.module('z1 (axis twist or non-perpendicularity) initialization study');

	/*
	demonstrates that an axis twist of 1 degree means that the az axis leans to the right when facing its zero point (here, north);
	eg, when z1=0 scope's zenith points to site zenith (RA=0) and when z1=1 scope's zenith points east of site zenith (az=90,alt=89 or RA=1.22 or HA = -1.22);
	does not matter if z1=1 set before or after init as long as init positions adjusted, 
	   eg, setPositionDeg(0, 35, 0, 90, 0, 0, cmws.one); setPositionDeg(0, -55, 180, 0, 0, 0, cmws.two); xform.setFabErrorsDeg(1, 0, 0);  same as
	   xform.setFabErrorsDeg(1, 0, 0); setPositionDeg(1.2207, 34.9939, 0, 90, 0, 0, cmws.one); setPositionDeg(0, -55, 180, 0, 0, 0, cmws.two);
	 */
	QUnit.test('altaz values with z1 for zenith, horizon', function () {
		var allowedErrorDeg = 1/3600,
		    latitude = 35,
		    latitudeRad = latitude * uom.degToRad,
		    xform = new XForm(ConvertStyle.matrix, latitudeRad),
			cmws = xform.cmws,
			resultBestZ123,
			resultBestZ1Deg,
			expectedBestZ1Deg = 0,
			resultRADeg,
			expectedRADeg = 1.2207,
			resultDecDeg,
			expectedDecDeg = 34.9939,
			testPosition = new Position(10 * uom.degToRad, 40 * uom.degToRad, 0, 0, 0, 0),
			expectedPosition = new Position(0, 0, 48.7286 * uom.degToRad, 80.68443 * uom.degToRad, 0, 0);

		// initialize at altaz zenith and the southern horizon (lat=35)
		xform.setFabErrorsDeg(0, 0, 0);
		setPositionDeg(0, 35, 0, 90, 0, 0, cmws.one);
		setPositionDeg(0, -55, 180, 0, 0, 0, cmws.two);
		clearPosition(cmws.three);
		initMatrixFacade(cmws, 2);	
		//z1=1: scope's zenith points east of site zenith (az=90,alt=89 or RA=1.22, Dec=34.9939 [site zenith is RA=0, Dec=25])
		xform.setFabErrorsDeg(1, 0, 0);
		xform.position.SidT = 0;
		xform.position.az = 0 * uom.degToRad;
		xform.position.alt = 90 * uom.degToRad;
		xform.getEquat();
		resultRADeg = validHalfRev(xform.position.RA) / uom.degToRad;
		equal(withinRange(resultRADeg, expectedRADeg, allowedErrorDeg), true, 'RA (deg) should be ' + expectedRADeg + ', is ' + resultRADeg);
		resultDecDeg = xform.position.Dec / uom.degToRad;
		equal(withinRange(resultDecDeg, expectedDecDeg, allowedErrorDeg), true, 'Dec (deg) should be ' + expectedDecDeg + ', is ' + resultDecDeg);
		// and...
		copyPosition(testPosition, xform.position);
		xform.getAltaz();
		equal(withinRange(xform.position.az / uom.degToRad, expectedPosition.az / uom.degToRad, allowedErrorDeg), true, 'az (deg) should be ' + expectedPosition.az / uom.degToRad + ', is ' + xform.position.az / uom.degToRad);
		equal(withinRange(xform.position.alt / uom.degToRad, expectedPosition.alt / uom.degToRad, allowedErrorDeg), true, 'alt (deg) should be ' + expectedPosition.alt / uom.degToRad + ', is ' + xform.position.alt / uom.degToRad);

		// compare to init w/ z1=1, init#1: RA,Dec = expected equat when z1=1; here pointing to alt=90 results in RA/Dec of 1.2/34.9 (same transformations as above example)
		xform.setFabErrorsDeg(1, 0, 0);
		setPositionDeg(expectedRADeg, expectedDecDeg, 0, 90, 0, 0, cmws.one);
		setPositionDeg(0, -55, 180, 0, 0, 0, cmws.two);
		clearPosition(cmws.three);
		initMatrixFacade(cmws, 2);
		xform.position.SidT = 0;
		xform.position.az = 0 * uom.degToRad;
		xform.position.alt = 90 * uom.degToRad;
		xform.getEquat();
		resultRADeg = validHalfRev(xform.position.RA) / uom.degToRad;
		equal(withinRange(resultRADeg, expectedRADeg, allowedErrorDeg), true, 'RA (deg) should be ' + expectedRADeg + ', is ' + resultRADeg);
		resultDecDeg = xform.position.Dec / uom.degToRad;
		equal(withinRange(resultDecDeg, expectedDecDeg, allowedErrorDeg), true, 'Dec (deg) should be ' + expectedDecDeg + ', is ' + resultDecDeg);
		// and...
		copyPosition(testPosition, xform.position);
		xform.getAltaz();
		equal(withinRange(xform.position.az / uom.degToRad, expectedPosition.az / uom.degToRad, allowedErrorDeg), true, 'az (deg) should be ' + expectedPosition.az / uom.degToRad + ', is ' + xform.position.az / uom.degToRad);
		equal(withinRange(xform.position.alt / uom.degToRad, expectedPosition.alt / uom.degToRad, allowedErrorDeg), true, 'alt (deg) should be ' + expectedPosition.alt / uom.degToRad + ', is ' + xform.position.alt / uom.degToRad);
	});
	
	QUnit.module('hysteresis: start with altaz, get equat, then get altaz, compare ending to starting altaz');
	
	function hysteresisSubr(cmws, convertSubroutineType, azError, altError) {
		var startingAz = 140 * uom.degToRad,
		    startingAlt = 85 * uom.degToRad;
		cmws.convertSubrType = convertSubroutineType;
		cmws.current.az = startingAz;
		cmws.current.alt = startingAlt;
		getEquatMatrix(cmws);
		getAltazMatrix(cmws);
		equal(withinRange(cmws.current.az, startingAz, azError), true, convertSubroutineType + ' hysteresis in az (arcsecond) is ' + (cmws.current.az - startingAz) / uom.arcsecToRad);
		equal(withinRange(cmws.current.alt, startingAlt, altError), true, convertSubroutineType + ' hysteresis in alt (arcsecond) is ' + (cmws.current.alt - startingAlt) / uom.arcsecToRad);	
	}
	
	QUnit.test('vary ConvertSubroutineType', function () {
		var cmws = new ConvertMatrixWorkingStorage();
		setFabErrorsDeg(-0.04, 0.4, -1.63, cmws.fabErrors);
		initTaki(cmws);
		
		// TakiSimple: hysteresis in az (arcsecond) is -1386.1089080839276, hysteresis in alt (arcsecond) is -236.7554830011852
		hysteresisSubr(cmws, ConvertSubroutineType.TakiSimple, 1400 * uom.arcsecToRad, 240 * uom.arcsecToRad);
	
		// TakiSmallAngle: hysteresis in az (arcsecond) is -30.09717037050807, hysteresis in alt (arcsecond) is -104.29204227149842
		hysteresisSubr(cmws, ConvertSubroutineType.TakiSmallAngle, 31 * uom.arcsecToRad, 110 * uom.arcsecToRad);

		// TakiIterative: hysteresis in az (arcsecond) is -0.00014596272788597236, hysteresis in alt (arcsecond) is -0.22944771470291325
		hysteresisSubr(cmws, ConvertSubroutineType.TakiIterative, 0.00015 * uom.arcsecToRad, 0.23 * uom.arcsecToRad);

		// BellIterative: hysteresis in az (arcsecond) is -0.09717037063207208, hysteresis in alt (arcsecond) is -4.5799987413074643e-10 (Firefox), -1.648799546870687e-9 (Google)
		hysteresisSubr(cmws, ConvertSubroutineType.BellIterative, 0.1 * uom.arcsecToRad, 0.00000001 * uom.arcsecToRad);

		// BellTaki: hysteresis in az (arcsecond) is -0.00014596272788597236, hysteresis in alt (arcsecond) is -4.5799987413074643e-10 (Firefox), -1.648799546870687e-9 (Google)
		hysteresisSubr(cmws, ConvertSubroutineType.BellTaki, 0.0002 * uom.arcsecToRad, 0.00000001 * uom.arcsecToRad);
	});
	
	QUnit.module('xform: meridian flip (matrix: presetAltaz)');
	
	function testConvertWithMeridianFlip(convertStyle, latitude, azDeg, altDeg, flippedAzDeg, flippedAltDeg, desiredRADeg, desiredDecDeg) {
		var allowedErrorDeg, latitudeRad, xform, resultRADeg, resultDecDeg, resultAltDeg, resultAzDeg;

		// 1 arcsecond
		allowedErrorDeg = 1 / 3600;

		latitudeRad = latitude * uom.degToRad;
		xform = new XForm(convertStyle, latitudeRad);
		xform.setMeridianFlip(true, false);
		xform.presetAltaz();

		xform.position.SidT = 0;
		xform.position.az = azDeg * uom.degToRad;
		xform.position.alt = altDeg * uom.degToRad;
		xform.getEquat();
		resultRADeg = xform.position.RA / uom.degToRad;
		resultDecDeg = xform.position.Dec / uom.degToRad;
		equal(withinRange(resultRADeg, desiredRADeg, allowedErrorDeg), true, convertStyle + ' RA (deg) should be ' + desiredRADeg + ', is ' + resultRADeg);
		equal(withinRange(resultDecDeg, desiredDecDeg, allowedErrorDeg), true, convertStyle + ' Dec (deg) should be ' + desiredDecDeg + ', is ' + resultDecDeg);
		// flip
		xform.setMeridianFlip(true, true);
		xform.position.az = flippedAzDeg * uom.degToRad;
		xform.position.alt = flippedAltDeg * uom.degToRad;
		xform.getEquat();
		resultRADeg = xform.position.RA / uom.degToRad;
		resultDecDeg = xform.position.Dec / uom.degToRad;
		equal(withinRange(resultRADeg, desiredRADeg, allowedErrorDeg), true, convertStyle + ' flipped RA (deg) should be ' + desiredRADeg + ', is ' + resultRADeg);
		equal(withinRange(resultDecDeg, desiredDecDeg, allowedErrorDeg), true, convertStyle + ' flipped Dec (deg) should be ' + desiredDecDeg + ', is ' + resultDecDeg);
		// try to return to flipped altaz coordinates
		xform.getAltaz();
		resultAzDeg = xform.position.az / uom.degToRad;
		resultAltDeg = xform.position.alt / uom.degToRad;
		equal(withinRange(resultAzDeg, flippedAzDeg, allowedErrorDeg), true, convertStyle + ' flipped az (deg) should be ' + flippedAzDeg + ', is ' + resultAzDeg);
		equal(withinRange(resultAltDeg, flippedAltDeg, allowedErrorDeg), true, convertStyle + ' flipped alt (deg) should be ' + flippedAltDeg + ', is ' + resultAltDeg);
		// unflip
		xform.setMeridianFlip(true, false);
		xform.getAltaz();
		resultAzDeg = xform.position.az / uom.degToRad;
		resultAltDeg = xform.position.alt / uom.degToRad;
		equal(withinRange(resultAzDeg, azDeg, allowedErrorDeg), true, convertStyle + ' flipped az (deg) should be ' + azDeg + ', is ' + resultAzDeg);
		equal(withinRange(resultAltDeg, altDeg, allowedErrorDeg), true, convertStyle + ' flipped alt (deg) should be ' + altDeg + ', is ' + resultAltDeg);	
	}

	function testConvertWithMeridianFlipByConvertStyle(convertStyle) {
		var latitude = 30,
		    azDeg = 150,
		    altDeg = 70,
		    flippedAzDeg = 330,
		    flippedAltDeg = 110,
            desiredRADeg = 10.080956290391772,
            desiredDecDeg = 12.317641041744118;
		testConvertWithMeridianFlip(convertStyle, latitude, azDeg, altDeg, flippedAzDeg, flippedAltDeg, desiredRADeg, desiredDecDeg);

		// southern hemisphere az reverses direction so RA is mirrored; Dec is negative
		latitude = -30;
		azDeg = 150;
		altDeg = 70;
		flippedAzDeg = 330;
		flippedAltDeg = 110;
        desiredRADeg = 349.9190437096082;
        desiredDecDeg = -12.317641041744118;
		testConvertWithMeridianFlip(convertStyle, latitude, azDeg, altDeg, flippedAzDeg, flippedAltDeg, desiredRADeg, desiredDecDeg);
	}

	QUnit.test('matrix', function () {
		testConvertWithMeridianFlipByConvertStyle(ConvertStyle.matrix);
	});

	QUnit.test('trig', function () {
		testConvertWithMeridianFlipByConvertStyle(ConvertStyle.trig);
	});
	
	QUnit.module('xform');
	
	function testXform(xform, priDeg, secDeg, expectedPriDeg, expectedSecDeg, expectedFRAngle) {
		var allowedErrorDeg, resultPriDeg, resultSecDeg, HAOffset, resultFieldRotationAngle, differenceFieldRotationAngle;

		// 1 arcsecond
		allowedErrorDeg = 1 / 3600;
		xform.position.SidT = 0;
		xform.position.RA = priDeg * uom.degToRad;
		xform.position.Dec = secDeg * uom.degToRad;
		xform.getAltaz();
		resultPriDeg = xform.position.az / uom.degToRad;
		resultSecDeg = xform.position.alt / uom.degToRad;
		equal(withinRange(resultPriDeg, expectedPriDeg, allowedErrorDeg), true, 'az (deg) should be ' + expectedPriDeg + ', is ' + resultPriDeg);
		equal(withinRange(resultSecDeg, expectedSecDeg, allowedErrorDeg), true, 'alt (deg) should be ' + expectedSecDeg + ', is ' + resultSecDeg);
		// compare to starting equatorial coordinates
		xform.getEquat();
		resultPriDeg = xform.position.RA / uom.degToRad;
		resultSecDeg = xform.position.Dec / uom.degToRad;
		equal(withinRange(resultPriDeg, priDeg, allowedErrorDeg), true, 'az (deg) should be ' + priDeg + ', is ' + resultPriDeg);
		equal(withinRange(resultSecDeg, secDeg, allowedErrorDeg), true, 'alt (deg) should be ' + secDeg + ', is ' + resultSecDeg);
		
		HAOffset = 0;
		resultFieldRotationAngle = xform.calcFieldRotationAngle(HAOffset);
		// eg, covers when expected, result FR are 0. 2Pi or vise versa
		differenceFieldRotationAngle = validHalfRev(expectedFRAngle - resultFieldRotationAngle);
		equal(withinRange(differenceFieldRotationAngle, 0, allowedErrorDeg), true, 'FR angle(deg) should be ' + expectedFRAngle + ', is ' + resultFieldRotationAngle);		
	}
	
	QUnit.test('trig, matrix: presetEquat', function () {
		var latitude = 30,
		    latitudeRad = latitude * uom.degToRad,
			// 20 degrees east of the meridian
		    priDeg = 20,
		    secDeg = 10,
		    expectedPriDeg = 160,
		    expectedSecDeg = 10,
			// FR angle 0: different browsers can return the smallest possible number less than 360
		    expectedFRAngle = 0,
			// trig
		    xform = new XForm(ConvertStyle.trig, latitudeRad);
		xform.presetEquat(Hemisphere.northern);
		testXform(xform, priDeg, secDeg, expectedPriDeg, expectedSecDeg, expectedFRAngle);
		// matrix
		xform = new XForm(ConvertStyle.matrix, latitudeRad);
		xform.presetEquat(Hemisphere.northern);
		testXform(xform, priDeg, secDeg, expectedPriDeg, expectedSecDeg, expectedFRAngle);
		
		// southern hemisphere
		latitudeRad = -latitudeRad;
		secDeg = -10;
		expectedPriDeg = 200;
		expectedSecDeg = 10;
		// FR angle 180 in southern hemisphere (parallactic angle always tied to north pole)
		expectedFRAngle = uom.halfRev;
		// trig
		xform = new XForm(ConvertStyle.trig, latitudeRad);
		xform.presetEquat(Hemisphere.southern);
		testXform(xform, priDeg, secDeg, expectedPriDeg, expectedSecDeg, expectedFRAngle);
		// matrix
		xform = new XForm(ConvertStyle.matrix, latitudeRad);
		xform.presetEquat(Hemisphere.southern);
		testXform(xform, priDeg, secDeg, expectedPriDeg, expectedSecDeg, expectedFRAngle);
	});

	QUnit.test('trig, matrix: presetAltaz', function () {
		var latitude = 30,
		    latitudeRad = latitude * uom.degToRad,
			// on meridian
		    priDeg = 0,
		    secDeg = 10,
		    expectedPriDeg = 180,
		    expectedSecDeg = 70,
		    expectedFRAngle = 0,
			// trig
		    xform = new XForm(ConvertStyle.trig, latitudeRad);
		xform.presetAltaz();
		testXform(xform, priDeg, secDeg, expectedPriDeg, expectedSecDeg, expectedFRAngle);
		// matrix
		xform = new XForm(ConvertStyle.matrix, latitudeRad);
		xform.presetAltaz();
		testXform(xform, priDeg, secDeg, expectedPriDeg, expectedSecDeg, expectedFRAngle);
		
		// southern hemisphere
		latitudeRad = -latitudeRad;
		secDeg = -10;
		expectedPriDeg = 180;
		expectedSecDeg = 70;
		// FR angle 180 in southern hemisphere (parallactic angle always tied to north pole)
		expectedFRAngle = uom.halfRev;
		// trig
		xform = new XForm(ConvertStyle.trig, latitudeRad);
		xform.presetAltaz();
		testXform(xform, priDeg, secDeg, expectedPriDeg, expectedSecDeg, expectedFRAngle);
		// matrix
		xform = new XForm(ConvertStyle.matrix, latitudeRad);
		xform.presetAltaz();
		testXform(xform, priDeg, secDeg, expectedPriDeg, expectedSecDeg, expectedFRAngle);
	});
	
	QUnit.test('matrix: post init functions using Taki data', function () {
		var xform, initAltazResults, bestZ123;

		xform = new XForm(ConvertStyle.matrix, 40 * uom.degToRad);
		xform.setFabErrorsDeg(-0.04, 0.4, -1.63);
		initTaki(xform.cmws);
		initAltazResults = xform.initAltazResults();
		equal(initAltazResults.azOffset / uom.degToRad, -95.00070279017189, 'az offset (deg)');
		bestZ123 = xform.bestZ123(loadTakiTestPositions());
		// Taki says -0.04
		equal(bestZ123.z1 / uom.degToRad, 0, 'z1 (deg)');	
	});

	QUnit.test('trig, matrix: meridianFlip=off', function () {
		var latitude = 30,
		    latitudeRad = latitude * uom.degToRad,
			// RA=0, Dec=89, expected az=180, alt=89
		    priDeg = 0,
		    secDeg = 89,
		    expectedPriDeg = 180,
		    expectedSecDeg = 89,
		    expectedFRAngle = 0,
			// trig
		    xform = new XForm(ConvertStyle.trig, latitudeRad);
		
		xform.meridianFlip.canFlip = false;
		xform.presetEquat(Hemisphere.northern);
		testXform(xform, priDeg, secDeg, expectedPriDeg, expectedSecDeg, expectedFRAngle);
		// matrix
		xform = new XForm(ConvertStyle.matrix, latitudeRad);
		xform.presetEquat(Hemisphere.northern);
		testXform(xform, priDeg, secDeg, expectedPriDeg, expectedSecDeg, expectedFRAngle);
		
		// southern hemisphere
		latitudeRad = -latitudeRad;
		// RA=0, Dec=-89, expected az=180, alt=-89
		secDeg = -89;
		expectedPriDeg = 180;
		expectedSecDeg = 89;
		expectedFRAngle = uom.halfRev;
		// trig
		xform = new XForm(ConvertStyle.trig, latitudeRad);
		xform.presetEquat(Hemisphere.southern);
		testXform(xform, priDeg, secDeg, expectedPriDeg, expectedSecDeg, expectedFRAngle);
		// matrix
		xform = new XForm(ConvertStyle.matrix, latitudeRad);
		xform.presetEquat(Hemisphere.southern);
		testXform(xform, priDeg, secDeg, expectedPriDeg, expectedSecDeg, expectedFRAngle);
	});
	
	QUnit.test('trig, matrix: meridianFlip=on', function () {
		var latitude = 30,
		    latitudeRad = latitude * uom.degToRad,
			// RA=0, Dec=89, expected az=180, alt=89, flipped az=0, alt=91
		    priDeg = 0,
		    secDeg = 89,
		    expectedPriDeg = 0,
		    expectedSecDeg = 91,
		    expectedFRAngle = 0,
			// trig
		    xform = new XForm(ConvertStyle.trig, latitudeRad);
		
		xform.presetEquat(Hemisphere.northern);
		xform.meridianFlip.canFlip = true;
		setFlipState(true, xform.meridianFlip);
		testXform(xform, priDeg, secDeg, expectedPriDeg, expectedSecDeg, expectedFRAngle);
		// matrix
		xform = new XForm(ConvertStyle.matrix, latitudeRad);
		xform.presetEquat(Hemisphere.northern);
		xform.meridianFlip.canFlip = true;
		setFlipState(true, xform.meridianFlip);
		testXform(xform, priDeg, secDeg, expectedPriDeg, expectedSecDeg, expectedFRAngle);
		
		// southern hemisphere
		latitudeRad = -latitudeRad;
		// RA=0, Dec=-89, expected az=180, alt=89, flipped az=0, alt=91
		secDeg = -89;
		expectedPriDeg = 0;
		expectedSecDeg = 91;
		expectedFRAngle = uom.halfRev;
		// trig
		xform = new XForm(ConvertStyle.trig, latitudeRad);
		xform.presetEquat(Hemisphere.southern);
		xform.meridianFlip.canFlip = true;
		setFlipState(true, xform.meridianFlip);
		testXform(xform, priDeg, secDeg, expectedPriDeg, expectedSecDeg, expectedFRAngle);
		// matrix
		xform = new XForm(ConvertStyle.matrix, latitudeRad);
		xform.presetEquat(Hemisphere.southern);
		xform.meridianFlip.canFlip = true;
		setFlipState(true, xform.meridianFlip);
		testXform(xform, priDeg, secDeg, expectedPriDeg, expectedSecDeg, expectedFRAngle);
	});
	
	QUnit.module('tracking rates');
		
	QUnit.test('King rate: northern hemisphere, southern hemisphere, near pole', function () {
		var allowedErrorDeg, RA, Dec, SidT, latitude, expectedRate, resultRate, expectedRateArcsecPerSec, resultRateArcsecPerSec, expectedRateMinutesPerDayUnderPole;	

		allowedErrorDeg = 1 / 1000;	
		RA = 6 * uom.hrToRad;
		Dec = 5 * uom.degToRad;
		SidT = 7.5 * uom.hrToRad;
		latitude = 30 * uom.degToRad;
		
		expectedRate = 1432.9251192666854;
		resultRate = calcKingRateMinutesPerDay(RA, Dec, SidT, latitude);
		equal(withinRange(resultRate, expectedRate, allowedErrorDeg), true, 'King tracking rate at refracted pole should be ' + expectedRate + ', is ' + resultRate);
		expectedRateArcsecPerSec = 15.032901824812674;
		resultRateArcsecPerSec = calcKingRateArcsecPerSec(resultRate);
		equal(withinRange(resultRateArcsecPerSec, expectedRateArcsecPerSec, allowedErrorDeg), true, 'King tracking rate at refracted pole should be ' + expectedRateArcsecPerSec + ', is ' + resultRateArcsecPerSec);
		
		// southern hemisphere
		latitude = -latitude;
		Dec = -Dec;
		resultRate = calcKingRateMinutesPerDay(RA, Dec, SidT, latitude);
		equal(resultRate, -expectedRate, 'southern refracted rate is ' + resultRate);
		resultRateArcsecPerSec = calcKingRateArcsecPerSec(resultRate);
		equal(withinRange(resultRateArcsecPerSec, -expectedRateArcsecPerSec, allowedErrorDeg), true, 'King tracking rate at refracted pole should be ' + -expectedRateArcsecPerSec + ', is ' + resultRateArcsecPerSec);

        // directly under pole, 10 deg above horiz: instantaneous corrected tracking rates routines, RA tr = 15.058"/sec
        RA = 12 * uom.hrToRad;
        Dec = 70 * uom.degToRad;
        SidT = 0;
        latitude = 30 * uom.degToRad;
		expectedRate = 15.07820961888914;
        expectedRateMinutesPerDayUnderPole = calcKingRateMinutesPerDay(RA, Dec, SidT, latitude);
        resultRate = calcKingRateArcsecPerSec(expectedRateMinutesPerDayUnderPole);
		equal(withinRange(resultRate, expectedRate, allowedErrorDeg), true, 'expected rate under pole should be ' + expectedRate + ', is ' + resultRate);
	});
	
	QUnit.test('calcFieldRotationRateSidTrackFormula(), matches above test', function () {
		var allowedErrorArcsec = 1 / 1000,
			// see above test, very slightly slower than calculating by elapsed time
			expectedFRRateArcsecSec = 0.326, 
		    latitudeRad = 40 * uom.degToRad,
			HAOffset = 0,
		    position = new Position(),
			meridianFlip = new MeridianFlip(),
			result;
			
		setPositionDeg(45, 30, 90.9920, 52.2321, 0, 0, position);
		result = calcFieldRotationRateSidTrackFormula(position, meridianFlip, latitudeRad, HAOffset) / uom.arcsecToRad;
		equal(withinRange(result, expectedFRRateArcsecSec, allowedErrorArcsec), true, 'FR rate ("/sec) should be ' + expectedFRRateArcsecSec + ', is ' + result);
	});
	
	QUnit.test('calcFieldRotationRateSidTrackFormula()', function () {
		var allowedErrorArcsec = 1 / 1000,
			//14.095389311788617 for sidereal second, from ScopeIII test
			expectedFRRateArcsecSec = 14.1340, 
		    latitudeRad = 45 * uom.degToRad,
			HAOffset = 0,
		    position = new Position(),
			meridianFlip = new MeridianFlip(),
			result;
			
		setPositionDeg(0, 0, 160, 45, 0, 0, position);
		// get equat, necessary for FR routine
		getEquatTrig(position, null, latitudeRad);
		result = calcFieldRotationRateSidTrackFormula(position, meridianFlip, latitudeRad, HAOffset) / uom.arcsecToRad;
		equal(withinRange(result, expectedFRRateArcsecSec, allowedErrorArcsec), true, 'FR rate ("/sec) should be ' + expectedFRRateArcsecSec + ', is ' + result);
	});
	
	QUnit.test('calcAltazTrackingRates()', function () {
		var allowedErrorArcsec = 1 / 1000,
			// from test above with RA = 45 deg, Dec = 30 deg
		    latitudeRad = 40 * uom.degToRad,
			azDeg = 90.9920,
			altDeg = 52.2321,
			// azimuth rate should be slightly slower than test above since az rate is slowly accelerating
		    expectedResultArcsecSec = {az: 9.926, alt: 11.520},
			resultArcsecSec = {az: 'undefined', alt: 'undefined'},
			result = calcAltazTrackingRates(azDeg * uom.degToRad, altDeg * uom.degToRad, latitudeRad);

		resultArcsecSec.az = result.azRate / uom.arcsecToRad;
		resultArcsecSec.alt = result.altRate / uom.arcsecToRad;
	
		equal(withinRange(resultArcsecSec.az, expectedResultArcsecSec.az, allowedErrorArcsec), true, 'tracking rate in az expected is ' + expectedResultArcsecSec.az + ', is ' + resultArcsecSec.az);
		equal(withinRange(resultArcsecSec.alt, expectedResultArcsecSec.alt, allowedErrorArcsec), true, 'tracking rate in alt expected is ' + expectedResultArcsecSec.alt + ', is ' + resultArcsecSec.alt);	
	});
	
	QUnit.test('calcRefractionFromTrueEquatorialCorrection', function () {
		var allowedErrorDeg = 1/ 360000,
		    allowedErrorArcsec = 0.02,
		    latitudeDeg = 40,
			elevationDeg = 1,
			RADeg = 0,
			DecDeg = latitudeDeg - 90 + elevationDeg,
			SidTDeg = RADeg, 
			workPosition = new Position(),
			expectedAzDeg = 180,
			expectedAltDeg = elevationDeg,
			expectedRefractionArcsec = 1575.00,
			expectedRefractedAltArcsec  = 5175.00,
			expectedDeltaRAArcsec = 0,
			expectedDeltaDecArcsec = expectedRefractionArcsec,
			resultAzDeg,
			resultAltDeg,
			resultRefractionArcsec,
			resultRefractedAltArcsec,
			resultDeltaRAArcsec,
			resultDeltaDecArcsec,
			correction = calcRefractionFromTrueEquatorialCorrection(RADeg * uom.degToRad, DecDeg * uom.degToRad, SidTDeg * uom.degToRad, latitudeDeg * uom.degToRad, workPosition);

		resultAzDeg = correction.az / uom.degToRad;
		resultAltDeg = correction.alt / uom.degToRad;
		resultRefractionArcsec = correction.refraction / uom.arcsecToRad;
		resultRefractedAltArcsec = correction.refractedAlt / uom.arcsecToRad;
		resultDeltaRAArcsec = correction.deltaRA / uom.arcsecToRad;
		resultDeltaDecArcsec = correction.deltaDec / uom.arcsecToRad;
		
		equal(withinRange(resultAzDeg, expectedAzDeg, allowedErrorDeg), true, 'az (deg) should be ' + expectedAzDeg + ', is ' + resultAzDeg);
		equal(withinRange(resultAltDeg, expectedAltDeg, allowedErrorDeg), true, 'alt (deg) should be ' + expectedAltDeg + ', is ' + resultAltDeg);
		equal(withinRange(resultRefractionArcsec, expectedRefractionArcsec, allowedErrorArcsec), true, 'refraction (arcsec) should be ' + expectedRefractionArcsec + ', is ' + resultRefractionArcsec);
		equal(withinRange(resultRefractedAltArcsec, expectedRefractedAltArcsec, allowedErrorArcsec), true, 'refractedAlt (arcsec) should be ' + expectedRefractedAltArcsec + ', is ' + resultRefractedAltArcsec);
		equal(withinRange(resultDeltaRAArcsec, expectedDeltaRAArcsec, allowedErrorArcsec), true, 'delta RA (arcsec) should be ' + expectedDeltaRAArcsec + ', is ' + resultDeltaRAArcsec);
		equal(withinRange(resultDeltaDecArcsec, expectedDeltaDecArcsec, allowedErrorArcsec), true, 'delta (arcsec) Dec should be ' + expectedDeltaDecArcsec + ', is ' + resultDeltaDecArcsec);
	});
	
	QUnit.test('calcRefractionFromApparentEquatorialCorrection', function () {
		var allowedErrorDeg = 1 / 3600,
		    latitudeDeg = 40,
			elevationDeg = 1,
			RADeg = 0,
			DecDeg = latitudeDeg - 90 + elevationDeg,
			SidTDeg = RADeg, 
			workPosition = new Position(),
			correction = calcRefractionFromTrueEquatorialCorrection(RADeg * uom.degToRad, DecDeg * uom.degToRad, SidTDeg * uom.degToRad, latitudeDeg * uom.degToRad, workPosition),
			correctionAzDeg = correction.az / uom.degToRad,
			correctionAltDeg = correction.alt / uom.degToRad,
			correctedRADeg = RADeg + correction.deltaRA / uom.degToRad,
			correctedDecDeg = DecDeg + correction.deltaDec / uom.degToRad,
			correctedSidTDeg = correctedRADeg,
			roundTripCorrection = calcRefractionFromApparentEquatorialCorrection(correctedRADeg * uom.degToRad, correctedDecDeg * uom.degToRad, correctedSidTDeg * uom.degToRad, latitudeDeg * uom.degToRad, workPosition),
			roundTripCorrectionAzDeg = roundTripCorrection.az / uom.degToRad,
			roundTripCorrectionAltDeg = roundTripCorrection.alt / uom.degToRad,
			roundTripRADeg = correctedRADeg + roundTripCorrection.deltaRA / uom.degToRad,
			roundTripDecDeg = correctedDecDeg + roundTripCorrection.deltaDec / uom.degToRad;

		equal(withinRange(correctionAzDeg, roundTripCorrectionAzDeg, allowedErrorDeg), true, 'before and after az (deg) should match: before is ' + correctionAzDeg + ' and after is ' + roundTripCorrectionAzDeg);
		equal(withinRange(correctionAltDeg, roundTripCorrectionAltDeg, allowedErrorDeg), true, 'before and after non-refracted alt (deg) should match: before is ' + correctionAltDeg + ' and after is ' + roundTripCorrectionAltDeg);
		equal(withinRange(roundTripRADeg, RADeg, allowedErrorDeg), true, 'before and after RAs should match: before is ' + RADeg + ' and after is ' + roundTripRADeg + ', intervening RA was ' + correctedRADeg);
		equal(withinRange(roundTripDecDeg, DecDeg, allowedErrorDeg), true, 'before and after Degs should match: before is ' + DecDeg + ' and after is ' + roundTripDecDeg + ', intervening Dec was ' + correctedDecDeg);
	});
	
	function testTrackingRates(xform, expectedRatesArcsec, expectedSiteDeg, expectedTrackingRatesStrategy, timeIntervalSec, result) {
		var allowedErrorArcsec = 1 / 100,
		    // 0.1 arcsec 
		    allowedErrorDeg = 1 / 360000,
		    resultRates = {az: 'undefined', alt: 'undefined', FR: 'undefined', changeAz: 'undefined', changeAlt: 'undefined', changeFR: 'undefined'},
			resultSite = {siteAz: 'undefined', siteAlt: 'undefined'};

		resultRates.az = result.azRate / uom.arcsecToRad;
		resultRates.alt = result.altRate / uom.arcsecToRad;
		resultRates.FR = result.FRRate / uom.arcsecToRad;
		resultRates.changeAz = result.changeAzRate / uom.arcsecToRad;
		resultRates.changeAlt = result.changeAltRate / uom.arcsecToRad;
		resultRates.changeFR = result.changeFRRate / uom.arcsecToRad;
		resultSite.siteAz = result.siteAz / uom.degToRad;
		resultSite.siteAlt = result.siteAlt / uom.degToRad;

		equal(withinRange(resultRates.az, expectedRatesArcsec.az, allowedErrorArcsec), true, 'tracking rate in az expected is ' + expectedRatesArcsec.az + ', is ' + resultRates.az);
		equal(withinRange(resultRates.alt, expectedRatesArcsec.alt, allowedErrorArcsec), true, 'tracking rate in alt expected is ' + expectedRatesArcsec.alt + ', is ' + resultRates.alt);
		equal(withinRange(resultRates.FR, expectedRatesArcsec.FR, allowedErrorArcsec), true, 'tracking rate in FR expected is ' + expectedRatesArcsec.FR + ', is ' + resultRates.FR);
		equal(withinRange(resultRates.changeAz, expectedRatesArcsec.changeAz, allowedErrorArcsec), true, 'change in rates in az expected is ' + expectedRatesArcsec.changeAz + ', is ' + resultRates.changeAz);
		equal(withinRange(resultRates.changeAlt, expectedRatesArcsec.changeAlt, allowedErrorArcsec), true, 'change in rates in alt expected is ' + expectedRatesArcsec.changeAlt + ', is ' + resultRates.changeAlt);
		equal(withinRange(resultRates.changeFR, expectedRatesArcsec.changeFR, allowedErrorArcsec), true, 'change in rates in FR expected is ' + expectedRatesArcsec.changeFR + ', is ' + resultRates.changeFR);
		equal(withinRange(resultSite.siteAz, expectedSiteDeg.siteAz, allowedErrorDeg), true, 'site az expected is ' + expectedSiteDeg.siteAz + ', is ' + resultSite.siteAz);
		equal(withinRange(resultSite.siteAlt, expectedSiteDeg.siteAlt, allowedErrorDeg), true, 'site alt expected is ' + expectedSiteDeg.siteAlt + ', is ' + resultSite.siteAlt);
		equal(expectedTrackingRatesStrategy, result.trackingRatesStrategy, 'tracking rates expected strategy is ' + expectedTrackingRatesStrategy + ', is ' + result.trackingRatesStrategy);
	}
	
	QUnit.test('getRatesViaDeltaTime() equat', function () {
		var latitudeRad = 40 * uom.degToRad,
		    convertStyle = ConvertStyle.trig,
			xform,
			timeIntervalSec = 30,
			HAOffset = 0,
			includeRefraction = false,
			expectedRatesArcsec = {az: 15.0411, alt: 0, FR: 0, changeAz: 0, changeAlt: 0, changeFR: 0},
			expectedSiteDeg = {siteAz: 180, siteAlt: 50};

		xform = new XForm(convertStyle, latitudeRad);
		xform.presetEquat();
		setPositionDeg(0, 0, 0, 0, 0, 0, xform.position);
		testTrackingRates(xform, expectedRatesArcsec, expectedSiteDeg, TrackingRatesStrategy.deltaTimeNoRefraction, timeIntervalSec, new TrackingRates().getRatesViaDeltaTime(xform, timeIntervalSec, HAOffset, includeRefraction));
	});

	QUnit.test('getRatesViaDeltaTime() equat, under pole', function () {
		var latitudeRad = 40 * uom.degToRad,
		    convertStyle = ConvertStyle.trig,
			xform,
			timeIntervalSec = 30,
			SidTDeg = 180,
			DecDeg = 80,
			HAOffset = 0,
			includeRefraction = false,
			expectedRatesArcsec = {az: 15.0411, alt: 0, FR: 0, changeAz: 0, changeAlt: 0, changeFR: 0},
			expectedSiteDeg = {siteAz: 360, siteAlt: 30};

		xform = new XForm(convertStyle, latitudeRad);
		xform.presetEquat();
		setPositionDeg(0, DecDeg, 0, 0, SidTDeg, 0, xform.position);
		testTrackingRates(xform, expectedRatesArcsec, expectedSiteDeg, TrackingRatesStrategy.deltaTimeNoRefraction, timeIntervalSec, new TrackingRates().getRatesViaDeltaTime(xform, timeIntervalSec, HAOffset, includeRefraction));
	});

	QUnit.test('getRatesViaDeltaTime() altaz, with refraction', function () {
		var latitudeRad = 40 * uom.degToRad,
		    convertStyle = ConvertStyle.trig,
			xform,
			timeIntervalSec = 1,
			HAOffset = 0,
			includeRefraction = true,
			// with refraction, alt tracking rate slows, FR increases slightly
			expectedRatesArcsec = {az: 9.9260, alt: 11.5130, FR: 0.3299, changeAz: 0.000745, changeAlt: -0.00000962, changeFR: 0.000929},
			expectedSiteDeg = {siteAz:  90.991974, siteAlt:  52.232103};

		xform = new XForm(convertStyle, latitudeRad);
		xform.presetAltaz();
		setPositionDeg(45, 30, 0, 0, 0, 0, xform.position);
		testTrackingRates(xform, expectedRatesArcsec, expectedSiteDeg, TrackingRatesStrategy.deltaTimeWithRefraction, timeIntervalSec, new TrackingRates().getRatesViaDeltaTime(xform, timeIntervalSec, HAOffset, includeRefraction));
	});
	
	QUnit.test('getRatesViaDeltaTime() equat, under pole, with refraction', function () {
		var latitudeRad = 40 * uom.degToRad,
		    convertStyle = ConvertStyle.trig,
			xform,
			timeIntervalSec = 30,
			SidTDeg = 180,
			DecDeg = 80,
			HAOffset = 0,
			includeRefraction = true,
			// refracted RA runs slightly faster since the RA lines are squeezed up towards site zenith, fattening them from side to side
			expectedRatesArcsec = {az: 15.08, alt: 0, FR: 0, changeAz: 0, changeAlt: 0, changeFR: 0},
			expectedSiteDeg = {siteAz: 360, siteAlt: 30};

		xform = new XForm(convertStyle, latitudeRad);
		xform.presetEquat();
		setPositionDeg(0, DecDeg, 0, 0, SidTDeg, 0, xform.position);
		testTrackingRates(xform, expectedRatesArcsec, expectedSiteDeg, TrackingRatesStrategy.deltaTimeWithRefraction, timeIntervalSec, new TrackingRates().getRatesViaDeltaTime(xform, timeIntervalSec, HAOffset, includeRefraction));
	});

	QUnit.test('getRatesViaDeltaTime() altaz', function () {
		var latitudeRad = 40 * uom.degToRad,
		    convertStyle = ConvertStyle.trig,
			xform,
			timeIntervalSec = 1,
			HAOffset = 0,
			includeRefraction = false,
			expectedRatesArcsec = {az: 9.9260, alt: 11.5204, FR: 0.3262, changeAz: 0.000745, changeAlt: -0.00000962, changeFR: 0.000929},
			expectedSiteDeg = {siteAz:  90.991974, siteAlt:  52.232103};

		xform = new XForm(convertStyle, latitudeRad);
		xform.presetAltaz();
		setPositionDeg(45, 30, 0, 0, 0, 0, xform.position);
		testTrackingRates(xform, expectedRatesArcsec, expectedSiteDeg, TrackingRatesStrategy.deltaTimeNoRefraction, timeIntervalSec, new TrackingRates().getRatesViaDeltaTime(xform, timeIntervalSec, HAOffset, includeRefraction));
	});
	
	QUnit.test('getRatesViaDeltaTime() equat with meridian flip = off', function () {
		var latitudeRad = 40 * uom.degToRad,
		    convertStyle = ConvertStyle.trig,
			xform,
			timeIntervalSec = 30,
			HAOffset = 0,
			includeRefraction = false,
			expectedRatesArcsec = {az: 15.0411, alt: 0, FR: 0, changeAz: 0, changeAlt: 0, changeFR: 0},
			expectedSiteDeg = {siteAz: 0, siteAlt: 50};

		xform = new XForm(convertStyle, latitudeRad);
		xform.presetEquat();
		xform.meridianFlip.canFlip = true;
		setFlipState(false, xform.meridianFlip);
		setPositionDeg(0, 80, 0, 0, 0, 0, xform.position);
		testTrackingRates(xform, expectedRatesArcsec, expectedSiteDeg, TrackingRatesStrategy.deltaTimeNoRefraction, timeIntervalSec, new TrackingRates().getRatesViaDeltaTime(xform, timeIntervalSec, HAOffset, includeRefraction));
	});

	QUnit.test('getRatesViaDeltaTime() equat with meridian flip = on', function () {
		var latitudeRad = 40 * uom.degToRad,
		    convertStyle = ConvertStyle.trig,
			xform,
			timeIntervalSec = 30,
			HAOffset = 0,
			includeRefraction = false,
			expectedRatesArcsec = {az: 15.0411, alt: 0, FR: 0, changeAz: 0, changeAlt: 0, changeFR: 0},
			expectedSiteDeg = {siteAz: 0, siteAlt: 50};

		xform = new XForm(convertStyle, latitudeRad);
		xform.presetEquat();
		xform.meridianFlip.canFlip = true;
		setFlipState(true, xform.meridianFlip);
		// contrast with above position of 0, 80: flipped position is 180, 100
		setPositionDeg(180, 100, 0, 0, 0, 0, xform.position);
		testTrackingRates(xform, expectedRatesArcsec, expectedSiteDeg, TrackingRatesStrategy.deltaTimeNoRefraction, timeIntervalSec, new TrackingRates().getRatesViaDeltaTime(xform, timeIntervalSec, HAOffset, includeRefraction));
	});

	QUnit.test('getRatesViaDeltaTime() equat with meridian flip = off, from starting altaz coord', function () {
		var latitudeRad = 40 * uom.degToRad,
		    convertStyle = ConvertStyle.trig,
			xform,
			timeIntervalSec = 30,
			HAOffset = 0,
			includeRefraction = false,
			expectedRatesArcsec = {az: 15.0411, alt: 0, FR: 0, changeAz: 0, changeAlt: 0, changeFR: 0},
			expectedSiteDeg = {siteAz: 0, siteAlt: 50};

		xform = new XForm(convertStyle, latitudeRad);
		xform.presetEquat();
		xform.meridianFlip.canFlip = true;
		setFlipState(false, xform.meridianFlip);
		setPositionDeg(0, 0, 180, 80, 0, 0, xform.position);
		xform.getEquat();
		testTrackingRates(xform, expectedRatesArcsec, expectedSiteDeg, TrackingRatesStrategy.deltaTimeNoRefraction, timeIntervalSec, new TrackingRates().getRatesViaDeltaTime(xform, timeIntervalSec, HAOffset, includeRefraction));
	});

	QUnit.test('getRatesViaDeltaTime() equat with meridian flip = on, from starting altaz coord', function () {
		var latitudeRad = 40 * uom.degToRad,
		    convertStyle = ConvertStyle.trig,
			xform,
			timeIntervalSec = 30,
			HAOffset = 0,
			includeRefraction = false,
			expectedRatesArcsec = {az: 15.0411, alt: 0, FR: 0, changeAz: 0, changeAlt: 0, changeFR: 0},
			expectedSiteDeg = {siteAz: 0, siteAlt: 50};

		xform = new XForm(convertStyle, latitudeRad);
		xform.presetEquat();
		xform.meridianFlip.canFlip = true;
		setFlipState(true, xform.meridianFlip);
		// contrast with above position of 180, 80: flipped position is 0, 100
		setPositionDeg(0, 0, 0, 100, 0, 0, xform.position);
		xform.getEquat();
		testTrackingRates(xform, expectedRatesArcsec, expectedSiteDeg, TrackingRatesStrategy.deltaTimeNoRefraction, timeIntervalSec, new TrackingRates().getRatesViaDeltaTime(xform, timeIntervalSec, HAOffset, includeRefraction));
	});

	QUnit.test('getRatesViaFormulae() equat', function () {
		var latitudeRad = 40 * uom.degToRad,
		    convertStyle = ConvertStyle.trig,
			xform,
			timeIntervalSec = 30,
			HAOffset = 0,
			includeRefraction = false,
			expectedRatesArcsec = {az: 15.0411, alt: 0, FR: 0, changeAz: 0, changeAlt: 0, changeFR: 0},
			expectedSiteDeg = {siteAz: 180, siteAlt: 50};

		xform = new XForm(convertStyle, latitudeRad);
		xform.presetEquat();
		setPositionDeg(0, 0, 0, 0, 0, 0, xform.position);
		testTrackingRates(xform, expectedRatesArcsec, expectedSiteDeg, TrackingRatesStrategy.formulae, timeIntervalSec, new TrackingRates().getRatesViaFormulae(xform, timeIntervalSec, HAOffset, includeRefraction));
	});
	
	QUnit.test('getRatesViaFormulae() altaz', function () {
		var latitudeRad = 40 * uom.degToRad,
		    convertStyle = ConvertStyle.trig,
			xform,
			timeIntervalSec = 1,
			HAOffset = 0,
			// getRatesViaDeltaTime() is {az: 9.9260, alt: 11.5204, FR: 0.3262, changeAz: 0.000745, changeAlt: -0.00000962, changeFR: 0.000929};
			expectedRatesArcsec = {az: 9.9256, alt: 11.5204, FR: 0.3257, changeAz: 0.000745, changeAlt: -0.00000961, changeFR: 0.000929},
			expectedSiteDeg = {siteAz:  90.991974, siteAlt:  52.232103};

		xform = new XForm(convertStyle, latitudeRad);
		xform.presetAltaz();
		setPositionDeg(45, 30, 0, 0, 0, 0, xform.position);
		testTrackingRates(xform, expectedRatesArcsec, expectedSiteDeg, TrackingRatesStrategy.formulae, timeIntervalSec, new TrackingRates().getRatesViaFormulae(xform, timeIntervalSec, HAOffset));
	});
	
	QUnit.test('getRatesViaFormulae() equat with meridian flip = off', function () {
		var latitudeRad = 40 * uom.degToRad,
		    convertStyle = ConvertStyle.trig,
			xform,
			timeIntervalSec = 30,
			HAOffset = 0,
			includeRefraction = false,
			expectedRatesArcsec = {az: 15.0411, alt: 0, FR: 0, changeAz: 0, changeAlt: 0, changeFR: 0},
			expectedSiteDeg = {siteAz: 0, siteAlt: 50};

		xform = new XForm(convertStyle, latitudeRad);
		xform.presetEquat();
		xform.meridianFlip.canFlip = true;
		setFlipState(false, xform.meridianFlip);
		setPositionDeg(0, 80, 0, 0, 0, 0, xform.position);
		testTrackingRates(xform, expectedRatesArcsec, expectedSiteDeg, TrackingRatesStrategy.formulae, timeIntervalSec, new TrackingRates().getRatesViaFormulae(xform, timeIntervalSec, HAOffset, includeRefraction));
	});

	QUnit.test('getRatesViaFormulae() equat with meridian flip = on', function () {
		var latitudeRad = 40 * uom.degToRad,
		    convertStyle = ConvertStyle.trig,
			xform,
			timeIntervalSec = 30,
			HAOffset = 0,
			includeRefraction = false,
			expectedRatesArcsec = {az: 15.0411, alt: 0, FR: 0, changeAz: 0, changeAlt: 0, changeFR: 0},
			expectedSiteDeg = {siteAz: 0, siteAlt: 50};

		xform = new XForm(convertStyle, latitudeRad);
		xform.presetEquat();
		xform.meridianFlip.canFlip = true;
		setFlipState(true, xform.meridianFlip);
		// contrast with above position of 0, 80: flipped position is 180, 100
		setPositionDeg(180, 100, 0, 0, 0, 0, xform.position);
		testTrackingRates(xform, expectedRatesArcsec, expectedSiteDeg, TrackingRatesStrategy.formulae, timeIntervalSec, new TrackingRates().getRatesViaFormulae(xform, timeIntervalSec, HAOffset, includeRefraction));
	});

	QUnit.test('getRatesViaFormulae() equat with meridian flip = off, from starting altaz coord', function () {
		var latitudeRad = 40 * uom.degToRad,
		    convertStyle = ConvertStyle.trig,
			xform,
			timeIntervalSec = 30,
			HAOffset = 0,
			includeRefraction = false,
			expectedRatesArcsec = {az: 15.0411, alt: 0, FR: 0, changeAz: 0, changeAlt: 0, changeFR: 0},
			expectedSiteDeg = {siteAz: 0, siteAlt: 50};

		xform = new XForm(convertStyle, latitudeRad);
		xform.presetEquat();
		xform.meridianFlip.canFlip = true;
		setFlipState(false, xform.meridianFlip);
		setPositionDeg(0, 0, 180, 80, 0, 0, xform.position);
		xform.getEquat();
		testTrackingRates(xform, expectedRatesArcsec, expectedSiteDeg, TrackingRatesStrategy.formulae, timeIntervalSec, new TrackingRates().getRatesViaFormulae(xform, timeIntervalSec, HAOffset, includeRefraction));
	});

	QUnit.test('getRatesViaFormulae() equat with meridian flip = on, from starting altaz coord', function () {
		var latitudeRad = 40 * uom.degToRad,
		    convertStyle = ConvertStyle.trig,
			xform,
			timeIntervalSec = 30,
			HAOffset = 0,
			includeRefraction = false,
			expectedRatesArcsec = {az: 15.0411, alt: 0, FR: 0, changeAz: 0, changeAlt: 0, changeFR: 0},
			expectedSiteDeg = {siteAz: 0, siteAlt: 50};

		xform = new XForm(convertStyle, latitudeRad);
		xform.presetEquat();
		xform.meridianFlip.canFlip = true;
		setFlipState(true, xform.meridianFlip);
		// contrast with above position of 180, 80: flipped position is 0, 100
		setPositionDeg(0, 0, 0, 100, 0, 0, xform.position);
		xform.getEquat();
		testTrackingRates(xform, expectedRatesArcsec, expectedSiteDeg, TrackingRatesStrategy.formulae, timeIntervalSec, new TrackingRates().getRatesViaFormulae(xform, timeIntervalSec, HAOffset, includeRefraction));
	});

	QUnit.test('getRatesViaDeltaTime() equat, southern horizon, with refraction (compare with immediately following getKingRates() test)', function () {
		var latitudeRad = 40 * uom.degToRad,
		    convertStyle = ConvertStyle.trig,
			xform,
			timeIntervalSec = 30,
			SidTDeg = 0,
			DecDeg = -49,
			HAOffset = 0,
			includeRefraction = true,
			expectedRatesArcsec = {az: 14.9083, alt: 0.001, FR: 0, changeAz: 0, changeAlt: 0, changeFR: 0},
			expectedSiteDeg = {siteAz: 180, siteAlt: 1};

		xform = new XForm(convertStyle, latitudeRad);
		xform.presetEquat();
		setPositionDeg(0, DecDeg, 0, 0, SidTDeg, 0, xform.position);
		testTrackingRates(xform, expectedRatesArcsec, expectedSiteDeg, TrackingRatesStrategy.deltaTimeWithRefraction, timeIntervalSec, new TrackingRates().getRatesViaDeltaTime(xform, timeIntervalSec, HAOffset, includeRefraction));
	});

	QUnit.test('getKingRates() equat, southern horizon, with refraction (compare with above test)', function () {
		var latitudeRad = 40 * uom.degToRad,
		    convertStyle = ConvertStyle.trig,
			xform,
			timeIntervalSec = 30,
			SidTDeg = 0,
			DecDeg = -49,
			HAOffset = 0,
			includeRefraction = true,
			// contrast with test above using trig and getRatesViaDeltaTime
			expectedRatesArcsec = {az: 14.7564, alt: 0, FR: 0, changeAz: 0, changeAlt: 0, changeFR: 0},
			expectedSiteDeg = {siteAz: 180, siteAlt: 1};

		xform = new XForm(convertStyle, latitudeRad);
		xform.presetEquat();
		setPositionDeg(0, DecDeg, 0, 0, SidTDeg, 0, xform.position);
		testTrackingRates(xform, expectedRatesArcsec, expectedSiteDeg, TrackingRatesStrategy.KingRates, timeIntervalSec, new TrackingRates().getKingRates(xform, timeIntervalSec, HAOffset, includeRefraction));
	});
	
	QUnit.module('trackingRates with meridian flip and refraction comparing matrix to trig to King');

	QUnit.test('getRatesViaDeltaTime() equat, southern horizon, with refraction, with meridianFlip using matrix', function () {
		var latitudeRad = 40 * uom.degToRad,
		    convertStyle = ConvertStyle.matrix,
			xform,
			timeIntervalSec = 30,
			SidTDeg = 0,
			DecDeg = -49,
			HAOffset = 0,
			includeRefraction = true,
			// note that alt tracking rate is negative compared to not-flipped
			expectedRatesArcsec = {az: 14.9083, alt: -0.001, FR: 0, changeAz: 0, changeAlt: 0, changeFR: 0},
			expectedSiteDeg = {siteAz: 180, siteAlt: 1};

		xform = new XForm(convertStyle, latitudeRad);
		xform.presetEquat();
		xform.meridianFlip.canFlip = true;
		setFlipState(true, xform.meridianFlip);
		setPositionDeg(180, 180 - DecDeg, 0, 0, SidTDeg, 0, xform.position);
		testTrackingRates(xform, expectedRatesArcsec, expectedSiteDeg, TrackingRatesStrategy.deltaTimeWithRefraction, timeIntervalSec, new TrackingRates().getRatesViaDeltaTime(xform, timeIntervalSec, HAOffset, includeRefraction));
	});

	QUnit.test('getRatesViaDeltaTime() equat, southern horizon, with refraction, with meridianFlip using trig', function () {
		var latitudeRad = 40 * uom.degToRad,
		    convertStyle = ConvertStyle.trig,
			xform,
			timeIntervalSec = 30,
			SidTDeg = 0,
			DecDeg = -49,
			HAOffset = 0,
			includeRefraction = true,
			// note that alt tracking rate is negative compared to not-flipped
			expectedRatesArcsec = {az: 14.9083, alt: -0.001, FR: 0, changeAz: 0, changeAlt: 0, changeFR: 0},
			expectedSiteDeg = {siteAz: 180, siteAlt: 1};

		xform = new XForm(convertStyle, latitudeRad);
		xform.presetEquat();
		xform.meridianFlip.canFlip = true;
		setFlipState(true, xform.meridianFlip);
		setPositionDeg(180, 180 - DecDeg, 0, 0, SidTDeg, 0, xform.position);
		testTrackingRates(xform, expectedRatesArcsec, expectedSiteDeg, TrackingRatesStrategy.deltaTimeWithRefraction, timeIntervalSec, new TrackingRates().getRatesViaDeltaTime(xform, timeIntervalSec, HAOffset, includeRefraction));
	});

	QUnit.test('getKingRates() equat, southern horizon, with refraction, with meridianFlip using trig', function () {
		var latitudeRad = 40 * uom.degToRad,
		    convertStyle = ConvertStyle.trig,
			xform,
			timeIntervalSec = 30,
			SidTDeg = 0,
			DecDeg = -49,
			HAOffset = 0,
			includeRefraction = true,
			expectedRatesArcsec = {az: 14.7564, alt: 0, FR: 0, changeAz: 0, changeAlt: 0, changeFR: 0},
			expectedSiteDeg = {siteAz: 180, siteAlt: 1};

		xform = new XForm(convertStyle, latitudeRad);
		xform.presetEquat();
		xform.meridianFlip.canFlip = true;
		setFlipState(true, xform.meridianFlip);
		setPositionDeg(180, 180 - DecDeg, 0, 0, SidTDeg, 0, xform.position);
		testTrackingRates(xform, expectedRatesArcsec, expectedSiteDeg, TrackingRatesStrategy.KingRates, timeIntervalSec, new TrackingRates().getKingRates(xform, timeIntervalSec, HAOffset, includeRefraction));
	});
	
	QUnit.test('altaz constant track rate tracking errors (over 5 minutes)', function () {
		var allowedErrorArcsec = 1 / 100,
		    // 0.1 arcsec 
		    allowedErrorDeg = 1 / 360000,
			latitudeRad = 40 * uom.degToRad,
		    convertStyle = ConvertStyle.trig,
			xform,
			trackingRates,
			timeIntervalSec = 30,
			SidTDeg = 0,
			DecDeg = 0,
			HAOffset = 0,
			includeRefraction,
			expected,
			results,
			fiveMinuteAzErrorResults,
			fiveMinuteAltErrorResultsArcSec,
			az;

		trackingRates = new TrackingRates();
		// 5 minutes
		trackingRates.setConstantTrackRateTimeRad(300 * uom.secToRad);
		
		// delta time w/o refraction
		includeRefraction = false;
		xform = new XForm(convertStyle, latitudeRad);
		xform.presetEquat();
		setPositionDeg(0, 0, 270, 10, SidTDeg, 0, xform.position);
		xform.getEquat();
		results = trackingRates.getRatesViaDeltaTime(xform, timeIntervalSec, HAOffset, includeRefraction);		
		fiveMinuteAltErrorResultsArcSec = results.constantTrackRateAzError / uom.arcsecToRad;
		expected = 0;
		equal(withinRange(fiveMinuteAltErrorResultsArcSec, expected, allowedErrorArcsec), true, 'fiveMinuteAzErrorResults (arcsec) delta time w/o refraction should be ' + expected + ', is ' + fiveMinuteAltErrorResultsArcSec);

		// delta time w/ refraction
		includeRefraction = true;
		setPositionDeg(0, 0, 270, 10, SidTDeg, 0, xform.position);
		xform.getEquat();
		results = trackingRates.getRatesViaDeltaTime(xform, timeIntervalSec, HAOffset, includeRefraction);
		fiveMinuteAltErrorResultsArcSec = results.constantTrackRateAzError / uom.arcsecToRad;
		expected = -16.30;
		equal(withinRange(fiveMinuteAltErrorResultsArcSec, expected, allowedErrorArcsec), true, 'fiveMinuteAzErrorResults (arcsec) delta time w/ refraction should be ' + expected + ', is ' + fiveMinuteAltErrorResultsArcSec);

		// King rate
		setPositionDeg(0, 0, 270, 10, SidTDeg, 0, xform.position);
		xform.getEquat();
		results = trackingRates.getKingRates(xform, timeIntervalSec, HAOffset, includeRefraction);
		fiveMinuteAltErrorResultsArcSec = results.constantTrackRateAzError / uom.arcsecToRad;
		expected = 60.329;
		equal(withinRange(fiveMinuteAltErrorResultsArcSec, expected, allowedErrorArcsec), true, 'fiveMinuteAzErrorResults (arcsec) (King rate) should be ' + expected + ', is ' + fiveMinuteAltErrorResultsArcSec);

		// formula (w/o refraction; formula w/ refraction uses King rate)
		includeRefraction = false;
		xform = new XForm(convertStyle, latitudeRad);
		xform.presetEquat();
		setPositionDeg(0, 0, 270, 10, SidTDeg, 0, xform.position);
		xform.getEquat();
		results = trackingRates.getRatesViaFormulae(xform, timeIntervalSec, HAOffset, includeRefraction);
		fiveMinuteAltErrorResultsArcSec = results.constantTrackRateAzError / uom.arcsecToRad;
		expected = 0;
		equal(withinRange(fiveMinuteAltErrorResultsArcSec, expected, allowedErrorArcsec), true, 'fiveMinuteAzErrorResults (arcsec) formula w/o refraction should be ' + expected + ', is ' + fiveMinuteAltErrorResultsArcSec);
	});

	QUnit.module('investigate different init points for accuracy given realworld errors');
	
	QUnit.test('init points are altaz zenith and south horizon', function () {
		var latitudeRad = 35 * uom.degToRad,
		    convertStyle = ConvertStyle.matrix,
			xform,
			HAOffset = 0,
			includeRefraction = false,

		xform = new XForm(convertStyle, latitudeRad);
		xform.presetAltaz();
		xform.position.SidT = 0;

		xform.position.az = 0 * uom.degToRad;
		xform.position.alt = 90 * uom.degToRad;
		xform.getEquat();		
		// RA: 0, Dec: 35
		equal(true, true, '(deg) given SidT=' + xform.position.SidT / uom.degToRad + ', AZ=' + xform.position.az / uom.degToRad + ', alt=' + xform.position.alt / uom.degToRad + ', results RA: ' + xform.position.RA / uom.degToRad + ',  Dec: ' + xform.position.Dec / uom.degToRad);

		xform.position.az = 180 * uom.degToRad;
		xform.position.alt = 0 * uom.degToRad;
		xform.getEquat();		
		// RA: 0, Dec: -55
		equal(true, true, '(deg) given SidT=' + xform.position.SidT / uom.degToRad + ', AZ=' + xform.position.az / uom.degToRad + ', alt=' + xform.position.alt / uom.degToRad + ', results RA: ' + xform.position.RA / uom.degToRad + ',  Dec: ' + xform.position.Dec / uom.degToRad);
	});
	
	QUnit.test('find 2 init points as far apart in RA+Dec and az+alt as possible', function () {
		var latitudeRad = 35 * uom.degToRad,
		    convertStyle = ConvertStyle.matrix,
			xform,
			HAOffset = 0,
			includeRefraction = false,

		xform = new XForm(convertStyle, latitudeRad);
		xform.presetAltaz();
		xform.position.SidT = 0;

		xform.position.az = 45 * uom.degToRad;
		xform.position.alt = 60 * uom.degToRad;
		xform.getEquat();		
		// RA: 34.91009861045054, Dec: 51.84531532692444
		equal(true, true, '(deg) given SidT=' + xform.position.SidT / uom.degToRad + ', AZ=' + xform.position.az / uom.degToRad + ', alt=' + xform.position.alt / uom.degToRad + ', results RA: ' + xform.position.RA / uom.degToRad + ',  Dec: ' + xform.position.Dec / uom.degToRad);

		xform.position.az = 235 * uom.degToRad;
		xform.position.alt = 30 * uom.degToRad;
		xform.getEquat();		
		// RA: 314.3912378741873, Dec: -6.898486958580778
		equal(true, true, '(deg) given SidT=' + xform.position.SidT / uom.degToRad + ', AZ=' + xform.position.az / uom.degToRad + ', alt=' + xform.position.alt / uom.degToRad + ', results RA: ' + xform.position.RA / uom.degToRad + ',  Dec: ' + xform.position.Dec / uom.degToRad);
		
		equal(true, true, 'angular separation (deg) = ' + calcAngularSepUsingAltaz(new Position(0, 0, 45 / uom.degToRad, 60 / uom.degToRad, 0, 0), new Position(0, 0, 235 / uom.degToRad, 30 / uom.degToRad, 0, 0)) / uom.degToRad);
	});
	
	QUnit.test('find 2 init points with same alt', function () {
		var latitudeRad = 35 * uom.degToRad,
		    convertStyle = ConvertStyle.matrix,
			xform,
			HAOffset = 0,
			includeRefraction = false,

		xform = new XForm(convertStyle, latitudeRad);
		xform.presetAltaz();
		xform.position.SidT = 0;

		xform.position.az = 45 * uom.degToRad;
		xform.position.alt = 45 * uom.degToRad;
		xform.getEquat();		
		// RA: 59.677510196492726, Dec: 54.60277092323401 
		equal(true, true, '(deg) given SidT=' + xform.position.SidT / uom.degToRad + ', AZ=' + xform.position.az / uom.degToRad + ', alt=' + xform.position.alt / uom.degToRad + ', results RA: ' + xform.position.RA / uom.degToRad + ',  Dec: ' + xform.position.Dec / uom.degToRad);

		xform.position.az = 235 * uom.degToRad;
		xform.position.alt = 45 * uom.degToRad;
		xform.getEquat();		
		// RA: 324.493705198779, Dec: 4.206324033819533
		equal(true, true, '(deg) given SidT=' + xform.position.SidT / uom.degToRad + ', AZ=' + xform.position.az / uom.degToRad + ', alt=' + xform.position.alt / uom.degToRad + ', results RA: ' + xform.position.RA / uom.degToRad + ',  Dec: ' + xform.position.Dec / uom.degToRad);
	});
	
	QUnit.test('find 2 init points within 30 degrees', function () {
		var latitudeRad = 35 * uom.degToRad,
		    convertStyle = ConvertStyle.matrix,
			xform,
			HAOffset = 0,
			includeRefraction = false,

		xform = new XForm(convertStyle, latitudeRad);
		xform.presetAltaz();
		xform.position.SidT = 0;

		xform.position.az = 170 * uom.degToRad;
		xform.position.alt = 50 * uom.degToRad;
		xform.getEquat();		
		// RA: 6.428903549644681, Dec: -4.540077532708472
		equal(true, true, '(deg) given SidT=' + xform.position.SidT / uom.degToRad + ', AZ=' + xform.position.az / uom.degToRad + ', alt=' + xform.position.alt / uom.degToRad + ', results RA: ' + xform.position.RA / uom.degToRad + ',  Dec: ' + xform.position.Dec / uom.degToRad);

		xform.position.az = 190 * uom.degToRad;
		xform.position.alt = 40 * uom.degToRad;
		xform.getEquat();		
		// RA: 352.1049692231464, Dec: -14.435253883260346
		equal(true, true, '(deg) given SidT=' + xform.position.SidT / uom.degToRad + ', AZ=' + xform.position.az / uom.degToRad + ', alt=' + xform.position.alt / uom.degToRad + ', results RA: ' + xform.position.RA / uom.degToRad + ',  Dec: ' + xform.position.Dec / uom.degToRad);
	});
	
	QUnit.test('verify custom init algorithm (uses the find 2 init points within 30 degrees above)', function () {
		var allowedErrorArcsecond = 0.05,
		    allowedErrorDeg = allowedErrorArcsecond / 3600,
		    latitudeRad = 35 * uom.degToRad,
		    convertStyle = ConvertStyle.matrix,
			xform,
			resultAzDeg,
			resultAltDeg,
			expectedAzDeg = 170,
			expectedAltDeg = 50;

		xform = new XForm(convertStyle, latitudeRad);
		setPositionDeg(6.428903549644681, -4.540077532708472, 170, 50, 0, 0, xform.cmws.one);
		setPositionDeg(352.1049692231464, -14.435253883260346, 190, 40, 0, 0, xform.cmws.two);
		clearPosition(xform.cmws.three);
		initMatrixFacade(xform.cmws, 2);

		xform.position.SidT = 0;
		xform.position.RA = 6.428903549644681 * uom.degToRad;
		xform.position.Dec = -4.540077532708472 * uom.degToRad;
		xform.getAltaz();
		resultAzDeg = xform.position.az / uom.degToRad;
		resultAltDeg = xform.position.alt / uom.degToRad;
		equal(withinRange(expectedAzDeg, resultAzDeg, allowedErrorDeg), true, 'Az (deg) should be ' + expectedAzDeg + ', is ' + resultAzDeg);		
		equal(withinRange(expectedAltDeg, resultAltDeg, allowedErrorDeg), true, 'Alt (deg) should be ' + expectedAltDeg + ', is ' + resultAltDeg);		
	});

	// lat = 30N for the following inits

	function initStrategy (cmws, variances, initFunc) {
		initFunc(cmws, variances);
		clearPosition(cmws.three);
		initMatrixFacade(cmws, 2);
	};
	
	// presetAltaz()
	function initAltazEquatPoleAndMeridian90DegAway (cmws, variances) {
		initStrategy(cmws, variances, function (cmws, variances) {
			setPositionDeg(0, 90, 0 + variances[0] / Math.cos(35 * uom.degToRad), 35 + variances[1], 0, 0, cmws.one);
			setPositionDeg(0, 0, 180 + variances[2] / Math.cos(55 * uom.degToRad), 55 + variances[3], 0, 0, cmws.two);
		});
	};
	
	function initAltazZenithSouthHorizon (cmws, variances) {
		initStrategy(cmws, variances, function (cmws, variances) {
			// 1st position: since alt=90, az varies from 0 to 360; 2nd position: since alt=0, az not modified with variances
			setPositionDeg(0, 35, 0 + Math.random() * 360, 90 + variances[1], 0, 0, cmws.one);
			setPositionDeg(0, -55, 180 + variances[2], 0 + variances[3], 0, 0, cmws.two);
		});
	};
	
	// note that using the exact horizon of alt=0 causes tremendous errors in the initialization
	function initAltazOnNorthSouthHorizon (cmws, variances) {
		initStrategy(cmws, variances, function (cmws, variances) {
			setPositionDeg(180, 56, 0 + variances[0], 1 + variances[1], 0, 0, cmws.one);
			setPositionDeg(0, -54, 180 + variances[2], 1 + variances[3], 0, 0, cmws.two);
		});
	};
	
	function initAltazFartApart (cmws, variances) {
		initStrategy(cmws, variances, function (cmws, variances) {
			setPositionDeg(34.91009861045054, 51.84531532692444, 45 + variances[0] / Math.cos(60 * uom.degToRad), 60 + variances[1], 0, 0, cmws.one);
			setPositionDeg(314.3912378741873, -6.898486958580778, 235 + variances[2] / Math.cos(30 * uom.degToRad), 30 + variances[3], 0, 0, cmws.two);
		});
	};

	function initAltazSameAlt (cmws, variances) {
		initStrategy(cmws, variances, function (cmws, variances) {
			setPositionDeg(59.677510196492726, 54.60277092323401, 45 + variances[0] / Math.cos(45 * uom.degToRad), 45 + variances[1], 0, 0, cmws.one);
			setPositionDeg(324.493705198779, 4.206324033819533, 235 + variances[2] / Math.cos(45 * uom.degToRad), 45 + variances[3], 0, 0, cmws.two);
		});
	};

	// celestial pole, southern horizon
	function initAltaz135Apart (cmws, variances) {
		initStrategy(cmws, variances, function (cmws, variances) {
			setPositionDeg(0, 90, 0 + variances[0] / Math.cos(35 * uom.degToRad), 35 + variances[1], 0, 0, cmws.one);
			setPositionDeg(0, -55, 180 + variances[2], 0 + variances[3], 0, 0, cmws.two);
		});
	};

	function initAltaz30degApart (cmws, variances) {
		initStrategy(cmws, variances, function (cmws, variances) {
			setPositionDeg(6.428903549644681, -4.540077532708472, 170 + variances[0] / Math.cos(50 * uom.degToRad), 50 + variances[1], 0, 0, cmws.one);
			setPositionDeg(352.1049692231464, -14.435253883260346, 190 + variances[2] / Math.cos(40 * uom.degToRad), 40 + variances[3], 0, 0, cmws.two);
		});
	};
	
	var inits = [initAltazEquatPoleAndMeridian90DegAway, initAltazZenithSouthHorizon, initAltazOnNorthSouthHorizon, initAltazFartApart, initAltazSameAlt, initAltaz135Apart, initAltaz30degApart];

	function getRandomErrorDeg (maxErrorDeg) {
		return Math.random() * maxErrorDeg;
	};
	
	function createPerfectPositions (spacingDeg) {
		var latitudeRad = 35 * uom.degToRad,
		    convertStyle = ConvertStyle.matrix,
			xform,
			perfectPositions = [],
			altDeg,
			azSpacingDeg,
			azDeg;
		
		xform = new XForm(convertStyle, latitudeRad);
		// use default altaz init as coded in coordLib.js
		inits[0](xform.cmws, [0, 0, 0, 0]);

		for (altDeg = 0; altDeg < 90; altDeg += spacingDeg) {
			azSpacingDeg = spacingDeg / Math.cos(altDeg * uom.degToRad);
			for (azDeg = 0; azDeg < 360; azDeg += azSpacingDeg) {
				xform.position.SidT = 0;
				xform.position.az = azDeg * uom.degToRad;
				xform.position.alt = altDeg * uom.degToRad;
				xform.getEquat();
				perfectPositions.push(new Position(xform.position.RA, xform.position.Dec, xform.position.az, xform.position.alt, 0, 0));
			}
		}
		return perfectPositions;
	};
	
	function initWithRandomErrors (initIx) {
		var latitudeRad = 35 * uom.degToRad,
		    xform = new XForm(ConvertStyle.matrix, latitudeRad),
			maxErrorDeg = 1;

		inits[initIx](xform.cmws, [getRandomErrorDeg(maxErrorDeg), getRandomErrorDeg(maxErrorDeg), getRandomErrorDeg(maxErrorDeg), getRandomErrorDeg(maxErrorDeg)]);
		return xform;
	};
	
	QUnit.test('verify northSouthHorizon coordinates init position 1', function () {
		var allowedErrorArcsecond = 0.05,
		    allowedErrorDeg = allowedErrorArcsecond / 3600,
		    latitudeRad = 35 * uom.degToRad,
		    convertStyle = ConvertStyle.matrix,
			xform,
			resultRADeg,
			resultDecDeg,
			expectedRADeg = 180,
			expectedDecDeg = 55;

		xform = new XForm(convertStyle, latitudeRad);
		inits[0](xform.cmws, [0, 0, 0, 0]);

		xform.position.SidT = 0;
		xform.position.az = 0;
		xform.position.alt = 0;
		xform.getEquat();
		resultRADeg = xform.position.RA / uom.degToRad;
		resultDecDeg = xform.position.Dec / uom.degToRad;
		equal(withinRange(expectedRADeg, resultRADeg, allowedErrorDeg), true, 'RA (deg) should be ' + expectedRADeg + ', is ' + resultRADeg);		
		equal(withinRange(expectedDecDeg, resultDecDeg, allowedErrorDeg), true, 'Dec (deg) should be ' + expectedDecDeg + ', is ' + resultDecDeg);		
	});

	QUnit.test('verify northSouthHorizon coordinates init position 2', function () {
		var allowedErrorArcsecond = 0.05,
		    allowedErrorDeg = allowedErrorArcsecond / 3600,
		    latitudeRad = 35 * uom.degToRad,
		    convertStyle = ConvertStyle.matrix,
			xform,
			resultRADeg,
			resultDecDeg,
			expectedRADeg = 0,
			expectedDecDeg = -55;

		xform = new XForm(convertStyle, latitudeRad);
		inits[0](xform.cmws, [0, 0, 0, 0]);

		xform.position.SidT = 0;
		xform.position.az = 180 * uom.degToRad;
		xform.position.alt = 0;
		xform.getEquat();
		resultRADeg = xform.position.RA / uom.degToRad;
		resultDecDeg = xform.position.Dec / uom.degToRad;
		equal(withinRange(expectedRADeg, resultRADeg, allowedErrorDeg), true, 'RA (deg) should be ' + expectedRADeg + ', is ' + resultRADeg);		
		equal(withinRange(expectedDecDeg, resultDecDeg, allowedErrorDeg), true, 'Dec (deg) should be ' + expectedDecDeg + ', is ' + resultDecDeg);		
	});

	QUnit.test('verify initAltaz30degApart', function () {
		var allowedErrorArcsecond = 0.05,
		    allowedErrorDeg = allowedErrorArcsecond / 3600,
		    latitudeRad = 35 * uom.degToRad,
		    convertStyle = ConvertStyle.matrix,
			xform,
			resultAzDeg,
			resultAltDeg,
			expectedAzDeg = 170,
			expectedAltDeg = 50;

		xform = new XForm(convertStyle, latitudeRad);
		//initAltaz30degApart(xform.cmws, [0, 0, 0, 0]);
		inits[4](xform.cmws, [0, 0, 0, 0]);

		xform.position.SidT = 0;
		xform.position.RA = 6.428903549644681 * uom.degToRad;
		xform.position.Dec = -4.540077532708472 * uom.degToRad;
		xform.getAltaz();
		resultAzDeg = xform.position.az / uom.degToRad;
		resultAltDeg = xform.position.alt / uom.degToRad;
		equal(withinRange(expectedAzDeg, resultAzDeg, allowedErrorDeg), true, 'Az (deg) should be ' + expectedAzDeg + ', is ' + resultAzDeg);		
		equal(withinRange(expectedAltDeg, resultAltDeg, allowedErrorDeg), true, 'Alt (deg) should be ' + expectedAltDeg + ', is ' + resultAltDeg);		
	});

	QUnit.test('verify initAltaz30degApart with altaz errors', function () {
		var allowedErrorArcsecond = 0.05,
		    allowedErrorDeg = allowedErrorArcsecond / 3600,
		    latitudeRad = 35 * uom.degToRad,
		    convertStyle = ConvertStyle.matrix,
			xform,
			resultAzDeg,
			resultAltDeg,
			expectedAzDeg = 170,
			expectedAltDeg = 50,
			maxErrorDeg = 1;

		xform = new XForm(convertStyle, latitudeRad);
		inits[4](xform.cmws, [getRandomErrorDeg(maxErrorDeg), getRandomErrorDeg(maxErrorDeg), getRandomErrorDeg(maxErrorDeg), getRandomErrorDeg(maxErrorDeg)]);

		xform.position.SidT = 0;
		xform.position.RA = 6.428903549644681 * uom.degToRad;
		xform.position.Dec = -4.540077532708472 * uom.degToRad;
		xform.getAltaz();
		resultAzDeg = xform.position.az / uom.degToRad;
		resultAltDeg = xform.position.alt / uom.degToRad;
		notEqual(withinRange(expectedAzDeg, resultAzDeg, allowedErrorDeg), true, 'Az (deg) should be ' + expectedAzDeg + ', is ' + resultAzDeg);		
		notEqual(withinRange(expectedAltDeg, resultAltDeg, allowedErrorDeg), true, 'Alt (deg) should be ' + expectedAltDeg + ', is ' + resultAltDeg);		
	});

	QUnit.test('verify all inits', function () {
		var allowedErrorArcsecond = 0.05,
		    allowedErrorDeg = allowedErrorArcsecond / 3600,
		    latitudeRad = 35 * uom.degToRad,
		    convertStyle = ConvertStyle.matrix,
			xform,
			resultRADeg,
			resultDecDeg,
			expectedRADeg =  34.437679678316364,
			expectedDecDeg = 10.143530341195495,
			ix,
			initCount = 7;

		for (ix = 0; ix < initCount; ix++) {
			xform = new XForm(convertStyle, latitudeRad);
			inits[ix](xform.cmws, [0, 0, 0, 0]);

			xform.position.SidT = 0;
			xform.position.az = 120 * uom.degToRad;
			xform.position.alt = 50 * uom.degToRad;
			xform.getEquat();
			resultRADeg = xform.position.RA / uom.degToRad;
			resultDecDeg = xform.position.Dec / uom.degToRad;
			equal(true, true, 'init# ' + ix);
			equal(withinRange(expectedRADeg, resultRADeg, allowedErrorDeg), true, 'RA (deg) should be ' + expectedRADeg + ', is ' + resultRADeg);
			equal(withinRange(expectedDecDeg, resultDecDeg, allowedErrorDeg), true, 'Dec (deg) should be ' + expectedDecDeg + ', is ' + resultDecDeg);
		}
	});

	QUnit.test('createPerfectPositions', function () {
		var spacingDeg = 30,
		    perfectPositions = createPerfectPositions(spacingDeg),
		    result = perfectPositions.length;

		// Firefox and Chrome return different results because their cos(alt) results in either 60 or 59.999... which adds an extra perfectPosition
		equal(result >=29 && result <=30, true, 'perfect position length should is ' + result + ', should be 29 or 30');
	});

	/*
	results:
		given randomly varying init error of 1 deg, average errors in degrees are (expected error = sqrt(.5^2+.5^2)=0.7):
		EquatPoleAndMeridian90DegAway 0.7
		ZenithSouthHorizon            0.6
		initAltazOnNorthSouthHorizon  7.9
		FarthestApart                 0.7
		SameAlt                       0.7
		initAltaz135Apart             0.8
		30degApart                    1.2
		
		init# 0: az error (deg) = 0.6079217451540107, alt error (deg) = 0.30096816575664015, total (deg) = 0.6783440756946391
		init# 1: az error (deg) = 0.4370348605865382, alt error (deg) = 0.35738176505732866, total (deg) = 0.5645539791405128
		init# 2: az error (deg) = 1.9947312174914567, alt error (deg) = 7.643766991398687, total (deg) = 7.899754834729435
		init# 3: az error (deg) = 0.6033945685336284, alt error (deg) = 0.33997592075127214, total (deg) = 0.692581137504162
		init# 4: az error (deg) = 0.602806878059878, alt error (deg) = 0.3056089383530997, total (deg) = 0.6758498024247734
		init# 5: az error (deg) = 0.4952340007682071, alt error (deg) = 0.6157031948782028, total (deg) = 0.7901564020496896
		init# 6: az error (deg) = 0.9309159632309724, alt error (deg) = 0.7359943574795378, total (deg) = 1.1867148877636813	
	*/
	QUnit.test('compare various inits for random errors', function () {
		var spacingDeg = 30,
		    perfectPositions = createPerfectPositions(spacingDeg),
			lengthPerfectPositions = perfectPositions.length,
			ppIx,
			initIx,
			xform,
			accumAzError = [0, 0, 0, 0, 0, 0, 0],
			accumAltError = [0, 0, 0, 0, 0, 0, 0],
			totalAzError,
			totalAltError,
			totalError,
			trials,
			numberTrials = 100,
			initCount = 7;
			
		for (trials = 0; trials < numberTrials; trials++) {
			for (initIx = 0; initIx < initCount; initIx++) {
				xform = initWithRandomErrors(initIx);
				// for each position in perfectPositions, grab equat coords and convert to altaz, comparing converted altaz to perfect altaz
				for (ppIx = 0; ppIx < lengthPerfectPositions; ppIx++) {
					copyPosition(perfectPositions[ppIx], xform.position);
					xform.getAltaz();
					accumAzError[initIx] += Math.abs(validHalfRev(xform.position.az - perfectPositions[ppIx].az)) * Math.cos(xform.position.alt) / lengthPerfectPositions;
					accumAltError[initIx] += Math.abs(xform.position.alt - perfectPositions[ppIx].alt) / lengthPerfectPositions;
				}
			}
		}
		for (initIx = 0; initIx < initCount; initIx++) {
			totalAzError = accumAzError[initIx] / uom.degToRad / numberTrials;
			totalAltError = accumAltError[initIx] / uom.degToRad / numberTrials;
			totalError = Math.sqrt(totalAzError * totalAzError + totalAltError * totalAltError);
			equal(true, true, 'init# ' + initIx + ': az error (deg) = ' + totalAzError + ', alt error (deg) = ' + totalAltError	+ ', total (deg) = ' + totalError);
		}
	});
	
	/*
	results:
		separation (deg) = 10: az error (deg) = 1.2363546934407827, alt error (deg) = 1.1341287458299665, total (deg) = 1.6777428110741244
		separation (deg) = 20: az error (deg) = 0.6987646298709792, alt error (deg) = 0.6629236948099974, total (deg) = 0.9631925213057174
		separation (deg) = 30: az error (deg) = 0.5650359036326905, alt error (deg) = 0.5226586596798358, total (deg) = 0.7696997121815322
		separation (deg) = 40: az error (deg) = 0.5079078082241125, alt error (deg) = 0.4987242166933869, total (deg) = 0.7118259520215979
		separation (deg) = 50: az error (deg) = 0.4247277839781765, alt error (deg) = 0.48188110802529643, total (deg) = 0.642341881520036
		separation (deg) = 60: az error (deg) = 0.7604227229498064, alt error (deg) = 0.40658395754521826, total (deg) = 0.8622953276642115
		separation (deg) = 70: az error (deg) = 0.6670644759446506, alt error (deg) = 0.32801880418713175, total (deg) = 0.7433514316712299
		separation (deg) = 80: az error (deg) = 0.6616024180458311, alt error (deg) = 0.30914007237096963, total (deg) = 0.7302638864887261
		separation (deg) = 90: az error (deg) = 0.5763151717012412, alt error (deg) = 0.30460094584317937, total (deg) = 0.651859581000073
		separation (deg) = 100: az error (deg) = 0.5588977045459367, alt error (deg) = 0.33201341696675934, total (deg) = 0.650076574868423
		separation (deg) = 110: az error (deg) = 0.5732328761780968, alt error (deg) = 0.33902453151168355, total (deg) = 0.6659831554162086
		separation (deg) = 120: az error (deg) = 0.5040608529477961, alt error (deg) = 0.40908085763515806, total (deg) = 0.6491721586435883
		separation (deg) = 130: az error (deg) = 0.4863679099411538, alt error (deg) = 0.45300948798110674, total (deg) = 0.6646588147474092
		separation (deg) = 140: az error (deg) = 0.4825110791508936, alt error (deg) = 0.5573950786225603, total (deg) = 0.7372287400637675
		separation (deg) = 150: az error (deg) = 0.5067580723835097, alt error (deg) = 0.6744868068951267, total (deg) = 0.8436445914017552
		separation (deg) = 160: az error (deg) = 0.6598710495242899, alt error (deg) = 0.9945162542928601, total (deg) = 1.1935210019320937
		separation (deg) = 170: az error (deg) = 1.2924314829897554, alt error (deg) = 1.989828362150067, total (deg) = 2.372719125610934
	*/
	QUnit.test('compare inits with range of separation', function () {
		var spacingDeg = 30,
		    perfectPositions = createPerfectPositions(spacingDeg),
			lengthPerfectPositions = perfectPositions.length,
			ppIx,
			initIx,
			xform,
			accumAzError = [],
			accumAltError = [],
			totalAzError,
			totalAltError,
			totalError,
			trials,
			numberTrials = 100,
			// designed to end near southern horizon
			initCount = 17,
			// don't change this because perfect positions generated using this latitude
			latitudeDeg = 35,
			latitudeRad = latitudeDeg * uom.degToRad,
		    xform,
			cmws,
			maxErrorDeg = 1,
			variances,
			initStepDegrees = 10,
			initSpacingDegrees,
			initDecDegrees,
			initAltDegrees,
			initAzDegrees;
			
		for (initIx = 0; initIx < initCount; initIx++) {
			accumAzError.push(0);
			accumAltError.push(0);
		}
		for (trials = 0; trials < numberTrials; trials++) {
			for (initIx = 0; initIx < initCount; initIx++) {

				// init starting with init#1 at equat pole and init#2 initStepDegrees away on meridian, ending with init#1 at equat pole and init#2 near southern horizon
				xform = new XForm(ConvertStyle.matrix, latitudeRad);
				cmws = xform.cmws;
				variances = [getRandomErrorDeg(maxErrorDeg), getRandomErrorDeg(maxErrorDeg), getRandomErrorDeg(maxErrorDeg), getRandomErrorDeg(maxErrorDeg)];
				initSpacingDegrees = initStepDegrees * (initIx + 1);
				initDecDegrees = 90 - initSpacingDegrees;
				initAltDegrees = latitudeDeg + initSpacingDegrees;
				// adjust for going through altaz pole
				if (initAltDegrees > 90) {
					initAltDegrees = 180 - initAltDegrees;
					initAzDegrees = 180;
				} else {
					initAzDegrees = 0;
				}
				initStrategy(cmws, variances, function (cmws, variances) {
					setPositionDeg(0, 90, 0 + variances[0] / Math.cos(latitudeDeg * uom.degToRad), latitudeDeg + variances[1], 0, 0, cmws.one);
					setPositionDeg(0, initDecDegrees, initAzDegrees + variances[2] / Math.cos(initAltDegrees * uom.degToRad), initAltDegrees + variances[3], 0, 0, cmws.two);
				});
			
				// for each position in perfectPositions, grab equat coords and convert to altaz, comparing converted altaz to perfect altaz
				for (ppIx = 0; ppIx < lengthPerfectPositions; ppIx++) {
					copyPosition(perfectPositions[ppIx], xform.position);
					xform.getAltaz();
					accumAzError[initIx] += Math.abs(validHalfRev(xform.position.az - perfectPositions[ppIx].az)) * Math.cos(xform.position.alt) / lengthPerfectPositions;
					accumAltError[initIx] += Math.abs(xform.position.alt - perfectPositions[ppIx].alt) / lengthPerfectPositions;
				}
			}
		}
		for (initIx = 0; initIx < initCount; initIx++) {
			totalAzError = accumAzError[initIx] / uom.degToRad / numberTrials;
			totalAltError = accumAltError[initIx] / uom.degToRad / numberTrials;
			totalError = Math.sqrt(totalAzError * totalAzError + totalAltError * totalAltError);
			equal(true, true, 'separation (deg) = ' + initStepDegrees * (initIx + 1) + ': az error (deg) = ' + totalAzError + ', alt error (deg) = ' + totalAltError	+ ', total (deg) = ' + totalError);
		}
	});
	
	/*
	volatility for spacing of 5 degrees, 500 trials, percent of trials that have 90% acceptable pointing (better than twice the initialization error)
		two columns: spacing in degrees, percent of acceptable initializations
		10	12.8
		20	43.8
		30	73.2
		40	91.4
		50	98.8
		60	56.2
		70	75.8
		80	87.8
		90	95
		100	98.6
		110	100
		120	99
		130	92.6
		140	73
		150	43.2
		160	14.4
	thoughts: the 2nd init point is at the scope's azimuth axis when the separation is 55 deg
	*/
	QUnit.test('volatility of pointing errors over a range of separation between initialization stars', function () {
		var spacingDeg = 30,
		    perfectPositions = createPerfectPositions(spacingDeg),
			lengthPerfectPositions = perfectPositions.length,
			ppIx,
			initIx,
			xform,
			accumAzError = [],
			accumAltError = [],
			totalAzError,
			totalAltError,
			totalError,
			trials,
			numberTrials = 100,
			// designed to end near southern horizon
			initCount = 17,
			// don't change this because perfect positions generated using this latitude
			latitudeDeg = 35,
			latitudeRad = latitudeDeg * uom.degToRad,
		    xform,
			cmws,
			maxErrorDeg = 1,
			variances,
			initStepDegrees = 10,
			initSpacingDegrees,
			initDecDegrees,
			initAltDegrees,
			initAzDegrees,
			azError,
			altError,
			angularError,
			errors = [];
			
		for (initIx = 0; initIx < initCount; initIx++) {
			accumAzError.push(0);
			accumAltError.push(0);
		}
		for (trials = 0; trials < numberTrials; trials++) {
			errors[trials] = [];
			for (initIx = 0; initIx < initCount; initIx++) {
				errors[trials][initIx] = [];

				// init starting with init#1 at equat pole and init#2 initStepDegrees away on meridian, ending with init#1 at equat pole and init#2 near southern horizon
				xform = new XForm(ConvertStyle.matrix, latitudeRad);
				cmws = xform.cmws;
				variances = [getRandomErrorDeg(maxErrorDeg), getRandomErrorDeg(maxErrorDeg), getRandomErrorDeg(maxErrorDeg), getRandomErrorDeg(maxErrorDeg)];
				initSpacingDegrees = initStepDegrees * (initIx + 1);
				initDecDegrees = 90 - initSpacingDegrees;
				initAltDegrees = latitudeDeg + initSpacingDegrees;
				// adjust for going through altaz pole
				if (initAltDegrees > 90) {
					initAltDegrees = 180 - initAltDegrees;
					initAzDegrees = 180;
				} else {
					initAzDegrees = 0;
				}
				initStrategy(cmws, variances, function (cmws, variances) {
					setPositionDeg(0, 90, 0 + variances[0] / Math.cos(latitudeDeg * uom.degToRad), latitudeDeg + variances[1], 0, 0, cmws.one);
					setPositionDeg(0, initDecDegrees, initAzDegrees + variances[2] / Math.cos(initAltDegrees * uom.degToRad), initAltDegrees + variances[3], 0, 0, cmws.two);
				});
			
				// for each position in perfectPositions, grab equat coords and convert to altaz, comparing converted altaz to perfect altaz
				for (ppIx = 0; ppIx < lengthPerfectPositions; ppIx++) {
					copyPosition(perfectPositions[ppIx], xform.position);
					xform.getAltaz();
					azError = Math.abs(validHalfRev(xform.position.az - perfectPositions[ppIx].az)) * Math.cos(xform.position.alt);
					altError = Math.abs(xform.position.alt - perfectPositions[ppIx].alt);
					angularError = Math.sqrt(azError * azError + altError * altError);
					errors[trials][initIx][ppIx] = angularError;
				}
			}
		}
		// how many trials (% of trials) had acceptable pointing (90% below threshold of double the average initialization error)
		var acceptableError = 1.4 * uom.degToRad;
		var ppErrorCount;
		var acceptablePpErrorCount = lengthPerfectPositions * 0.1;
		var trialErrorCount;
		for (initIx = 0; initIx < initCount; initIx++) {
			trialErrorCount = 0;
			for (trials = 0; trials < numberTrials; trials++) {
				for (ppErrorCount = 0, ppIx = 0; ppIx < lengthPerfectPositions; ppIx++) {
					angularError = errors[trials][initIx][ppIx];
					if (angularError > acceptableError) {
						ppErrorCount += 1;
					}
				}
				if (ppErrorCount > acceptablePpErrorCount) {
					trialErrorCount += 1;
				}
			}
			equal(true, true, 'separation (deg) = ' + initStepDegrees * (initIx + 1) + ', trialErrorCount = ' + trialErrorCount);
		}
	});
	
	/*
	errors per angular separation for close inits using these stars:
		Vega: RA 18h 36m 56s | Dec 38° 47.022'
		Deneb: RA 20h 41m 25.9s | Dec +45° 16' 49"
		Sadr (gamma Cygni): RA 20h 22m 13.70184s | Dec +40° 15' 24.0450"
		Altair: RA 19h 50m 47s | Dec 8° 52.098'
		separations:
			Vega to Deneb = 24 deg
			Vega to Sadr = 20 deg
			Deneb to Sadr = 6 deg
			Deneb to Altair = 
		see initializationErrorPlot.html for polar coordinate plots of errors for various star separations
	*/
	QUnit.test('pointing errors as function of distance from close init stars', function () {
		var VegaRADeg,
		    VegaDecDeg,
			expectedVegaRADeg = 279.23333333333335,
			expectedVegaDecDeg = 38.7837,
			expectedVegaAzDeg = 299.83990023991294,
			expectedVegaAltDeg = 27.499158714353655,
			DenebRADeg,
		    DenebDecDeg,
			expectedDenebRADeg = 310.35791666666665,
			expectedDenebDecDeg = 45.280277777777776,
			expectedDenebAzDeg = 300.884733594231,
			expectedDenebAltDeg = 51.33431233693868,
			SadrRADeg,
		    SadrDecDeg,
			expectedSadrRADeg = 305.557091,
			expectedSadrDecDeg = 40.256679166666665,
			expectedSadrAzDeg = 293.87497236155536,
			expectedSadrAltDeg = 47.23806627310548,
			AltairRADeg,
		    AltairDecDeg,
			expectedAltairRADeg = 297.6958333333333,
			expectedAltairDecDeg = 8.8683,
			expectedAltairAzDeg = 261.09243502469985,
			expectedAltairAltDeg = 27.684132893975374,
			FomalhautRADeg,
		    FomalhautDecDeg,
			expectedFomalhautRADeg = 344.4142416666666,
			expectedFomalhautDecDeg = -29.622913888888892,
			expectedFomalhautAzDeg = 194.78126988203408,
			expectedFomalhautAltDeg = 23.727672101958323,
			PolarisRADeg,
		    PolarisDecDeg,
			expectedPolarisRADeg = 37.954166666666666,
			expectedPolarisDecDeg = 89.2641,
			expectedPolarisAzDeg = 0.556483527754148,
			expectedPolarisAltDeg = 35.57899259406004,
			result,
			expected,
			allowedErrorArcsecond = 0.05,
		    allowedErrorDeg = allowedErrorArcsecond / 1000,
		    latitudeRad = 35 * uom.degToRad,
		    convertStyle = ConvertStyle.matrix,
			xform,
			cmws,
			variances,
			resultAzDeg,
			resultAltDeg,
			expectedAzDeg,
			expectedAltDeg,
			// spacingDeg = 1 for all sky pointing error plots
			spacingDeg = 30,
		    perfectPositions = createPerfectPositions(spacingDeg),
			lengthPerfectPositions = perfectPositions.length,
			trials,
			numberTrials = 100,
			maxErrorDeg = 1,
			ppIx,
			positionVega,
			positionDeneb,
			positionSadr,
			positionAltair,
			positionFomalhaut,
			positionPolaris,
			VegaDenebSeparationDeg,
			VegaSadrSeparationDeg,
			DenebSadrSeparationDeg,
			DenebAltairSeparationDeg,
			DenebFomalhautSeparationDeg,
			PolarisAltairSeparationDeg,
			PolarisFomalhautSeparationDeg,
			expectedVegaDenebSeparationDeg = 23.8482146529,
			expectedVegaSadrSeparationDeg = 20.2848421369,
			expectedDenebSadrSeparationDeg = 6.133963617,
			expectedDenebAltairSeparationDeg = 38.01387266,
			expectedDenebFomalhautSeparationDeg = 81.05180639,
			expectedPolarisAltairSeparationDeg = 81.26346421906294,
			expectedPolarisFomalhautSeparationDeg = 119.18387315603456,
			positionA,
			positionZ,
			separation,
			separations = [],
			azError,
			altError,
			totalError,
			errors = [],
			plot = [],
			sortedPlot,
			displayString;

		// get/test coordinates in degrees for the test stars
		VegaRADeg = parseCoordinateGetValueInRadians('18h 36m 56s').radians / uom.degToRad;
		result = VegaRADeg;
		expected = expectedVegaRADeg;
		equal(withinRange(result, expected, allowedErrorDeg), true, 'Vega RA (deg) should be ' + expected + ', is ' + result);
		VegaDecDeg = parseCoordinateGetValueInRadians("38° 47.022'").radians / uom.degToRad;
		result = VegaDecDeg;
		expected = expectedVegaDecDeg;
		equal(withinRange(result, expected, allowedErrorDeg), true, 'Vega Dec (deg) should be ' + expected + ', is ' + result);

		DenebRADeg = parseCoordinateGetValueInRadians('20h 41m 25.9s').radians / uom.degToRad;
		result = DenebRADeg;
		expected = expectedDenebRADeg;
		equal(withinRange(result, expected, allowedErrorDeg), true, 'Deneb RA (deg) should be ' + expected + ', is ' + result);
		DenebDecDeg = parseCoordinateGetValueInRadians('+45° 16\' 49"').radians / uom.degToRad;
		result = DenebDecDeg;
		expected = expectedDenebDecDeg;
		equal(withinRange(result, expected, allowedErrorDeg), true, 'Deneb Dec (deg) should be ' + expected + ', is ' + result);

		SadrRADeg = parseCoordinateGetValueInRadians('20h 22m 13.70184s').radians / uom.degToRad;
		result = SadrRADeg;
		expected = expectedSadrRADeg;
		equal(withinRange(result, expected, allowedErrorDeg), true, 'Sadr RA (deg) should be ' + expected + ', is ' + result);
		SadrDecDeg = parseCoordinateGetValueInRadians('+40° 15\' 24.0450"').radians / uom.degToRad;
		result = SadrDecDeg;
		expected = expectedSadrDecDeg;
		equal(withinRange(result, expected, allowedErrorDeg), true, 'Sadr Dec (deg) should be ' + expected + ', is ' + result);

		AltairRADeg = parseCoordinateGetValueInRadians('19h 50m 47s').radians / uom.degToRad;
		result = AltairRADeg;
		expected = expectedAltairRADeg;
		equal(withinRange(result, expected, allowedErrorDeg), true, 'Altair RA (deg) should be ' + expected + ', is ' + result);
		AltairDecDeg = parseCoordinateGetValueInRadians('8° 52.098\'').radians / uom.degToRad;
		result = AltairDecDeg;
		expected = expectedAltairDecDeg;
		equal(withinRange(result, expected, allowedErrorDeg), true, 'Altair Dec (deg) should be ' + expected + ', is ' + result);

		FomalhautRADeg = parseCoordinateGetValueInRadians('22h57m39.418s').radians / uom.degToRad;
		result = FomalhautRADeg;
		expected = expectedFomalhautRADeg;
		equal(withinRange(result, expected, allowedErrorDeg), true, 'Fomalhaut RA (deg) should be ' + expected + ', is ' + result);
		FomalhautDecDeg = parseCoordinateGetValueInRadians('-29°37\'22.49"').radians / uom.degToRad;
		result = FomalhautDecDeg;
		expected = expectedFomalhautDecDeg;
		equal(withinRange(result, expected, allowedErrorDeg), true, 'Fomalhaut Dec (deg) should be ' + expected + ', is ' + result);

		PolarisRADeg = parseCoordinateGetValueInRadians('2h 31m 49s').radians / uom.degToRad;
		result = PolarisRADeg;
		expected = expectedPolarisRADeg;
		equal(withinRange(result, expected, allowedErrorDeg), true, 'Polaris RA (deg) should be ' + expected + ', is ' + result);
		PolarisDecDeg = parseCoordinateGetValueInRadians('89° 15.846').radians / uom.degToRad;
		result = PolarisDecDeg;
		expected = expectedPolarisDecDeg;
		equal(withinRange(result, expected, allowedErrorDeg), true, 'Polaris Dec (deg) should be ' + expected + ', is ' + result);

		// get/test altaz for the test stars given perfect init, SidT=0
		xform = new XForm(convertStyle, latitudeRad);
		inits[0](xform.cmws, [0, 0, 0, 0]);
		xform.position.SidT = 0;

		xform.position.RA = expectedVegaRADeg * uom.degToRad;
		xform.position.Dec = expectedVegaDecDeg * uom.degToRad;
		xform.getAltaz();
		resultAzDeg = xform.position.az / uom.degToRad;
		resultAltDeg = xform.position.alt / uom.degToRad;
		expectedAzDeg = expectedVegaAzDeg;
		expectedAltDeg = expectedVegaAltDeg;
		equal(withinRange(expectedAzDeg, resultAzDeg, allowedErrorDeg), true, 'Vega az (deg) should be ' + expectedAzDeg + ', is ' + resultAzDeg);		
		equal(withinRange(expectedAltDeg, resultAltDeg, allowedErrorDeg), true, 'Vega alt (deg) should be ' + expectedAltDeg + ', is ' + resultAltDeg);		
	
		xform.position.RA = expectedDenebRADeg * uom.degToRad;
		xform.position.Dec = expectedDenebDecDeg * uom.degToRad;
		xform.getAltaz();
		resultAzDeg = xform.position.az / uom.degToRad;
		resultAltDeg = xform.position.alt / uom.degToRad;
		expectedAzDeg = expectedDenebAzDeg;
		expectedAltDeg = expectedDenebAltDeg;
		equal(withinRange(expectedAzDeg, resultAzDeg, allowedErrorDeg), true, 'Deneb az (deg) should be ' + expectedAzDeg + ', is ' + resultAzDeg);		
		equal(withinRange(expectedAltDeg, resultAltDeg, allowedErrorDeg), true, 'Deneb alt (deg) should be ' + expectedAltDeg + ', is ' + resultAltDeg);		
	
		xform.position.RA = expectedSadrRADeg * uom.degToRad;
		xform.position.Dec = expectedSadrDecDeg * uom.degToRad;
		xform.getAltaz();
		resultAzDeg = xform.position.az / uom.degToRad;
		resultAltDeg = xform.position.alt / uom.degToRad;
		expectedAzDeg = expectedSadrAzDeg;
		expectedAltDeg = expectedSadrAltDeg;
		equal(withinRange(expectedAzDeg, resultAzDeg, allowedErrorDeg), true, 'Sadr az (deg) should be ' + expectedAzDeg + ', is ' + resultAzDeg);		
		equal(withinRange(expectedAltDeg, resultAltDeg, allowedErrorDeg), true, 'Sadr alt (deg) should be ' + expectedAltDeg + ', is ' + resultAltDeg);		
	
		xform.position.RA = expectedAltairRADeg * uom.degToRad;
		xform.position.Dec = expectedAltairDecDeg * uom.degToRad;
		xform.getAltaz();
		resultAzDeg = xform.position.az / uom.degToRad;
		resultAltDeg = xform.position.alt / uom.degToRad;
		expectedAzDeg = expectedAltairAzDeg;
		expectedAltDeg = expectedAltairAltDeg;
		equal(withinRange(expectedAzDeg, resultAzDeg, allowedErrorDeg), true, 'Altair az (deg) should be ' + expectedAzDeg + ', is ' + resultAzDeg);		
		equal(withinRange(expectedAltDeg, resultAltDeg, allowedErrorDeg), true, 'Altair alt (deg) should be ' + expectedAltDeg + ', is ' + resultAltDeg);		
	
		xform.position.RA = expectedFomalhautRADeg * uom.degToRad;
		xform.position.Dec = expectedFomalhautDecDeg * uom.degToRad;
		xform.getAltaz();
		resultAzDeg = xform.position.az / uom.degToRad;
		resultAltDeg = xform.position.alt / uom.degToRad;
		expectedAzDeg = expectedFomalhautAzDeg;
		expectedAltDeg = expectedFomalhautAltDeg;
		equal(withinRange(expectedAzDeg, resultAzDeg, allowedErrorDeg), true, 'Fomalhaut az (deg) should be ' + expectedAzDeg + ', is ' + resultAzDeg);		
		equal(withinRange(expectedAltDeg, resultAltDeg, allowedErrorDeg), true, 'Fomalhaut alt (deg) should be ' + expectedAltDeg + ', is ' + resultAltDeg);		
	
		xform.position.RA = expectedPolarisRADeg * uom.degToRad;
		xform.position.Dec = expectedPolarisDecDeg * uom.degToRad;
		xform.getAltaz();
		resultAzDeg = xform.position.az / uom.degToRad;
		resultAltDeg = xform.position.alt / uom.degToRad;
		expectedAzDeg = expectedPolarisAzDeg;
		expectedAltDeg = expectedPolarisAltDeg;
		equal(withinRange(expectedAzDeg, resultAzDeg, allowedErrorDeg), true, 'Polaris az (deg) should be ' + expectedAzDeg + ', is ' + resultAzDeg);		
		equal(withinRange(expectedAltDeg, resultAltDeg, allowedErrorDeg), true, 'Polaris alt (deg) should be ' + expectedAltDeg + ', is ' + resultAltDeg);		
	
		// create Positions for each star
		positionVega = new Position();
		setPositionDeg(expectedVegaRADeg, expectedVegaDecDeg, expectedVegaAzDeg, expectedVegaAltDeg, 0, 0, positionVega);
		positionDeneb = new Position();
		setPositionDeg(expectedDenebRADeg, expectedDenebDecDeg, expectedDenebAzDeg, expectedDenebAltDeg, 0, 0, positionDeneb);
		positionSadr = new Position();
		setPositionDeg(expectedSadrRADeg, expectedSadrDecDeg, expectedSadrAzDeg, expectedSadrAltDeg, 0, 0, positionSadr);
		positionAltair = new Position();
		setPositionDeg(expectedAltairRADeg, expectedAltairDecDeg, expectedAltairAzDeg, expectedAltairAltDeg, 0, 0, positionAltair);
		positionFomalhaut = new Position();
		setPositionDeg(expectedFomalhautRADeg, expectedFomalhautDecDeg, expectedFomalhautAzDeg, expectedFomalhautAltDeg, 0, 0, positionFomalhaut);
		positionPolaris = new Position();
		setPositionDeg(expectedPolarisRADeg, expectedPolarisDecDeg, expectedPolarisAzDeg, expectedPolarisAltDeg, 0, 0, positionPolaris);

		// test the init using 2 of the stars
		xform = new XForm(ConvertStyle.matrix, latitudeRad);
		cmws = xform.cmws;
		variances = [0, 0, 0, 0];
		initStrategy(cmws, variances, function (cmws, variances) {
			copyPosition(positionVega, cmws.one);
			copyPosition(positionDeneb, cmws.two);
		});		
		xform.position.SidT = 0;
		xform.position.RA = expectedSadrRADeg * uom.degToRad;
		xform.position.Dec = expectedSadrDecDeg * uom.degToRad;
		xform.getAltaz();
		resultAzDeg = xform.position.az / uom.degToRad;
		resultAltDeg = xform.position.alt / uom.degToRad;
		expectedAzDeg = expectedSadrAzDeg;
		expectedAltDeg = expectedSadrAltDeg;
		equal(withinRange(expectedAzDeg, resultAzDeg, allowedErrorDeg), true, 'Sadr az (deg) should be ' + expectedAzDeg + ', is ' + resultAzDeg);		
		equal(withinRange(expectedAltDeg, resultAltDeg, allowedErrorDeg), true, 'Sadr alt (deg) should be ' + expectedAltDeg + ', is ' + resultAltDeg);		

		// show angular separations between our stars
		VegaDenebSeparationDeg = calcAngularSepUsingAltaz(positionVega, positionDeneb) / uom.degToRad;
		VegaSadrSeparationDeg = calcAngularSepUsingAltaz(positionVega, positionSadr) / uom.degToRad;
		DenebSadrSeparationDeg = calcAngularSepUsingAltaz(positionDeneb, positionSadr) / uom.degToRad;
		DenebAltairSeparationDeg = calcAngularSepUsingAltaz(positionDeneb, positionAltair) / uom.degToRad;
		DenebFomalhautSeparationDeg = calcAngularSepUsingAltaz(positionDeneb, positionFomalhaut) / uom.degToRad;
		PolarisAltairSeparationDeg = calcAngularSepUsingAltaz(positionPolaris, positionAltair) / uom.degToRad;
		PolarisFomalhautSeparationDeg = calcAngularSepUsingAltaz(positionPolaris, positionFomalhaut) / uom.degToRad;
		equal(withinRange(expectedVegaDenebSeparationDeg, VegaDenebSeparationDeg, allowedErrorDeg), true, 'Vega to Deneb distance (deg) = ' + VegaDenebSeparationDeg); 
		equal(withinRange(expectedVegaSadrSeparationDeg, VegaSadrSeparationDeg, allowedErrorDeg), true, 'Vega to Sadr distance (deg) = ' + VegaSadrSeparationDeg); 
		equal(withinRange(expectedDenebSadrSeparationDeg, DenebSadrSeparationDeg, allowedErrorDeg), true, 'Sadr to Deneb distance (deg) = ' + DenebSadrSeparationDeg); 
		equal(withinRange(expectedDenebAltairSeparationDeg, DenebAltairSeparationDeg, allowedErrorDeg), true, 'Altair to Deneb distance (deg) = ' + DenebAltairSeparationDeg); 
		equal(withinRange(expectedDenebFomalhautSeparationDeg, DenebFomalhautSeparationDeg, allowedErrorDeg), true, 'Fomalhaut to Deneb distance (deg) = ' + DenebFomalhautSeparationDeg); 
		equal(withinRange(expectedPolarisAltairSeparationDeg, PolarisAltairSeparationDeg, allowedErrorDeg), true, 'Polaris to Altair distance (deg) = ' + PolarisAltairSeparationDeg); 
		equal(withinRange(expectedPolarisFomalhautSeparationDeg, PolarisFomalhautSeparationDeg, allowedErrorDeg), true, 'Polaris to Fomalhaut distance (deg) = ' + PolarisFomalhautSeparationDeg); 

		// set the two stars that will be used
		positionA = new Position();
		positionZ = new Position();
		//copyPosition(positionVega, positionA);
		//copyPosition(positionSadr, positionA);
		//copyPosition(positionAltair, positionA);
		copyPosition(positionFomalhaut, positionA);
		copyPosition(positionDeneb, positionZ);
		
		// build separations...
		xform = new XForm(convertStyle, latitudeRad);
		xform.presetAltaz();
		xform.position.SidT = 0;
		
		// get mid-point between stars
		xform.position.RA = (positionA.RA + positionZ.RA) / 2;
		xform.position.Dec = (positionA.Dec + positionZ.Dec) / 2;
		xform.getAltaz();
		equal(true, true, 'mid point (deg) az = ' + xform.position.az / uom.degToRad + ', alt = ' + xform.position.alt / uom.degToRad);

		// ...separations array
		for (ppIx = 0; ppIx < lengthPerfectPositions; ppIx++) {
			separation = calcAngularSepUsingAltaz(new Position(0, 0, perfectPositions[ppIx].az, perfectPositions[ppIx].alt, 0, 0), new Position(0, 0, xform.position.az, xform.position.alt, 0, 0));
			separations.push(separation);
			// display the separation
			// equal(true, true, 'separation (deg) = ' + separation / uom.degToRad + ', az = ' + perfectPositions[ppIx].az / uom.degToRad +  ', alt = ' + perfectPositions[ppIx].alt / uom.degToRad);
		}

		// main loop
		for (trials = 0; trials < numberTrials; trials++) {
			xform = new XForm(ConvertStyle.matrix, latitudeRad);
			cmws = xform.cmws;
			// set Z123 here, before the inits, eg, setFabErrorsDeg(-0.04, 0.4, -1.63, cmws.fabErrors);
			variances = [getRandomErrorDeg(maxErrorDeg), getRandomErrorDeg(maxErrorDeg), getRandomErrorDeg(maxErrorDeg), getRandomErrorDeg(maxErrorDeg)];
			initStrategy(cmws, variances, function (cmws, variances) {
				copyPosition(positionA, cmws.one);
				copyPosition(positionZ, cmws.two);
				// increase az per altitude
				cmws.one.az += variances[0] * uom.degToRad / Math.cos(cmws.one.alt);
				cmws.one.alt += variances[1] * uom.degToRad;
				cmws.two.az += variances[2] * uom.degToRad / Math.cos(cmws.two.alt);
				cmws.two.alt += variances[3] * uom.degToRad;
			});		

			// for each position in perfectPositions, grab equat coords and convert to altaz, comparing converted altaz to perfect altaz
			for (ppIx = 0; ppIx < lengthPerfectPositions; ppIx++) {
				copyPosition(perfectPositions[ppIx], xform.position);
				xform.getAltaz();			
				// shrink az per altitude
				azError = Math.abs(validHalfRev(xform.position.az - perfectPositions[ppIx].az)) * Math.cos(xform.position.alt);
				altError = Math.abs(xform.position.alt - perfectPositions[ppIx].alt);
				totalError = Math.sqrt(azError * azError + altError * altError);
				
				if (isNaN(errors[ppIx])) {
					errors[ppIx] = 0;
				}
				errors[ppIx] += totalError / numberTrials;
			}
		}
			
		// create plot data
		for (ppIx = 0; ppIx < lengthPerfectPositions; ppIx++) {
			plot[ppIx] = {separation: separations[ppIx], error: errors[ppIx], azimuth: perfectPositions[ppIx].az, altitude: perfectPositions[ppIx].alt};
		}

		
		// http://bgrins.github.io/devtools-snippets/#console-save
		(function (console) {
			console.save = function (data, filename) {
				if (!data) {
					console.error('Console.save: No data')
					return;
				}
				if (!filename) filename = 'console.json'

				if (typeof data === "object") {
					data = JSON.stringify(data, undefined, 4)
				}
				var blob = new Blob([data], {type: 'text/json'}),
					e    = document.createEvent('MouseEvents'),
					a    = document.createElement('a');

				a.download = filename;
				a.href = window.URL.createObjectURL(blob);
				a.dataset.downloadurl =  ['text/json', a.download, a.href].join(':');
				e.initMouseEvent('click', true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
				a.dispatchEvent(e);
			 }
		})(console);


		/*
		// save display to file (appears in download area) (console.log not big enough and/or too slow)
		displayString = '';
		for (ppIx = 0; ppIx < lengthPerfectPositions; ppIx++) {
			displayString += '[' + mInt(plot[ppIx].separation / uom.degToRad) + ', ' +  plot[ppIx].error / uom.degToRad + ', ' +  mInt(plot[ppIx].azimuth / uom.degToRad) + ', ' +  mInt(plot[ppIx].altitude / uom.degToRad) + '],\n';
		}
		console.save(displayString);
		*/

		/*
		// sorted output to file
		displayString = '';
		sortedPlot = _.sortBy(plot, function (record) { return record.separation; });
		// display for spreadsheet graphing purposes
		for (ppIx = 0; ppIx < lengthPerfectPositions; ppIx++) {
			displayString += '[' + mInt(sortedPlot[ppIx].separation / uom.degToRad) + ', ' +  sortedPlot[ppIx].error / uom.degToRad + ', ' +  mInt(sortedPlot[ppIx].azimuth / uom.degToRad) + ', ' +  mInt(sortedPlot[ppIx].altitude / uom.degToRad) + '],\n';
		}
		console.save(displayString);
		*/		
	});
	
	/*
	A three axis mount, 'alt-alt-az', can be configured as an horizontal yoke mount on a platter. The platter is parallel to the ground with its axis pointing at the zenith. On the platter is the 'alt-alt' or 'el-el' portion that is most commonly constructed as a yoke mounted horizontally, sometimes with each yoke end in the shape of a horseshoe so that the telescope can swing down to the horizon. The primary axis of the yoke points to the horizon and the secondary axis rotates between the yoke's arms. By calculating the field rotation angle at the focal plane using a standard altazimuth conversion, then setting the platter's rotational angle to the field rotation, then using a new altazimuth conversion where the altazimuth's primary axis points at the horizon (think of a Dobsonian tipped over 90 degrees) and finally taking these azimuth and altitude angles to set the 'alt-alt' or 'el-el' horizonal yoke, the 3-axis telescope can be made to point at the object and maintain a constant field rotation angle at the focal plane.
	*/
	QUnit.module('3 axes');
	
	QUnit.test('3 axes coordinates - unfold algorithm', function () {
		// 1 arcsecond
		var allowedErrorDeg = 1 / 3600,
		    XFormSite,
			XFormYoke,
			HAOffset = 0,
		    latitudeRad = 40 * uom.degToRad,
			siteLatitudeDeg = 40,
			siteLatitudeRad = siteLatitudeDeg * uom.degToRad,
			siteSidTDeg = 15, 
			objectSiteAzDeg = 180,
			objectSiteAltDeg = 60,
			expectedSiteRADeg = 15, // siteSidTDeg
			objectSiteRADeg,
			expectedSiteDecDeg = 10, 
			objectSiteDecDeg,
			FRRad,
			FRDeg,
			expectedFRDeg = 0, 
			yokePoleRADeg,
			expectedYokePoleRADeg = 195, // 180+siteSidTDeg
			yokePoleDecDeg,
			expectedYokePoleDecDeg = 50,
			yokeSiteZenithRADeg,
			expectedYokeSiteZenithRADeg = 15, // siteSidTDeg
			yokeSiteZenithDecDeg,
			expectedYokeSiteZenithDecDeg = 40, 
			yokePolePosition = new Position(),
			yokeSiteZenithPosition = new Position(),
			yokeAzDeg,
			expectedYokeAzDeg = 360, 
			yokeAltDeg,
			expectedYokeAltDeg = -30, 
			a1Deg,
			a2Deg,
			a3Deg;
			
		// develop algorithm here in the unit test, testing as the algorithm unfolds...

		// site coordinate transform
		XFormSite = new XForm(ConvertStyle.matrix, siteLatitudeRad);
		XFormSite.presetAltaz();
		// test for object's equat
		setPositionDeg(0, 0, objectSiteAzDeg, objectSiteAltDeg, siteSidTDeg, 0, XFormSite.position);
		XFormSite.getEquat();
		objectSiteRADeg = XFormSite.position.RA / uom.degToRad,
		objectSiteDecDeg = XFormSite.position.Dec / uom.degToRad,
		FRRad = XFormSite.calcFieldRotationAngle(HAOffset);
		FRDeg = FRRad / uom.degToRad
		equal(withinRange(objectSiteRADeg, expectedSiteRADeg, allowedErrorDeg), true, 'RA (deg) should be ' + expectedSiteRADeg + ', is ' + objectSiteRADeg);
		equal(withinRange(objectSiteDecDeg, expectedSiteDecDeg, allowedErrorDeg), true, 'Dec (deg) should be ' + expectedSiteDecDeg + ', is ' + objectSiteDecDeg);
		equal(withinRange(FRDeg, expectedFRDeg, allowedErrorDeg), true, 'FR (deg) should be ' + expectedFRDeg + ', is ' + FRDeg);
		
		// rotate the platter (axis aimed at zenith) to match the field rotation found above; this orients the yoke's primary axis to a point along the horizon with offset from north equal to the field rotation;
		a1Deg = FRDeg;

		// the yoke's pole will be one initialization point: find the site's equat at that point (site's horizon of az=FRDeg, alt=0)
		setPositionDeg(0, 0, FRDeg, 0, siteSidTDeg, 0, XFormSite.position);
		XFormSite.getEquat();
		yokePoleRADeg = XFormSite.position.RA / uom.degToRad;
		yokePoleDecDeg = XFormSite.position.Dec / uom.degToRad;
		equal(withinRange(yokePoleRADeg, expectedYokePoleRADeg, allowedErrorDeg), true, 'yoke pole RA (deg) should be ' + expectedYokePoleRADeg + ', is ' + yokePoleRADeg);
		equal(withinRange(yokePoleDecDeg, expectedYokePoleDecDeg, allowedErrorDeg), true, 'yoke pole Dec (deg) should be ' + expectedYokePoleDecDeg + ', is ' + yokePoleDecDeg);
		setPositionDeg(yokePoleRADeg, yokePoleDecDeg, 0, 90, siteSidTDeg, 0, yokePolePosition);

		// yoke's second initialization point is site's zenith: find the site's equat at that point (site's zenith of az=FRDeg, alt=90)
		setPositionDeg(0, 0, FRDeg, 90, siteSidTDeg, 0, XFormSite.position);
		XFormSite.getEquat();
		yokeSiteZenithRADeg = XFormSite.position.RA / uom.degToRad;
		yokeSiteZenithDecDeg = XFormSite.position.Dec / uom.degToRad;
		equal(withinRange(yokeSiteZenithRADeg, expectedYokeSiteZenithRADeg, allowedErrorDeg), true, 'yoke site zenith RA (deg) should be ' + expectedYokeSiteZenithRADeg + ', is ' + yokeSiteZenithRADeg);
		equal(withinRange(yokeSiteZenithDecDeg, expectedYokeSiteZenithDecDeg, allowedErrorDeg), true, 'yoke site zenith Dec (deg) should be ' + expectedYokeSiteZenithDecDeg + ', is ' + yokeSiteZenithDecDeg);
		setPositionDeg(yokeSiteZenithRADeg, yokeSiteZenithDecDeg, 0, 0, siteSidTDeg, 0, yokeSiteZenithPosition);
		
		// yoke coordinate transform
		XFormYoke = new XForm(ConvertStyle.matrix, uom.qtrRev);
		copyPosition(yokePolePosition, XFormYoke.cmws.one);
		copyPosition(yokeSiteZenithPosition, XFormYoke.cmws.two);
		initMatrixFacade(XFormYoke.cmws, 2);

		// get yoke's altaz using object's equat
		setPositionDeg(objectSiteRADeg, objectSiteDecDeg, 0, 0, siteSidTDeg, 0, XFormYoke.position);
		XFormYoke.getAltaz();
		yokeAzDeg = XFormYoke.position.az / uom.degToRad;
		yokeAltDeg = XFormYoke.position.alt / uom.degToRad;
		equal(withinRange(yokeAzDeg, expectedYokeAzDeg, allowedErrorDeg), true, 'yoke az (deg) should be ' + expectedYokeAzDeg + ', is ' + yokeAzDeg);
		equal(withinRange(yokeAltDeg, expectedYokeAltDeg, allowedErrorDeg), true, 'yoke alt (deg) should be ' + expectedYokeAltDeg + ', is ' + yokeAltDeg);
		
		a2Deg = yokeAzDeg;
		a3Deg = yokeAltDeg;
		
		equal(withinRange(a1Deg, expectedFRDeg, allowedErrorDeg), true, 'a1 (deg) should be ' + expectedFRDeg + ', is ' + a1Deg);
		equal(withinRange(a2Deg, expectedYokeAzDeg, allowedErrorDeg), true, 'a1 (deg) should be ' + expectedYokeAzDeg + ', is ' + a2Deg);
		equal(withinRange(a3Deg, expectedYokeAltDeg, allowedErrorDeg), true, 'a1 (deg) should be ' + expectedYokeAltDeg + ', is ' + a3Deg);		
	});

	QUnit.test('3 axes coordinates - getAltAltAz()', function () {
		// 1 arcsecond
		var allowedErrorDeg = 1 / 3600,
			latitudeDeg = 40,
			RADeg = 15,
			DecDeg = 10,
			SidTDeg = 15,
			HAOffset = 0,
			expectedA1Deg = 0,
			expectedA2Deg = 360,
			expectedA3Deg = -30,
			threeAxis,
			results,
			resultsA1Deg,
			resultsA2Deg,
			resultsA3Deg;
		
		threeAxis = new ThreeAxis();
		results = threeAxis.getAltAltAz(latitudeDeg * uom.degToRad, RADeg * uom.degToRad, DecDeg * uom.degToRad, SidTDeg * uom.degToRad, HAOffset);
		resultsA1Deg = results.a1 / uom.degToRad;
		resultsA2Deg = results.a2 / uom.degToRad;
		resultsA3Deg = results.a3 / uom.degToRad;
		
		equal(withinRange(resultsA1Deg, expectedA1Deg, allowedErrorDeg), true, 'a1 (deg) should be ' + expectedA1Deg + ', is ' + resultsA1Deg);
		equal(withinRange(resultsA2Deg, expectedA2Deg, allowedErrorDeg), true, 'a2 (deg) should be ' + expectedA2Deg + ', is ' + resultsA2Deg);
		equal(withinRange(resultsA3Deg, expectedA3Deg, allowedErrorDeg), true, 'a3 (deg) should be ' + expectedA3Deg + ', is ' + resultsA3Deg);		
	});

	QUnit.test('3 axes coordinates - getAltAltAz() #2', function () {
		// 1 arcsecond
		var allowedErrorDeg = 1 / 3600,
			latitudeDeg = 40,
			RADeg = 2,
			DecDeg = 10,
			SidTDeg = 1,
			HAOffset = 0,
			expectedA1Deg = 358.4684,
			expectedA2Deg = 359.7472,
			expectedA3Deg = -30.0122,
			threeAxis,
			results,
			resultsA1Deg,
			resultsA2Deg,
			resultsA3Deg;
		
		threeAxis = new ThreeAxis();
		results = threeAxis.getAltAltAz(latitudeDeg * uom.degToRad, RADeg * uom.degToRad, DecDeg * uom.degToRad, SidTDeg * uom.degToRad, HAOffset);
		resultsA1Deg = results.a1 / uom.degToRad;
		resultsA2Deg = results.a2 / uom.degToRad;
		resultsA3Deg = results.a3 / uom.degToRad;
		
		equal(withinRange(resultsA1Deg, expectedA1Deg, allowedErrorDeg), true, 'a1 (deg) should be ' + expectedA1Deg + ', is ' + resultsA1Deg);
		equal(withinRange(resultsA2Deg, expectedA2Deg, allowedErrorDeg), true, 'a2 (deg) should be ' + expectedA2Deg + ', is ' + resultsA2Deg);
		equal(withinRange(resultsA3Deg, expectedA3Deg, allowedErrorDeg), true, 'a3 (deg) should be ' + expectedA3Deg + ', is ' + resultsA3Deg);		
	});

	QUnit.test('3 axes coordinates - getAltAltAz() #3', function () {
		// 1 arcsecond
		var allowedErrorDeg = 1 / 3600,
			latitudeDeg = 40,
			RADeg = 45,
			DecDeg = 60,
			SidTDeg = 15,
			HAOffset = 0,
			expectedA1Deg = 236.5392,
			expectedA2Deg = 348.3345,
			expectedA3Deg = -24.8905,
			threeAxis,
			results,
			resultsA1Deg,
			resultsA2Deg,
			resultsA3Deg;
		
		threeAxis = new ThreeAxis();
		results = threeAxis.getAltAltAz(latitudeDeg * uom.degToRad, RADeg * uom.degToRad, DecDeg * uom.degToRad, SidTDeg * uom.degToRad, HAOffset);
		resultsA1Deg = results.a1 / uom.degToRad;
		resultsA2Deg = results.a2 / uom.degToRad;
		resultsA3Deg = results.a3 / uom.degToRad;
		
		equal(withinRange(resultsA1Deg, expectedA1Deg, allowedErrorDeg), true, 'a1 (deg) should be ' + expectedA1Deg + ', is ' + resultsA1Deg);
		equal(withinRange(resultsA2Deg, expectedA2Deg, allowedErrorDeg), true, 'a2 (deg) should be ' + expectedA2Deg + ', is ' + resultsA2Deg);
		equal(withinRange(resultsA3Deg, expectedA3Deg, allowedErrorDeg), true, 'a3 (deg) should be ' + expectedA3Deg + ', is ' + resultsA3Deg);		
	});

	QUnit.test('3 axes coordinates - getEquat()', function () {
		// 1 arcsecond
		var allowedErrorDeg = 1 / 3600,
			latitudeDeg = 40,
			SidTDeg = 15,
			a1Deg = 0,
			a2Deg = 0,
			a3Deg = -30,
			expectedRADeg = 15,
			expectedDecDeg = 10,
			threeAxis,
			results,
			resultRADeg,
			resultDecDeg;
		
		threeAxis = new ThreeAxis();
		results = threeAxis.getEquat(latitudeDeg * uom.degToRad, a1Deg * uom.degToRad, a2Deg * uom.degToRad, a3Deg * uom.degToRad, SidTDeg * uom.degToRad);
		resultRADeg = results.RA / uom.degToRad;
		resultDecDeg = results.Dec / uom.degToRad;
		
		equal(withinRange(resultRADeg, expectedRADeg, allowedErrorDeg), true, 'RA (deg) should be ' + expectedRADeg + ', is ' + resultRADeg);
		equal(withinRange(resultDecDeg, expectedDecDeg, allowedErrorDeg), true, 'Dec (deg) should be ' + expectedDecDeg + ', is ' + resultDecDeg);
	});

	QUnit.test('3 axes coordinates - getEquat() #2', function () {
		// 1 arcsecond
		var allowedErrorDeg = 1 / 3600,
			latitudeDeg = 40,
			SidTDeg = 1,
			a1Deg = 358.4684,
			a2Deg = 359.7472,
			a3Deg = -30.0122,
			expectedRADeg = 2,
			expectedDecDeg = 10,
			threeAxis,
			results,
			resultRADeg,
			resultDecDeg;
		
		threeAxis = new ThreeAxis();
		results = threeAxis.getEquat(latitudeDeg * uom.degToRad, a1Deg * uom.degToRad, a2Deg * uom.degToRad, a3Deg * uom.degToRad, SidTDeg * uom.degToRad);
		resultRADeg = results.RA / uom.degToRad;
		resultDecDeg = results.Dec / uom.degToRad;
		
		equal(withinRange(resultRADeg, expectedRADeg, allowedErrorDeg), true, 'RA (deg) should be ' + expectedRADeg + ', is ' + resultRADeg);
		equal(withinRange(resultDecDeg, expectedDecDeg, allowedErrorDeg), true, 'Dec (deg) should be ' + expectedDecDeg + ', is ' + resultDecDeg);
	});

	QUnit.test('3 axes coordinates - getEquat() #3', function () {
		// 1 arcsecond
		var allowedErrorDeg = 1 / 3600,
			latitudeDeg = 40,
			SidTDeg = 15,
			a1Deg = 236.5392,
			a2Deg = 348.3345,
			a3Deg = -24.8905,
			expectedRADeg = 45,
			expectedDecDeg = 60,
			threeAxis,
			results,
			resultRADeg,
			resultDecDeg;

		threeAxis = new ThreeAxis();
		results = threeAxis.getEquat(latitudeDeg * uom.degToRad, a1Deg * uom.degToRad, a2Deg * uom.degToRad, a3Deg * uom.degToRad, SidTDeg * uom.degToRad);
		resultRADeg = results.RA / uom.degToRad;
		resultDecDeg = results.Dec / uom.degToRad;
		
		equal(withinRange(resultRADeg, expectedRADeg, allowedErrorDeg), true, 'RA (deg) should be ' + expectedRADeg + ', is ' + resultRADeg);
		equal(withinRange(resultDecDeg, expectedDecDeg, allowedErrorDeg), true, 'Dec (deg) should be ' + expectedDecDeg + ', is ' + resultDecDeg);
	});

	QUnit.test('3 axes coordinates - getAltAltAzTrackingRates()', function () {
		// 1 arcsecond
		var allowedErrorDeg = 1 / 3600,
			latitudeDeg = 40,
			RADeg = 15,
			DecDeg = 10,
			SidTDeg = 15,
			HAOffset = 0,
			expectedA1Deg = 0,
			expectedA2Deg = 360,
			expectedA3Deg = -30,
			expectedA1RateArcsecSec = 23.0441,
			expectedA2RateArcsecSec = 3.7995,
			expectedA3RateArcsecSec = -0.0230,
			timeIntervalSec = 30,
			threeAxis,
			results,
			resultsA1Deg,
			resultsA2Deg,
			resultsA3Deg,
			resultsA1RateArcsecSec,
			resultsA2RateArcsecSec,
			resultsA3RateArcsecSec;
		
		threeAxis = new ThreeAxis();
		results = threeAxis.getAltAltAzTrackingRates(latitudeDeg * uom.degToRad, RADeg * uom.degToRad, DecDeg * uom.degToRad, SidTDeg * uom.degToRad, HAOffset, timeIntervalSec);
		resultsA1Deg = results.a1 / uom.degToRad;
		resultsA2Deg = results.a2 / uom.degToRad;
		resultsA3Deg = results.a3 / uom.degToRad;
		resultsA1RateArcsecSec = results.changeA1 / uom.arcsecToRad;
		resultsA2RateArcsecSec = results.changeA2 / uom.arcsecToRad;
		resultsA3RateArcsecSec = results.changeA3 / uom.arcsecToRad;
		
		equal(withinRange(resultsA1Deg, expectedA1Deg, allowedErrorDeg), true, 'a1 (deg) should be ' + expectedA1Deg + ', is ' + resultsA1Deg);
		equal(withinRange(resultsA2Deg, expectedA2Deg, allowedErrorDeg), true, 'a2 (deg) should be ' + expectedA2Deg + ', is ' + resultsA2Deg);
		equal(withinRange(resultsA3Deg, expectedA3Deg, allowedErrorDeg), true, 'a3 (deg) should be ' + expectedA3Deg + ', is ' + resultsA3Deg);		
		equal(withinRange(resultsA1RateArcsecSec, expectedA1RateArcsecSec, allowedErrorDeg), true, 'a1 rate (arcsec/sec) should be ' + expectedA1RateArcsecSec + ', is ' + resultsA1RateArcsecSec);
		equal(withinRange(resultsA2RateArcsecSec, expectedA2RateArcsecSec, allowedErrorDeg), true, 'a2 rate (arcsec/sec) should be ' + expectedA2RateArcsecSec + ', is ' + resultsA2RateArcsecSec);
		equal(withinRange(resultsA3RateArcsecSec, expectedA3RateArcsecSec, allowedErrorDeg), true, 'a3 rate (arcsec/sec) should be ' + expectedA3RateArcsecSec + ', is ' + resultsA3RateArcsecSec);		
	});

	QUnit.test('3 axes coordinates - getAltAltAzTrackingRates() #2', function () {
		// 1 arcsecond
		var allowedErrorDeg = 1 / 3600,
			latitudeDeg = 40,
			RADeg = 45,
			DecDeg = 60,
			SidTDeg = 15,
			HAOffset = 0,
			expectedA1Deg = 236.5392,
			expectedA2Deg = 348.3345,
			expectedA3Deg = -24.8905,
			expectedA1RateArcsecSec = -21.0770,
			expectedA2RateArcsecSec = 8.4939,
			expectedA3RateArcsecSec = 3.2076,
			timeIntervalSec = 30,
			threeAxis,
			results,
			resultsA1Deg,
			resultsA2Deg,
			resultsA3Deg,
			resultsA1RateArcsecSec,
			resultsA2RateArcsecSec,
			resultsA3RateArcsecSec;
		
		threeAxis = new ThreeAxis();
		results = threeAxis.getAltAltAzTrackingRates(latitudeDeg * uom.degToRad, RADeg * uom.degToRad, DecDeg * uom.degToRad, SidTDeg * uom.degToRad, HAOffset, timeIntervalSec);
		resultsA1Deg = results.a1 / uom.degToRad;
		resultsA2Deg = results.a2 / uom.degToRad;
		resultsA3Deg = results.a3 / uom.degToRad;
		resultsA1RateArcsecSec = results.changeA1 / uom.arcsecToRad;
		resultsA2RateArcsecSec = results.changeA2 / uom.arcsecToRad;
		resultsA3RateArcsecSec = results.changeA3 / uom.arcsecToRad;
		
		equal(withinRange(resultsA1Deg, expectedA1Deg, allowedErrorDeg), true, 'a1 (deg) should be ' + expectedA1Deg + ', is ' + resultsA1Deg);
		equal(withinRange(resultsA2Deg, expectedA2Deg, allowedErrorDeg), true, 'a2 (deg) should be ' + expectedA2Deg + ', is ' + resultsA2Deg);
		equal(withinRange(resultsA3Deg, expectedA3Deg, allowedErrorDeg), true, 'a3 (deg) should be ' + expectedA3Deg + ', is ' + resultsA3Deg);		
		equal(withinRange(resultsA1RateArcsecSec, expectedA1RateArcsecSec, allowedErrorDeg), true, 'a1 rate (arcsec/sec) should be ' + expectedA1RateArcsecSec + ', is ' + resultsA1RateArcsecSec);
		equal(withinRange(resultsA2RateArcsecSec, expectedA2RateArcsecSec, allowedErrorDeg), true, 'a2 rate (arcsec/sec) should be ' + expectedA2RateArcsecSec + ', is ' + resultsA2RateArcsecSec);
		equal(withinRange(resultsA3RateArcsecSec, expectedA3RateArcsecSec, allowedErrorDeg), true, 'a3 rate (arcsec/sec) should be ' + expectedA3RateArcsecSec + ', is ' + resultsA3RateArcsecSec);		
	});

});

</script>
</html>